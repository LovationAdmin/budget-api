=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\.env.example
=========================================
# Database Configuration
DATABASE_URL=postgresql://budget_db_uz3l_user:DfWCVdVQulVBIe0L6XvDcpyadrNyRQIl@dpg-d4n1379r0fns73ajeob0-a/budget_db_uz3l

# JWT Configuration
JWT_SECRET=test
JWT_EXPIRY=15m
REFRESH_EXPIRY=168h

# Frontend URL (for CORS and email links)
FRONTEND_URL=http://localhost:3000

# Email Configuration (Resend)
RESEND_API_KEY=re_test
FROM_EMAIL=Budget Famille <noreply@budgetfamille.com>

# Server Configuration
PORT=8080
ENVIRONMENT=development

BRIDGE_CLIENT_ID=your_client_id_here
BRIDGE_CLIENT_SECRET=your_client_secret_here
BRIDGE_ENV=sandbox  

ANTHROPIC_API_KEY=key
ADMIN_SECRET=test

ENABLE_BANKING_APP_ID=xxxxf836-6cd4-0000-b398-77fxxxxef930
ENABLE_BANKING_PRIVATE_KEY_PATH=./private-key.pem
ENABLE_BANKING_PRIVATE_KEY_BASE64=test

CACHE_DURATION_DAYS=30
DEFAULT_USER_COUNTRY=FR



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\.gitignore
=========================================
# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
main
budget-api

# Test binary
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# Environment files
.env
.env.local
.env.*.local

# IDE files
.idea/
.vscode/
*.swp
*.swo
*~

# OS files
.DS_Store
Thumbs.db

# Logs
*.log

# Temporary files
tmp/
temp/



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\DEPLOYMENT.md
=========================================




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\Dockerfile
=========================================
# Build stage
FROM golang:1.21-alpine AS builder

# Install build dependencies
RUN apk add --no-cache git

# Set working directory
WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Final stage
FROM alpine:latest

# Install ca-certificates for HTTPS
RUN apk --no-cache add ca-certificates

WORKDIR /root/

# Copy the binary from builder
COPY --from=builder /app/main .

# Expose port
EXPOSE 8080

# Run the application
CMD ["./main"]



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\go.mod
=========================================
module budget-api

go 1.21

require (
	github.com/gin-contrib/cors v1.5.0
	github.com/gin-gonic/gin v1.9.1
	github.com/golang-jwt/jwt/v5 v5.2.0
	github.com/google/uuid v1.5.0
	github.com/joho/godotenv v1.5.1
	github.com/lib/pq v1.10.9
	github.com/pquerna/otp v1.4.0
	golang.org/x/crypto v0.17.0
	github.com/olahol/melody v1.1.4
	github.com/kr/text v0.2.0
)



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\main.go
=========================================
package main

import (
	"context"
	"log"
	"os"
	"time"
	"database/sql"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	
	"budget-api/config"
	"budget-api/middleware"
	"budget-api/handlers"
	"budget-api/routes"
	"budget-api/services"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found")
	}

	// Initialize database connection
	db, err := config.InitDB()
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}
	defer db.Close()

	// Run migrations
	if err := config.RunMigrations(db); err != nil {
		log.Fatal("Failed to run migrations:", err)
	}

	// â­ NOUVEAU: DÃ©marrer le nettoyage automatique du cache des suggestions
	go scheduleCacheCleaning(db)

	// Initialize WebSocket Handler
	wsHandler := handlers.NewWSHandler()

	// Initialize Gin router
	router := gin.Default()

	// CORS configuration
	frontendURL := os.Getenv("FRONTEND_URL")
	if frontendURL == "" {
		frontendURL = "http://localhost:3000" // Fallback pour dev local
	}

	allowedOrigins := []string{
		frontendURL,
		"https://budgetfamille.com",
		"https://www.budgetfamille.com",
		"https://budget-ui-two.vercel.app",
	}

	log.Printf("ðŸŒ CORS: Allowing origins:")
	for _, origin := range allowedOrigins {
		log.Printf("   - %s", origin)
	}

	corsConfig := cors.Config{
		AllowOrigins:     allowedOrigins,
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           86400, 
	}
	router.Use(cors.New(corsConfig))

	// Add logging middleware
	router.Use(func(c *gin.Context) {
		log.Printf("ðŸ“¨ %s %s from %s", c.Request.Method, c.Request.URL.Path, c.ClientIP())
		c.Next()
	})

	// Rate limiting middleware
	router.Use(middleware.RateLimiter())

	// API v1 routes
	v1 := router.Group("/api/v1")
	{
		// Public routes
		routes.SetupAuthRoutes(v1, db)
		
		// WebSocket Route (Protected check handled inside handler or via query token)
		v1.GET("/ws/budgets/:id", wsHandler.HandleWS)

		// Admin routes (non protÃ©gÃ©es pour l'instant, Ã  sÃ©curiser si besoin)
		routes.SetupAdminRoutes(v1, db)
		
		// â­ NOUVEAU: Admin routes pour suggestions (nettoyage cache)
		routes.SetupAdminSuggestionsRoutes(v1, db)

		// Protected routes
		protected := v1.Group("/")
		protected.Use(middleware.AuthMiddleware())
		{
			routes.SetupBudgetRoutes(protected, db) 
			routes.SetupUserRoutes(protected, db)
			routes.SetupInvitationRoutes(protected, db)
			routes.SetupEnableBankingRoutes(protected, db)
			
			// â­ NOUVEAU: Routes Market Suggestions
			routes.SetupMarketSuggestionsRoutes(protected, db)
		}
	}

	// Health check endpoint
	router.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"status": "ok",
			"service": "budget-api",
			"frontend_url": frontendURL,
		})
	})

	// Start server
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("ðŸš€ Server starting on port %s", port)
	log.Printf("ðŸ“Š Market Suggestions: Cache cleaning scheduled (every 24h)")
	
	if err := router.Run(":" + port); err != nil {
		log.Fatal("Failed to start server:", err)
	}
}

// â­ NOUVELLE FONCTION: Nettoyage automatique du cache des suggestions
// S'exÃ©cute tous les jours Ã  minuit pour supprimer les suggestions expirÃ©es
func scheduleCacheCleaning(db *sql.DB) {
	// Attendre le dÃ©marrage complet
	time.Sleep(5 * time.Second)
	
	log.Println("ðŸ§¹ Cache cleaning scheduler started")
	
	ticker := time.NewTicker(24 * time.Hour)
	defer ticker.Stop()

	// Nettoyer immÃ©diatement au dÃ©marrage
	cleanCache(db)

	// Puis nettoyer toutes les 24h
	for range ticker.C {
		cleanCache(db)
	}
}

func cleanCache(db *sql.DB) {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	aiService := services.NewClaudeAIService()
	marketAnalyzer := services.NewMarketAnalyzerService(db, aiService)

	if err := marketAnalyzer.CleanExpiredCache(ctx); err != nil {
		log.Printf("âŒ Failed to clean suggestions cache: %v", err)
	} else {
		log.Println("âœ… Suggestions cache cleaned successfully")
	}
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\Makefile
=========================================
.PHONY: help build run test clean docker-up docker-down

APP_NAME=budget-api
POSTGRES_CONTAINER=budget-postgres

help:
	@echo "Available commands:"
	@echo "  make setup       - Setup complete (Docker + deps)"
	@echo "  make run         - Run the API"
	@echo "  make test-api    - Test the API"
	@echo "  make docker-up   - Start PostgreSQL"
	@echo "  make docker-down - Stop PostgreSQL"

install:
	go mod download
	go mod tidy

build:
	go build -o $(APP_NAME) main.go

run:
	go run main.go

test-api:
	chmod +x test.sh
	./test.sh

docker-up:
	docker run --name $(POSTGRES_CONTAINER) \
		-e POSTGRES_PASSWORD=mysecret \
		-e POSTGRES_DB=budget_db \
		-p 5432:5432 \
		-d postgres:15 || docker start $(POSTGRES_CONTAINER)

docker-down:
	docker stop $(POSTGRES_CONTAINER) || true
	docker rm $(POSTGRES_CONTAINER) || true

setup: docker-up install
	@echo "âœ… Setup complete!"
	@echo "Create .env: cp .env.example .env"
	@echo "Then: make run"

clean:
	rm -f $(APP_NAME)



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\private-key.pem
=========================================




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\QUICKSTART.md
=========================================




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\README.md
=========================================
# Budget API - Backend Go

API REST pour Budget Famille avec JWT, 2FA, multi-utilisateurs.

## Quick Start

### 1. Setup

\`\`\`bash
# Start PostgreSQL
make docker-up

# Configure
cp .env.example .env
# Edit .env with your values

# Run
make run
\`\`\`

### 2. Test

\`\`\`bash
# Health check
curl http://localhost:8080/health

# Run all tests
make test-api
\`\`\`

## API Endpoints

### Auth
- `POST /api/v1/auth/signup` - Create account
- `POST /api/v1/auth/login` - Login

### Budgets
- `POST /api/v1/budgets` - Create budget
- `GET /api/v1/budgets` - List budgets
- `GET /api/v1/budgets/:id` - Get budget
- `PUT /api/v1/budgets/:id/data` - Update data
- `DELETE /api/v1/budgets/:id` - Delete budget

### Invitations
- `POST /api/v1/budgets/:id/invite` - Invite user
- `POST /api/v1/invitations/accept` - Accept invitation

### User
- `GET /api/v1/user/profile` - Get profile
- `PUT /api/v1/user/profile` - Update profile
- `POST /api/v1/user/2fa/setup` - Setup 2FA
- `POST /api/v1/user/2fa/verify` - Enable 2FA

## Environment Variables

\`\`\`bash
DATABASE_URL=postgres://user:pass@localhost:5432/budget_db
JWT_SECRET=your-secret-key
FRONTEND_URL=http://localhost:3000
RESEND_API_KEY=re_your_key
PORT=8080
\`\`\`

## Deploy on Render.com (Free)

1. Create PostgreSQL on Render
2. Create Web Service
3. Add environment variables
4. Deploy!

See DEPLOYMENT.md for details.

## Stack

- Go 1.21+
- Gin (web framework)
- PostgreSQL 15+
- JWT authentication
- TOTP 2FA
- Resend (emails)
\`\`\`

---

## File 24: QUICKSTART.md
`````markdown
# Quick Start - 5 Minutes

## 1. Start Database

\`\`\`bash
make docker-up
\`\`\`

## 2. Configure

\`\`\`bash
cp .env.example .env

# Edit .env:
DATABASE_URL=postgres://postgres:mysecret@localhost:5432/budget_db?sslmode=disable
JWT_SECRET=$(openssl rand -base64 32)
FRONTEND_URL=http://localhost:3000
\`\`\`

## 3. Run

\`\`\`bash
go mod download
go run main.go
\`\`\`

## 4. Test

\`\`\`bash
# Health check
curl http://localhost:8080/health

# Create user
curl -X POST http://localhost:8080/api/v1/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"Test1234","name":"Test"}'

# Run test suite
make test-api
\`\`\`

âœ… Done!
\`\`\`

---

## File 25: DEPLOYMENT.md
````markdown
# Deployment on Render.com

## Step 1: Create PostgreSQL

1. Go to render.com
2. New â†’ PostgreSQL
3. Name: budget-db
4. Region: Frankfurt
5. Plan: Free
6. Copy Internal Database URL

## Step 2: Create Web Service

1. New â†’ Web Service
2. Connect GitHub repo
3. Settings:
   - Name: budget-api
   - Runtime: Go
   - Build: `go build -o main`
   - Start: `./main`
   - Plan: Free

## Step 3: Environment Variables

Add in Render dashboard:

\`\`\`
DATABASE_URL=<Internal URL from Step 1>
JWT_SECRET=<random secret>
FRONTEND_URL=https://your-frontend.vercel.app
RESEND_API_KEY=<resend key>
PORT=8080
\`\`\`

## Step 4: Deploy

Push to GitHub â†’ Render auto-deploys!

\`\`\`bash
git push origin main
\`\`\`

## Test Production

\`\`\`bash
curl https://budget-api.onrender.com/health
\`\`\`

âœ… Done! API is live at: https://budget-api.onrender.com
\`\`\`

---


---

# ðŸš€ How to Use

## Option 1: Use setup.sh script
```bash
# 1. Run setup script
bash setup.sh

# 2. Copy-paste each file content from above into the corresponding file

# 3. Setup and run
make setup
make run
```

## Option 2: Manual creation
```bash
# 1. Create directory structure
mkdir -p config models handlers middleware routes utils

# 2. Copy each file content from this document

# 3. Paste into corresponding files:
# - main.go â†’ root
# - go.mod â†’ root
# - .env.example â†’ root
# - etc.

# 4. Run
make setup
make run
```

## File Checklist

- [x] 1. main.go
- [x] 2. go.mod
- [x] 3. .env.example
- [x] 4. .gitignore
- [x] 5. Dockerfile
- [x] 6. Makefile
- [x] 7. config/database.go
- [x] 8. models/user.go
- [x] 9. models/budget.go
- [x] 10. models/invitation.go
- [x] 11. utils/jwt.go
- [x] 12. utils/password.go
- [x] 13. utils/totp.go
- [x] 14. utils/email.go
- [x] 15. middleware/auth.go
- [x] 16. middleware/ratelimit.go
- [x] 17. routes/routes.go
- [x] 18. handlers/auth.go
- [x] 19. handlers/budget.go
- [x] 20. handlers/user.go
- [x] 21. handlers/invitation.go
- [x] 22. test.sh
- [x] 23. README.md
- [x] 24. QUICKSTART.md
- [x] 25. DEPLOYMENT.md

**Total: 25 files**

---

# âœ… Next Steps

1. Create all files
2. `cp .env.example .env`
3. Edit `.env` with your values
4. `make setup`
5. `make run`
6. `make test-api`

Done! ðŸŽ‰



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\test.sh
=========================================
#!/bin/bash

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

API_URL="${API_URL:-http://localhost:8080}"
TEST_EMAIL="test_$(date +%s)@example.com"
TEST_PASSWORD="TestPass123!"
TEST_NAME="Test User"

echo -e "${YELLOW}ðŸ§ª Budget API - Test Suite${NC}"
echo "API URL: $API_URL"
echo "=========================================="

echo -e "\n${YELLOW}1. Health Check${NC}"
curl -s "$API_URL/health" | grep -q "ok" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"

echo -e "\n${YELLOW}2. User Signup${NC}"
SIGNUP_RESPONSE=$(curl -s -X POST "$API_URL/api/v1/auth/signup" \
    -H "Content-Type: application/json" \
    -d "{\"email\":\"$TEST_EMAIL\",\"password\":\"$TEST_PASSWORD\",\"name\":\"$TEST_NAME\"}")

if echo "$SIGNUP_RESPONSE" | grep -q "access_token"; then
    echo -e "${GREEN}âœ“ Signup successful${NC}"
    ACCESS_TOKEN=$(echo "$SIGNUP_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
    USER_ID=$(echo "$SIGNUP_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
    echo "Token: ${ACCESS_TOKEN:0:50}..."
else
    echo -e "${RED}âœ— Signup failed${NC}"
    echo "$SIGNUP_RESPONSE"
    exit 1
fi

echo -e "\n${YELLOW}3. User Login${NC}"
LOGIN_RESPONSE=$(curl -s -X POST "$API_URL/api/v1/auth/login" \
    -H "Content-Type: application/json" \
    -d "{\"email\":\"$TEST_EMAIL\",\"password\":\"$TEST_PASSWORD\"}")
echo "$LOGIN_RESPONSE" | grep -q "access_token" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"

echo -e "\n${YELLOW}4. Get User Profile${NC}"
PROFILE_RESPONSE=$(curl -s -X GET "$API_URL/api/v1/user/profile" \
    -H "Authorization: Bearer $ACCESS_TOKEN")
echo "$PROFILE_RESPONSE" | grep -q "$TEST_EMAIL" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"

echo -e "\n${YELLOW}5. Create Budget${NC}"
BUDGET_RESPONSE=$(curl -s -X POST "$API_URL/api/v1/budgets" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -d '{"name":"Test Budget"}')

if echo "$BUDGET_RESPONSE" | grep -q "id"; then
    echo -e "${GREEN}âœ“ Budget creation successful${NC}"
    BUDGET_ID=$(echo "$BUDGET_RESPONSE" | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
    echo "Budget ID: $BUDGET_ID"
else
    echo -e "${RED}âœ— Budget creation failed${NC}"
fi

echo -e "\n${YELLOW}6. Get All Budgets${NC}"
BUDGETS_RESPONSE=$(curl -s -X GET "$API_URL/api/v1/budgets" \
    -H "Authorization: Bearer $ACCESS_TOKEN")
echo "$BUDGETS_RESPONSE" | grep -q "Test Budget" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"

if [ ! -z "$BUDGET_ID" ]; then
    echo -e "\n${YELLOW}7. Update Budget Data${NC}"
    BUDGET_DATA='{"data": {"budgetTitle": "Test Budget Updated","people": [],"charges": [],"projects": [],"yearlyData": {}}}'
    UPDATE_RESPONSE=$(curl -s -X PUT "$API_URL/api/v1/budgets/$BUDGET_ID/data" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $ACCESS_TOKEN" \
        -d "$BUDGET_DATA")
    echo "$UPDATE_RESPONSE" | grep -q "version" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"
fi

echo -e "\n${GREEN}ðŸŽ‰ All tests completed!${NC}"
echo ""
echo "Test User: $TEST_EMAIL"
echo "Password: $TEST_PASSWORD"
if [ ! -z "$BUDGET_ID" ]; then
    echo "Budget ID: $BUDGET_ID"
fi



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\config\database.go
=========================================
package config

import (
	"database/sql"
	"fmt"
	"os"

	_ "github.com/lib/pq"
)

func InitDB() (*sql.DB, error) {
	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		return nil, fmt.Errorf("DATABASE_URL environment variable is required")
	}

	db, err := sql.Open("postgres", dbURL)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5)

	return db, nil
}

func RunMigrations(db *sql.DB) error {
	migrations := []string{
		`CREATE EXTENSION IF NOT EXISTS "uuid-ossp"`,
		
		`CREATE TABLE IF NOT EXISTS users (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			email VARCHAR(255) UNIQUE NOT NULL,
			password_hash VARCHAR(255) NOT NULL,
			name VARCHAR(255) NOT NULL,
			totp_secret VARCHAR(255),
			totp_enabled BOOLEAN DEFAULT FALSE,
			email_verified BOOLEAN DEFAULT FALSE,
			avatar TEXT,
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS budgets (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			name VARCHAR(255) NOT NULL,
			owner_id UUID REFERENCES users(id) ON DELETE CASCADE,
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS budget_members (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE,
			user_id UUID REFERENCES users(id) ON DELETE CASCADE,
			role VARCHAR(50) DEFAULT 'member',
			permissions JSONB DEFAULT '{"read": true, "write": true}',
			joined_at TIMESTAMP DEFAULT NOW(),
			UNIQUE(budget_id, user_id)
		)`,
		
		`CREATE TABLE IF NOT EXISTS invitations (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE,
			email VARCHAR(255) NOT NULL,
			invited_by UUID REFERENCES users(id),
			token VARCHAR(255) UNIQUE NOT NULL,
			status VARCHAR(50) DEFAULT 'pending',
			expires_at TIMESTAMP NOT NULL,
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS budget_data (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE,
			data JSONB NOT NULL,
			version INTEGER DEFAULT 1,
			updated_by UUID REFERENCES users(id),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS audit_logs (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE,
			user_id UUID REFERENCES users(id),
			action VARCHAR(100) NOT NULL,
			changes JSONB,
			created_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS sessions (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID REFERENCES users(id) ON DELETE CASCADE,
			refresh_token VARCHAR(500) UNIQUE NOT NULL,
			expires_at TIMESTAMP NOT NULL,
			created_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE INDEX IF NOT EXISTS idx_budget_members_budget_id ON budget_members(budget_id)`,
		`CREATE INDEX IF NOT EXISTS idx_budget_members_user_id ON budget_members(user_id)`,
		`CREATE INDEX IF NOT EXISTS idx_budget_data_budget_id ON budget_data(budget_id)`,
		`CREATE INDEX IF NOT EXISTS idx_invitations_email ON invitations(email)`,
		`CREATE INDEX IF NOT EXISTS idx_invitations_token ON invitations(token)`,
		`CREATE INDEX IF NOT EXISTS idx_audit_logs_budget_id ON audit_logs(budget_id)`,
		`CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON sessions(user_id)`,

		`ALTER TABLE invitations ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT NOW()`,
		`ALTER TABLE users ADD COLUMN IF NOT EXISTS avatar TEXT`,

		`CREATE TABLE IF NOT EXISTS email_verifications (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID REFERENCES users(id) ON DELETE CASCADE,
			token VARCHAR(255) NOT NULL,
			expires_at TIMESTAMP NOT NULL,
			created_at TIMESTAMP DEFAULT NOW()
		)`,
		`CREATE INDEX IF NOT EXISTS idx_email_verifications_token ON email_verifications(token)`,

		// --- BRIDGE API BANKING TABLES (existing) ---
		`CREATE TABLE IF NOT EXISTS bank_connections (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
			institution_id VARCHAR(255) NOT NULL,
			institution_name VARCHAR(255),
			provider_connection_id VARCHAR(255) NOT NULL,
			encrypted_access_token TEXT,
			encrypted_refresh_token TEXT,
			expires_at TIMESTAMP,
			status VARCHAR(50) DEFAULT 'active',
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,

		`ALTER TABLE bank_connections ADD COLUMN IF NOT EXISTS budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE`,

		`ALTER TABLE bank_connections DROP CONSTRAINT IF EXISTS bank_connections_provider_connection_id_key`,
		`ALTER TABLE bank_connections DROP CONSTRAINT IF EXISTS unique_provider_connection_per_budget`,
		`ALTER TABLE bank_connections ADD CONSTRAINT unique_provider_connection_per_budget UNIQUE (provider_connection_id, budget_id)`,

		`CREATE TABLE IF NOT EXISTS bank_accounts (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			connection_id UUID NOT NULL REFERENCES bank_connections(id) ON DELETE CASCADE,
			external_account_id VARCHAR(255) NOT NULL,
			name VARCHAR(255),
			mask VARCHAR(10),
			currency VARCHAR(3) DEFAULT 'EUR',
			balance DECIMAL(20, 2) DEFAULT 0,
			is_savings_pool BOOLEAN DEFAULT FALSE,
			last_synced_at TIMESTAMP DEFAULT NOW()
		)`,

		`CREATE INDEX IF NOT EXISTS idx_bank_connections_user ON bank_connections(user_id)`,
		`CREATE INDEX IF NOT EXISTS idx_bank_accounts_connection ON bank_accounts(connection_id)`,
		`CREATE INDEX IF NOT EXISTS idx_bank_connections_budget ON bank_connections(budget_id)`,

		`CREATE TABLE IF NOT EXISTS label_mappings (
			normalized_label VARCHAR(255) PRIMARY KEY,
			category VARCHAR(50) NOT NULL,
			source VARCHAR(20) DEFAULT 'AI',
			created_at TIMESTAMP DEFAULT NOW()
		)`,
		`CREATE INDEX IF NOT EXISTS idx_label_mappings_label ON label_mappings(normalized_label)`,

		`ALTER TABLE bank_accounts DROP CONSTRAINT IF EXISTS unique_account_per_connection`,
		`ALTER TABLE bank_accounts ADD CONSTRAINT unique_account_per_connection UNIQUE (connection_id, external_account_id)`,

		// ============================================================================
		// --- ENABLE BANKING API TABLES (new) ---
		// ============================================================================
		`CREATE TABLE IF NOT EXISTS banking_connections (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
			budget_id UUID NOT NULL REFERENCES budgets(id) ON DELETE CASCADE,
			aspsp_name VARCHAR(255) NOT NULL,
			aspsp_country VARCHAR(2) NOT NULL,
			session_id UUID NOT NULL,
			access_token TEXT,
			refresh_token TEXT,
			expires_at TIMESTAMP,
			status VARCHAR(50) DEFAULT 'active',
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,

		`CREATE INDEX IF NOT EXISTS idx_banking_connections_user_budget ON banking_connections(user_id, budget_id)`,
		`CREATE INDEX IF NOT EXISTS idx_banking_connections_session ON banking_connections(session_id)`,
		`CREATE INDEX IF NOT EXISTS idx_banking_connections_status ON banking_connections(status)`,

		`ALTER TABLE banking_connections DROP CONSTRAINT IF EXISTS unique_banking_connection_per_budget`,
		`ALTER TABLE banking_connections ADD CONSTRAINT unique_banking_connection_per_budget 
			UNIQUE (user_id, budget_id, aspsp_name, aspsp_country)`,

		`CREATE TABLE IF NOT EXISTS banking_accounts (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			connection_id UUID NOT NULL REFERENCES banking_connections(id) ON DELETE CASCADE,
			account_id UUID NOT NULL,
			account_name VARCHAR(255),
			account_type VARCHAR(50),
			currency VARCHAR(3),
			balance DECIMAL(15,2),
			last_sync_at TIMESTAMP,
			created_at TIMESTAMP DEFAULT NOW()
		)`,

		`CREATE INDEX IF NOT EXISTS idx_banking_accounts_connection ON banking_accounts(connection_id)`,
		`CREATE INDEX IF NOT EXISTS idx_banking_accounts_last_sync ON banking_accounts(last_sync_at)`,

		`ALTER TABLE banking_accounts DROP CONSTRAINT IF EXISTS unique_banking_account_per_connection`,
		`ALTER TABLE banking_accounts ADD CONSTRAINT unique_banking_account_per_connection 
			UNIQUE (connection_id, account_id)`,

		// ============================================================================
		// --- MARKET SUGGESTIONS SYSTEM ---
		// ============================================================================

		// 1. Ajouter colonnes pour localisation utilisateur
		`ALTER TABLE users ADD COLUMN IF NOT EXISTS country VARCHAR(2) DEFAULT 'FR'`,
		`ALTER TABLE users ADD COLUMN IF NOT EXISTS postal_code VARCHAR(10)`,
		`CREATE INDEX IF NOT EXISTS idx_users_country ON users(country)`,

		// 2. Table principale pour le cache des suggestions de marchÃ©
		`CREATE TABLE IF NOT EXISTS market_suggestions (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			category VARCHAR(50) NOT NULL,
			country VARCHAR(2) NOT NULL,
			merchant_name VARCHAR(255),
			competitors JSONB NOT NULL,
			last_updated TIMESTAMP DEFAULT NOW(),
			expires_at TIMESTAMP,
			created_at TIMESTAMP DEFAULT NOW()
		)`,

		// Index pour optimiser les recherches
		`CREATE INDEX IF NOT EXISTS idx_market_suggestions_category_country 
		ON market_suggestions(category, country)`,

		`CREATE INDEX IF NOT EXISTS idx_market_suggestions_expires 
		ON market_suggestions(expires_at)`,

		`CREATE INDEX IF NOT EXISTS idx_market_suggestions_merchant 
		ON market_suggestions(merchant_name)`,

		// â­ CORRIGÃ‰: Contrainte unique avec index partiels
		`DROP INDEX IF EXISTS idx_unique_market_suggestion_null`,
		`DROP INDEX IF EXISTS idx_unique_market_suggestion_not_null`,

		`CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_market_suggestion_null
		ON market_suggestions (category, country)
		WHERE merchant_name IS NULL`,

		`CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_market_suggestion_not_null
		ON market_suggestions (category, country, merchant_name)
		WHERE merchant_name IS NOT NULL`,

		// 3. Table pour tracker l'utilisation de l'API Claude (monitoring des coÃ»ts)
		`CREATE TABLE IF NOT EXISTS ai_api_usage (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID REFERENCES users(id) ON DELETE SET NULL,
			request_type VARCHAR(50) NOT NULL,
			category VARCHAR(50),
			country VARCHAR(2),
			input_tokens INT DEFAULT 0,
			output_tokens INT DEFAULT 0,
			total_tokens INT DEFAULT 0,
			cost_usd DECIMAL(10, 6) DEFAULT 0,
			cache_hit BOOLEAN DEFAULT FALSE,
			duration_ms INT,
			created_at TIMESTAMP DEFAULT NOW()
		)`,

		// Index pour analytics
		`CREATE INDEX IF NOT EXISTS idx_ai_usage_user ON ai_api_usage(user_id)`,
		`CREATE INDEX IF NOT EXISTS idx_ai_usage_type ON ai_api_usage(request_type)`,
		`CREATE INDEX IF NOT EXISTS idx_ai_usage_created ON ai_api_usage(created_at)`,
		`CREATE INDEX IF NOT EXISTS idx_ai_usage_cache ON ai_api_usage(cache_hit)`,

		// 4. Table pour stocker les liens d'affiliation par pays
		`CREATE TABLE IF NOT EXISTS affiliate_links (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			category VARCHAR(50) NOT NULL,
			country VARCHAR(2) NOT NULL,
			provider_name VARCHAR(255) NOT NULL,
			affiliate_url TEXT NOT NULL,
			commission_rate DECIMAL(5, 2),
			is_active BOOLEAN DEFAULT TRUE,
			priority INT DEFAULT 0,
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,

		// Index
		`CREATE INDEX IF NOT EXISTS idx_affiliate_category_country 
		ON affiliate_links(category, country)`,

		`CREATE INDEX IF NOT EXISTS idx_affiliate_active 
		ON affiliate_links(is_active)`,

		// Contrainte unique
		`DROP INDEX IF EXISTS idx_unique_affiliate_link`,
		`CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_affiliate_link
		ON affiliate_links (category, country, provider_name)`,

		// 5. DonnÃ©es initiales pour liens d'affiliation France
		`INSERT INTO affiliate_links (category, country, provider_name, affiliate_url, commission_rate, priority) 
		VALUES 
			('INTERNET', 'FR', 'Ariase', 'https://www.ariase.com/box', 5.00, 1),
			('MOBILE', 'FR', 'Ariase', 'https://www.ariase.com/mobile', 5.00, 1),
			('ENERGY', 'FR', 'Papernest', 'https://www.papernest.com/energie/', 8.00, 1),
			('LOAN', 'FR', 'Meilleurtaux', 'https://www.meilleurtaux.com/', 10.00, 1)
		ON CONFLICT DO NOTHING`,

	}

	for _, migration := range migrations {
		if _, err := db.Exec(migration); err != nil {
			// We log errors but don't fail hard, as some "DROP CONSTRAINT" might fail if constraint doesn't exist
			// which is expected on a fresh DB vs an existing one.
			fmt.Printf("Migration notice: %v\n", err)
		}
	}

	return nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\admin.go
=========================================
// handlers/admin.go
package handlers

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"budget-api/utils"

	"github.com/gin-gonic/gin"
)

type AdminHandler struct {
	DB *sql.DB
}

// ============================================
// Migration Logic (intÃ©grÃ©e directement ici)
// ============================================

var MONTHS = []string{
	"Janvier", "FÃ©vrier", "Mars", "Avril", "Mai", "Juin",
	"Juillet", "AoÃ»t", "Septembre", "Octobre", "Novembre", "DÃ©cembre",
}

var MONTH_NAME_VARIANTS = map[string]string{
	"Janvier": "Janvier", "janvier": "Janvier",
	"FÃ©vrier": "FÃ©vrier", "fÃ©vrier": "FÃ©vrier", "Fevrier": "FÃ©vrier",
	"Mars": "Mars", "mars": "Mars",
	"Avril": "Avril", "avril": "Avril",
	"Mai": "Mai", "mai": "Mai",
	"Juin": "Juin", "juin": "Juin",
	"Juillet": "Juillet", "juillet": "Juillet",
	"AoÃ»t": "AoÃ»t", "aoÃ»t": "AoÃ»t", "Aout": "AoÃ»t",
	"Septembre": "Septembre", "septembre": "Septembre",
	"Octobre": "Octobre", "octobre": "Octobre",
	"Novembre": "Novembre", "novembre": "Novembre",
	"DÃ©cembre": "DÃ©cembre", "dÃ©cembre": "DÃ©cembre", "Decembre": "DÃ©cembre",
	// Encodage UTF-8 mojibake
	"FÃƒÂ©vrier":  "FÃ©vrier",
	"AoÃƒÂ»t":     "AoÃ»t",
	"DÃƒÂ©cembre": "DÃ©cembre",
}

type EncryptedDataWrapper struct {
	Encrypted string `json:"encrypted"`
}

func normalizeMonthName(monthKey string) (string, bool) {
	if normalized, ok := MONTH_NAME_VARIANTS[monthKey]; ok {
		return normalized, true
	}
	return "", false
}

func isMonthName(key string) bool {
	_, ok := normalizeMonthName(key)
	return ok
}

func getMonthIndex(monthName string) int {
	normalized, ok := normalizeMonthName(monthName)
	if !ok {
		return -1
	}
	for i, m := range MONTHS {
		if m == normalized {
			return i
		}
	}
	return -1
}

func isLegacyFormat(yearlyData map[string]interface{}) bool {
	for key := range yearlyData {
		if isMonthName(key) {
			return true
		}
	}
	return false
}

func isNewFormat(yearlyData map[string]interface{}) bool {
	for key, value := range yearlyData {
		if len(key) == 4 && key[0] >= '0' && key[0] <= '9' {
			if yearMap, ok := value.(map[string]interface{}); ok {
				if _, hasMonths := yearMap["months"]; hasMonths {
					return true
				}
			}
		}
	}
	return false
}

func migrateBudgetData(data map[string]interface{}) (map[string]interface{}, bool, error) {
	yearlyData, ok := data["yearlyData"].(map[string]interface{})
	if !ok || yearlyData == nil {
		return data, false, nil
	}

	if isNewFormat(yearlyData) {
		return data, false, nil
	}

	if !isLegacyFormat(yearlyData) {
		return data, false, nil
	}

	// DÃ©terminer l'annÃ©e cible depuis currentYear du budget
	targetYear := time.Now().Year()
	if cy, ok := data["currentYear"].(float64); ok {
		targetYear = int(cy)
	}
	yearKey := fmt.Sprintf("%d", targetYear)

	// Nouvelle structure
	newYearlyData := make(map[string]interface{})
	months := make([]map[string]interface{}, 12)
	expenses := make([]map[string]interface{}, 12)
	monthComments := make([]string, 12)
	expenseComments := make([]map[string]interface{}, 12)

	for i := 0; i < 12; i++ {
		months[i] = make(map[string]interface{})
		expenses[i] = make(map[string]interface{})
		monthComments[i] = ""
		expenseComments[i] = make(map[string]interface{})
	}

	// Migrer yearlyData (allocations projets)
	for monthKey, monthData := range yearlyData {
		idx := getMonthIndex(monthKey)
		if idx >= 0 && idx < 12 {
			if md, ok := monthData.(map[string]interface{}); ok {
				if _, hasMonths := md["months"]; !hasMonths {
					months[idx] = md
				}
			}
		}
	}

	// Migrer yearlyExpenses
	if ye, ok := data["yearlyExpenses"].(map[string]interface{}); ok {
		for monthKey, expenseData := range ye {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if ed, ok := expenseData.(map[string]interface{}); ok {
					expenses[idx] = ed
				}
			}
		}
	}

	// Migrer monthComments
	if mc, ok := data["monthComments"].(map[string]interface{}); ok {
		for monthKey, comment := range mc {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if c, ok := comment.(string); ok {
					monthComments[idx] = c
				}
			}
		}
	}

	// Migrer projectComments
	if pc, ok := data["projectComments"].(map[string]interface{}); ok {
		for monthKey, comments := range pc {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if pcm, ok := comments.(map[string]interface{}); ok {
					expenseComments[idx] = pcm
				}
			}
		}
	}

	// Migrer oneTimeIncomes
	if oti, ok := data["oneTimeIncomes"].(map[string]interface{}); ok {
		newOneTimeIncomes := make(map[string]interface{})
		newYearIncomes := make([]map[string]interface{}, 12)
		for i := 0; i < 12; i++ {
			newYearIncomes[i] = map[string]interface{}{"amount": float64(0), "description": ""}
		}
		for monthKey, income := range oti {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if amount, ok := income.(float64); ok {
					newYearIncomes[idx] = map[string]interface{}{"amount": amount, "description": ""}
				}
			}
		}
		newOneTimeIncomes[yearKey] = newYearIncomes
		data["oneTimeIncomes"] = newOneTimeIncomes
	}

	// Construire la nouvelle structure
	newYearlyData[yearKey] = map[string]interface{}{
		"months":          months,
		"expenses":        expenses,
		"monthComments":   monthComments,
		"expenseComments": expenseComments,
		"deletedMonths":   []int{},
	}

	data["yearlyData"] = newYearlyData
	data["version"] = "2.3-migrated"
	data["lastUpdated"] = time.Now().Format(time.RFC3339)

	// Nettoyer les anciens champs (optionnel, garde pour compatibilitÃ©)
	// delete(data, "yearlyExpenses")
	// delete(data, "monthComments")
	// delete(data, "projectComments")

	return data, true, nil
}

// ============================================
// HTTP Handlers
// ============================================

// MigrateAllBudgets migre tous les budgets vers le nouveau format
// POST /api/v1/admin/migrate-budgets
func (h *AdminHandler) MigrateAllBudgets(c *gin.Context) {
	// VÃ©rification du secret admin
	adminSecret := c.GetHeader("X-Admin-Secret")
	expectedSecret := os.Getenv("ADMIN_SECRET")

	if expectedSecret == "" {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "ADMIN_SECRET not configured"})
		return
	}

	if adminSecret != expectedSecret {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid admin secret"})
		return
	}

	// ExÃ©cuter la migration
	result, err := h.runMigration(c.Request.Context(), "")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, result)
}

// MigrateSingleBudget migre un seul budget
// POST /api/v1/admin/migrate-budget/:id
func (h *AdminHandler) MigrateSingleBudget(c *gin.Context) {
	// VÃ©rification du secret admin
	adminSecret := c.GetHeader("X-Admin-Secret")
	expectedSecret := os.Getenv("ADMIN_SECRET")

	if expectedSecret == "" {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "ADMIN_SECRET not configured"})
		return
	}

	if adminSecret != expectedSecret {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid admin secret"})
		return
	}

	budgetID := c.Param("id")
	if budgetID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Budget ID required"})
		return
	}

	result, err := h.runMigration(c.Request.Context(), budgetID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, result)
}

// runMigration exÃ©cute la migration pour un ou tous les budgets
func (h *AdminHandler) runMigration(ctx context.Context, budgetID string) (gin.H, error) {
	var query string
	var rows *sql.Rows
	var err error

	if budgetID != "" {
		query = `
			SELECT bd.budget_id, bd.data, b.name
			FROM budget_data bd
			JOIN budgets b ON bd.budget_id = b.id
			WHERE bd.budget_id = $1
		`
		rows, err = h.DB.QueryContext(ctx, query, budgetID)
	} else {
		query = `
			SELECT bd.budget_id, bd.data, b.name
			FROM budget_data bd
			JOIN budgets b ON bd.budget_id = b.id
			ORDER BY bd.updated_at DESC
		`
		rows, err = h.DB.QueryContext(ctx, query)
	}

	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}
	defer rows.Close()

	var migrated, skipped, errors int
	var details []gin.H

	for rows.Next() {
		var id string
		var rawJSON []byte
		var name string

		if err := rows.Scan(&id, &rawJSON, &name); err != nil {
			log.Printf("âŒ Scan error: %v", err)
			errors++
			continue
		}

		log.Printf("ðŸ“¦ Processing: %s (%s)", name, id)

		// 1. DÃ©crypter les donnÃ©es
		var data map[string]interface{}
		var wrapper EncryptedDataWrapper

		if err := json.Unmarshal(rawJSON, &wrapper); err == nil && wrapper.Encrypted != "" {
			// DonnÃ©es chiffrÃ©es
			decryptedBytes, err := utils.Decrypt(wrapper.Encrypted)
			if err != nil {
				log.Printf("  âŒ Decrypt error: %v", err)
				errors++
				details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": "decrypt failed"})
				continue
			}
			if err := json.Unmarshal(decryptedBytes, &data); err != nil {
				log.Printf("  âŒ Unmarshal error: %v", err)
				errors++
				details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": "unmarshal failed"})
				continue
			}
		} else {
			// DonnÃ©es non chiffrÃ©es (legacy)
			if err := json.Unmarshal(rawJSON, &data); err != nil {
				log.Printf("  âŒ Unmarshal error: %v", err)
				errors++
				details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": "unmarshal failed"})
				continue
			}
		}

		// 2. Migrer les donnÃ©es
		migratedData, wasMigrated, err := migrateBudgetData(data)
		if err != nil {
			log.Printf("  âŒ Migration error: %v", err)
			errors++
			details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": err.Error()})
			continue
		}

		if !wasMigrated {
			log.Printf("  â­ï¸  Already migrated or no migration needed")
			skipped++
			details = append(details, gin.H{"id": id, "name": name, "status": "skipped", "reason": "already new format"})
			continue
		}

		// 3. Re-chiffrer et sauvegarder
		migratedJSON, err := json.Marshal(migratedData)
		if err != nil {
			log.Printf("  âŒ Marshal error: %v", err)
			errors++
			continue
		}

		encryptedString, err := utils.Encrypt(migratedJSON)
		if err != nil {
			log.Printf("  âŒ Encrypt error: %v", err)
			errors++
			continue
		}

		newWrapper := EncryptedDataWrapper{Encrypted: encryptedString}
		storageJSON, err := json.Marshal(newWrapper)
		if err != nil {
			log.Printf("  âŒ Wrapper marshal error: %v", err)
			errors++
			continue
		}

		// 4. Mettre Ã  jour en base
		updateQuery := `
			UPDATE budget_data
			SET data = $1, version = version + 1, updated_at = $2
			WHERE budget_id = $3
		`
		if _, err := h.DB.ExecContext(ctx, updateQuery, storageJSON, time.Now(), id); err != nil {
			log.Printf("  âŒ Update error: %v", err)
			errors++
			details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": "db update failed"})
			continue
		}

		// Extraire l'annÃ©e cible pour le log
		targetYear := "unknown"
		if yd, ok := migratedData["yearlyData"].(map[string]interface{}); ok {
			for k := range yd {
				targetYear = k
				break
			}
		}

		log.Printf("  âœ… Migrated to year %s", targetYear)
		migrated++
		details = append(details, gin.H{"id": id, "name": name, "status": "migrated", "targetYear": targetYear})
	}

	return gin.H{
		"migrated": migrated,
		"skipped":  skipped,
		"errors":   errors,
		"details":  details,
	}, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\admin_suggestion_handler.go
=========================================
package handlers

import (
	"budget-api/services"
	"context"
	"database/sql"
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

type AdminSuggestionHandler struct {
	DB             *sql.DB
	MarketAnalyzer *services.MarketAnalyzerService
}

func NewAdminSuggestionHandler(db *sql.DB) *AdminSuggestionHandler {
	// Re-use existing services
	aiService := services.NewClaudeAIService()
	marketAnalyzer := services.NewMarketAnalyzerService(db, aiService)

	return &AdminSuggestionHandler{
		DB:             db,
		MarketAnalyzer: marketAnalyzer,
	}
}

// RetroactiveAnalysis iterates over ALL budgets, fixes categories, and warms the cache
func (h *AdminSuggestionHandler) RetroactiveAnalysis(c *gin.Context) {
	// 1. Fetch all budget data
	rows, err := h.DB.QueryContext(c.Request.Context(), "SELECT budget_id, data FROM budget_data")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to query budgets: " + err.Error()})
		return
	}
	defer rows.Close()

	stats := struct {
		BudgetsProcessed int `json:"budgets_processed"`
		BudgetsUpdated   int `json:"budgets_updated"`
		ChargesFixed     int `json:"charges_fixed"`
		CacheEntriesNew  int `json:"cache_entries_created"`
	}{}

	// Use a background context for AI calls so they don't timeout if the HTTP request drops
	bgCtx := context.Background()

	for rows.Next() {
		stats.BudgetsProcessed++
		var budgetID string
		var rawData []byte

		if err := rows.Scan(&budgetID, &rawData); err != nil {
			log.Printf("Scan error: %v", err)
			continue
		}

		// 2. Parse JSON Data
		var dataMap map[string]interface{}
		if err := json.Unmarshal(rawData, &dataMap); err != nil {
			log.Printf("JSON error for budget %s: %v", budgetID, err)
			continue
		}

		// 3. Locate "charges" array
		chargesRaw, ok := dataMap["charges"].([]interface{})
		if !ok {
			continue // No charges in this budget
		}

		budgetModified := false

		// 4. Iterate over charges
		for i, ch := range chargesRaw {
			chargeMap, ok := ch.(map[string]interface{})
			if !ok {
				continue
			}

			label, _ := chargeMap["label"].(string)
			currentCat, _ := chargeMap["category"].(string)
			amount, _ := chargeMap["amount"].(float64)

			// LOGIC: If category is missing/OTHER, OR if you want to force re-check all:
			if label != "" && (currentCat == "" || currentCat == "OTHER") {
				
				// A. Apply Smart Categorization
				newCat := determineCategory(label) // Uses the logic from your market_suggestions_handler.go

				if newCat != "OTHER" && newCat != currentCat {
					// Update the Charge in Memory
					chargeMap["category"] = newCat
					chargesRaw[i] = chargeMap
					budgetModified = true
					stats.ChargesFixed++
					currentCat = newCat // Update for step B
				}
			}

			// B. Warm Up Cache (Trigger Analysis)
			// Only for relevant categories
			if isCategoryRelevant(currentCat) {
				// We call AnalyzeCharge. This checks DB cache first.
				// If missing, it calls AI and saves result.
				// This ensures that when the user logs in, the data is INSTANT.
				_, err := h.MarketAnalyzer.AnalyzeCharge(bgCtx, currentCat, "", amount, "FR")
				if err == nil {
					// We don't easily know if it was a hit or miss here without changing service return,
					// but we know we ensured it exists.
					stats.CacheEntriesNew++ // Loosely tracking processed items
				}
				// Sleep briefly to avoid hitting rate limits if processing thousands of items
				time.Sleep(50 * time.Millisecond)
			}
		}

		// 5. Save Updated Budget JSON back to DB if needed
		if budgetModified {
			dataMap["charges"] = chargesRaw
			updatedJSON, _ := json.Marshal(dataMap)

			_, err := h.DB.ExecContext(c.Request.Context(),
				"UPDATE budget_data SET data = $1 WHERE budget_id = $2",
				updatedJSON, budgetID)

			if err == nil {
				stats.BudgetsUpdated++
				log.Printf("[Migration] Updated budget %s (fixed categories)", budgetID)
			} else {
				log.Printf("[Migration] Failed to save budget %s: %v", budgetID, err)
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Retroactive analysis complete",
		"stats":   stats,
	})
}

// Copy helper here or ensure it's exported from the other file
// Simple relevance check
func isCategoryRelevant(cat string) bool {
	switch cat {
	case "MOBILE", "INTERNET", "ENERGY", "INSURANCE", "LOAN", "BANK":
		return true
	default:
		return false
	}
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\auth.go
=========================================
package handlers

import (
	"database/sql"
	"fmt"
	"net/http"
	"os"
	"time"

	"budget-api/utils"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// --- STRUCTURES DÃ‰FINIES ICI (C'Ã©tait ce qui manquait) ---

type AuthHandler struct {
	DB *sql.DB
}

type SignupRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required,min=8"`
	Name     string `json:"name" binding:"required"`
}

type LoginRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required"`
	TOTPCode string `json:"totp_code"`
}

type ResendVerificationRequest struct {
	Email string `json:"email" binding:"required,email"`
}

// --- HANDLERS ---

// Signup crÃ©e un utilisateur et envoie un email de vÃ©rification
func (h *AuthHandler) Signup(c *gin.Context) {
	var req SignupRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if user exists
	var exists bool
	err := h.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)", req.Email).Scan(&exists)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
		return
	}

	if exists {
		c.JSON(http.StatusConflict, gin.H{"error": "Cet email est dÃ©jÃ  utilisÃ©"})
		return
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		return
	}

	// Create user (email_verified defaults to FALSE)
	userID := uuid.New().String()
	_, err = h.DB.Exec(`
		INSERT INTO users (id, email, password_hash, name, created_at, updated_at, email_verified)
		VALUES ($1, $2, $3, $4, $5, $6, FALSE)
	`, userID, req.Email, string(hashedPassword), req.Name, time.Now(), time.Now())

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur crÃ©ation utilisateur"})
		return
	}

	// Create Verification Token
	verificationToken := uuid.New().String()
	expiresAt := time.Now().Add(24 * time.Hour)

	_, err = h.DB.Exec(`
        INSERT INTO email_verifications (user_id, token, expires_at)
        VALUES ($1, $2, $3)
    `, userID, verificationToken, expiresAt)

	if err != nil {
		fmt.Println("Erreur insert verification:", err)
	}

	// Send Email (in goroutine to be faster)
	go utils.SendVerificationEmail(req.Email, req.Name, verificationToken)

	c.JSON(http.StatusCreated, gin.H{
		"message":              "Compte crÃ©Ã©. Veuillez vÃ©rifier vos emails pour l'activer.",
		"require_verification": true,
	})
}

// Login connecte l'utilisateur et vÃ©rifie si l'email est validÃ©
func (h *AuthHandler) Login(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get user
	var userID, passwordHash, name string
	var totpEnabled, emailVerified bool
	var totpSecret sql.NullString

	// Note: On rÃ©cupÃ¨re aussi email_verified
	err := h.DB.QueryRow(`
		SELECT id, password_hash, name, totp_enabled, totp_secret, email_verified
		FROM users WHERE email = $1
	`, req.Email).Scan(&userID, &passwordHash, &name, &totpEnabled, &totpSecret, &emailVerified)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Identifiants invalides"})
		return
	}

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
		return
	}

	// Verify password
	if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(req.Password)); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Identifiants invalides"})
		return
	}

	// --- CHECK VERIFICATION ---
	if !emailVerified {
		c.JSON(http.StatusForbidden, gin.H{
			"error":        "Email non vÃ©rifiÃ©. Veuillez vÃ©rifier votre boÃ®te de rÃ©ception.",
			"not_verified": true,
		})
		return
	}

	// Check TOTP if enabled
	if totpEnabled {
		if req.TOTPCode == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "2FA code required", "require_totp": true})
			return
		}
		// Verify TOTP code here (logic in user handler or util)
		valid, _ := utils.VerifyTOTP(totpSecret.String, req.TOTPCode)
		if !valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Code 2FA invalide"})
			return
		}
	}

	// Generate token
	token, err := generateJWT(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"token": token,
		"user": gin.H{
			"id":    userID,
			"email": req.Email,
			"name":  name,
		},
	})
}

// VerifyEmail valide le token reÃ§u par email
func (h *AuthHandler) VerifyEmail(c *gin.Context) {
	token := c.Query("token")
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Token manquant"})
		return
	}

	var userID string
	var expiresAt time.Time

	// Find Token
	err := h.DB.QueryRow(`
        SELECT user_id, expires_at FROM email_verifications WHERE token = $1
    `, token).Scan(&userID, &expiresAt)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Lien invalide ou expirÃ©"})
		return
	}

	if time.Now().After(expiresAt) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Le lien a expirÃ©."})
		return
	}

	// Activate User
	_, err = h.DB.Exec("UPDATE users SET email_verified = TRUE WHERE id = $1", userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur serveur"})
		return
	}

	// Delete Token
	h.DB.Exec("DELETE FROM email_verifications WHERE token = $1", token)

	c.JSON(http.StatusOK, gin.H{"message": "Email vÃ©rifiÃ© avec succÃ¨s ! Vous pouvez vous connecter."})
}

// --- HELPER FUNCTIONS ---

func generateJWT(userID string) (string, error) {
	secret := os.Getenv("JWT_SECRET")
	if secret == "" {
		if os.Getenv("ENVIRONMENT") == "production" || os.Getenv("GIN_MODE") == "release" {
			return "", fmt.Errorf("JWT_SECRET is required in production")
		}
		secret = "dev-only-insecure-secret"
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(24 * time.Hour).Unix(),
	})
	return token.SignedString([]byte(secret))
}


// ResendVerification gÃ©nÃ¨re un nouveau token et renvoie l'email
func (h *AuthHandler) ResendVerification(c *gin.Context) {
	var req ResendVerificationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// 1. VÃ©rifier si l'utilisateur existe et n'est PAS dÃ©jÃ  vÃ©rifiÃ©
	var userID string
	var isVerified bool
	var name string

	err := h.DB.QueryRow("SELECT id, name, email_verified FROM users WHERE email = $1", req.Email).Scan(&userID, &name, &isVerified)
	
	if err == sql.ErrNoRows {
		// SÃ©curitÃ© : On ne dit pas si l'email existe ou non, on renvoie OK
		c.JSON(http.StatusOK, gin.H{"message": "Si ce compte existe, un email a Ã©tÃ© envoyÃ©."})
		return
	}

	if isVerified {
		c.JSON(http.StatusConflict, gin.H{"error": "Ce compte est dÃ©jÃ  vÃ©rifiÃ©. Connectez-vous."})
		return
	}

	// 2. Nettoyer les anciens tokens
	_, err = h.DB.Exec("DELETE FROM email_verifications WHERE user_id = $1", userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur systÃ¨me"})
        return
    }

	// 3. CrÃ©er nouveau token
	verificationToken := uuid.New().String()
	expiresAt := time.Now().Add(24 * time.Hour)

	_, err = h.DB.Exec(`
		INSERT INTO email_verifications (user_id, token, expires_at)
		VALUES ($1, $2, $3)
	`, userID, verificationToken, expiresAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Impossible de gÃ©nÃ©rer le token"})
		return
	}

	// 4. Renvoyer l'email
	go utils.SendVerificationEmail(req.Email, name, verificationToken)

	c.JSON(http.StatusOK, gin.H{"message": "Email de vÃ©rification envoyÃ© !"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\banking.go
=========================================
package handlers

import (
	"database/sql"
	"net/http"

	"budget-api/models"
	"budget-api/services"

	"github.com/gin-gonic/gin"
)

type BankingHandler struct {
	Service *services.BankingService
}

func NewBankingHandler(db *sql.DB) *BankingHandler {
	return &BankingHandler{
		Service: services.NewBankingService(db),
	}
}

// GetConnections liste les connexions DU BUDGET
func (h *BankingHandler) GetConnections(c *gin.Context) {
	budgetID := c.Param("id") // RÃ©cupÃ©rÃ© depuis l'URL /budgets/:id/banking/connections
	if budgetID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Budget ID required"})
		return
	}

	connections, err := h.Service.GetBudgetConnections(c.Request.Context(), budgetID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch connections"})
		return
	}

	totalReal, err := h.Service.GetRealityCheckSum(c.Request.Context(), budgetID)
	if err != nil {
		// Si aucune ligne n'est trouvÃ©e (pas de compte Ã©pargne cochÃ©), le total est 0
		totalReal = 0
	}

	c.JSON(http.StatusOK, gin.H{
		"connections":     connections,
		"total_real_cash": totalReal,
	})
}

// UpdateAccountPool met Ã  jour le flag "is_savings_pool"
func (h *BankingHandler) UpdateAccountPool(c *gin.Context) {
	accountID := c.Param("account_id")

	var req models.UpdateAccountPoolRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	err := h.Service.UpdateAccountPool(c.Request.Context(), accountID, req.IsSavingsPool)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update account"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Account updated successfully"})
}

// DeleteConnection supprime une connexion bancaire
func (h *BankingHandler) DeleteConnection(c *gin.Context) {
	connID := c.Param("connection_id")

	err := h.Service.DeleteConnection(c.Request.Context(), connID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete connection"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Connection deleted successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\budget.go
=========================================
package handlers

import (
	"log"
	"net/http"

	"budget-api/services"

	"github.com/gin-gonic/gin"
)

type Handler struct {
	budgetService *services.BudgetService
	emailService  *services.EmailService
}

func NewHandler(budgetService *services.BudgetService, emailService *services.EmailService) *Handler {
	return &Handler{
		budgetService: budgetService,
		emailService:  emailService,
	}
}

// GetBudgets returns all budgets for the authenticated user
func (h *Handler) GetBudgets(c *gin.Context) {
	userID := c.GetString("user_id")

	budgets, err := h.budgetService.GetUserBudgets(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get budgets"})
		return
	}

	c.JSON(http.StatusOK, budgets)
}

// CreateBudget creates a new budget
func (h *Handler) CreateBudget(c *gin.Context) {
	var req struct {
		Name string `json:"name" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	userID := c.GetString("user_id")

	budget, err := h.budgetService.Create(c.Request.Context(), req.Name, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create budget"})
		return
	}

	c.JSON(http.StatusCreated, budget)
}

// GetBudget returns a specific budget
func (h *Handler) GetBudget(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	budget, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	c.JSON(http.StatusOK, budget)
}

// UpdateBudget updates a budget name
func (h *Handler) UpdateBudget(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	var req struct {
		Name string `json:"name" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if user has access
	_, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	if err := h.budgetService.Update(c.Request.Context(), budgetID, req.Name); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update budget"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Budget updated successfully"})
}

// DeleteBudget deletes a budget
func (h *Handler) DeleteBudget(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	// Check if user is the owner
	budget, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	if budget.OwnerID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only the owner can delete the budget"})
		return
	}

	// Delete the budget
	if err := h.budgetService.Delete(c.Request.Context(), budgetID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete budget"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Budget deleted successfully"})
}

// GetBudgetData returns the JSON data for a budget
func (h *Handler) GetBudgetData(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	// Check access
	_, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	data, err := h.budgetService.GetData(c.Request.Context(), budgetID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get budget data"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"data": data})
}

// UpdateBudgetData updates the JSON data for a budget
func (h *Handler) UpdateBudgetData(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	var req struct {
		Data interface{} `json:"data" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check access
	_, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	if err := h.budgetService.UpdateData(c.Request.Context(), budgetID, req.Data); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update budget data"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Budget data updated successfully"})
}

// InviteMember invites a member to a budget
func (h *Handler) InviteMember(c *gin.Context) {
	var req struct {
		Email string `json:"email" binding:"required,email"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	// Check if user is the owner
	budget, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	if budget.OwnerID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only the owner can invite members"})
		return
	}

	// Check if user is already a member
	isMember, err := h.budgetService.IsMemberByEmail(c.Request.Context(), budgetID, req.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error checking membership"})
		return
	}
	if isMember {
		c.JSON(http.StatusConflict, gin.H{"error": "Cet utilisateur est dÃ©jÃ  membre du budget"})
		return
	}

	// Check if there's an existing pending invitation
	existingInvitation, _ := h.budgetService.GetPendingInvitation(c.Request.Context(), budgetID, req.Email)
	if existingInvitation != nil {
		// Delete the old invitation to create a fresh one
		if err := h.budgetService.DeleteInvitation(c.Request.Context(), existingInvitation.ID); err != nil {
			log.Printf("Failed to delete old invitation: %v", err)
		}
	}

	// Create invitation
	invitation, err := h.budgetService.CreateInvitation(c.Request.Context(), budgetID, req.Email, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Send email
	inviterName := budget.OwnerName
	if inviterName == "" {
		inviterName = "Un utilisateur"
	}

	if err := h.emailService.SendInvitation(req.Email, inviterName, budget.Name, invitation.Token); err != nil {
		log.Printf("Failed to send invitation email: %v", err)
		// Don't fail the request if email fails, but log it
	}

	c.JSON(http.StatusOK, gin.H{
		"message":    "Invitation sent successfully",
		"invitation": invitation,
	})
}

// AcceptInvitation accepts an invitation
func (h *Handler) AcceptInvitation(c *gin.Context) {
	var req struct {
		Token string `json:"token" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	userID := c.GetString("user_id")

	if err := h.budgetService.AcceptInvitation(c.Request.Context(), req.Token, userID); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Invitation accepted successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\categorization.go
=========================================
package handlers

import (
	"database/sql"
	"net/http"

	"budget-api/services"

	"github.com/gin-gonic/gin"
)

type CategorizationHandler struct {
	Service *services.CategorizerService
}

func NewCategorizationHandler(db *sql.DB) *CategorizationHandler {
	return &CategorizationHandler{
		Service: services.NewCategorizerService(db),
	}
}

type CategorizeRequest struct {
	Label string `json:"label" binding:"required"`
}

func (h *CategorizationHandler) CategorizeLabel(c *gin.Context) {
	var req CategorizeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	category, err := h.Service.GetCategory(c.Request.Context(), req.Label)
	if err != nil {
		// Fallback silencieux en cas d'erreur grave
		c.JSON(http.StatusOK, gin.H{"category": "OTHER", "source": "fallback"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"label":    req.Label,
		"category": category,
	})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\enable_banking_handler.go
=========================================
package handlers

import (
	"bytes"
	"database/sql"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"budget-api/middleware"
	"budget-api/services"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type EnableBankingHandler struct {
	DB                   *sql.DB
	Service              *services.BankingService
	EnableBankingService *services.EnableBankingService
}

func NewEnableBankingHandler(db *sql.DB) *EnableBankingHandler {
	return &EnableBankingHandler{
		DB:                   db,
		Service:              services.NewBankingService(db),
		EnableBankingService: services.NewEnableBankingService(),
	}
}

// ============================================================================
// 1. GET BANKS - Liste des banques disponibles
// ============================================================================

func (h *EnableBankingHandler) GetBanks(c *gin.Context) {
	country := c.DefaultQuery("country", "FR")
	
	log.Printf("ðŸ¦ Fetching banks for country: %s", country)
	
	aspsps, err := h.EnableBankingService.GetASPSPs(c.Request.Context(), country)
	if err != nil {
		log.Printf("âŒ Failed to fetch banks: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to fetch banks",
			"details": err.Error(),
		})
		return
	}

	// Transformer en format UI-friendly
	var banks []map[string]interface{}
	for _, aspsp := range aspsps {
		bank := map[string]interface{}{
			"id":      aspsp.Name,
			"name":    aspsp.Name,
			"country": aspsp.Country,
			"logo":    aspsp.Logo,
			"beta":    aspsp.Beta,
		}
		
		if aspsp.BIC != "" {
			bank["bic"] = aspsp.BIC
		}
		
		// Identifier si c'est une banque sandbox
		if aspsp.Sandbox != nil {
			bank["sandbox"] = true
			bank["sandbox_users"] = aspsp.Sandbox.Users
		} else {
			bank["sandbox"] = false
		}
		
		banks = append(banks, bank)
	}

	log.Printf("âœ… Returning %d banks", len(banks))
	c.JSON(http.StatusOK, gin.H{"banks": banks})
}

// ============================================================================
// 2. CREATE CONNECTION - Initier l'autorisation bancaire
// ============================================================================

func (h *EnableBankingHandler) CreateConnection(c *gin.Context) {
	var req struct {
		ASPSPID  string `json:"aspsp_id" binding:"required"`
		BudgetID string `json:"budget_id" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request",
			"details": "aspsp_id and budget_id are required",
		})
		return
	}

	log.Printf("ðŸ” Creating connection for bank: %s (budget: %s)", req.ASPSPID, req.BudgetID)

	// GÃ©nÃ©rer un state unique qui encode le budget ID
	state := fmt.Sprintf("%s|%s", req.BudgetID, uuid.New().String())
	validUntil := time.Now().AddDate(0, 0, 90).Format(time.RFC3339)

	// Construire l'URL de callback
	callbackURL := os.Getenv("FRONTEND_URL")
	if callbackURL == "" {
		callbackURL = "https://www.budgetfamille.com"
	}
	callbackURL += "/beta2/callback"

	log.Printf("ðŸ“ Callback URL: %s", callbackURL)

	// CrÃ©er la demande d'autorisation
	authReq := services.AuthRequest{
		Access: services.Access{
			ValidUntil: validUntil,
		},
		ASPSP: services.ASPSPIdentifier{
			Name:    req.ASPSPID,
			Country: "FR", // Pour l'instant, on se concentre sur la France
		},
		State:       state,
		RedirectURL: callbackURL,
		PSUType:     "personal",
	}

	authResp, err := h.EnableBankingService.CreateAuthRequest(c.Request.Context(), authReq)
	if err != nil {
		log.Printf("âŒ Failed to create auth request: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to create connection",
			"details": err.Error(),
		})
		return
	}

	log.Printf("âœ… Authorization URL created successfully")
	log.Printf("   URL: %s", authResp.URL)
	log.Printf("   State: %s", state)

	c.JSON(http.StatusOK, gin.H{
		"redirect_url":     authResp.URL,
		"state":            state,
		"authorization_id": authResp.AuthorizationID,
	})
}

// ============================================================================
// 3. HANDLE CALLBACK - GÃ©rer le retour aprÃ¨s autorisation
// ============================================================================

func (h *EnableBankingHandler) HandleCallback(c *gin.Context) {
	code := c.Query("code")
	state := c.Query("state")

	log.Printf("ðŸ“ž Callback received - Code: %s..., State: %s", code[:min(10, len(code))], state)

	if code == "" || state == "" {
		log.Println("âŒ Missing code or state parameter")
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Missing code or state parameter",
		})
		return
	}

	// CrÃ©er la session avec le code d'autorisation
	sessionResp, err := h.EnableBankingService.CreateSession(c.Request.Context(), code, state)
	if err != nil {
		log.Printf("âŒ Failed to create session: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to create session",
			"details": err.Error(),
		})
		return
	}

	// Extraire le budget ID du state
	budgetID := state
	if len(state) > 36 {
		// State format: "budgetID|uuid"
		budgetID = state[:36]
	}

	log.Printf("âœ… Session created successfully")
	log.Printf("   Session ID: %s", sessionResp.SessionID)
	log.Printf("   Budget ID: %s", budgetID)
	log.Printf("   Accounts: %d", len(sessionResp.Accounts))

	// Transformer les comptes en format UI-friendly
	var accounts []map[string]interface{}
	for _, acc := range sessionResp.Accounts {
		iban := acc.AccountID.IBAN
		if iban == "" && acc.AccountID.Other != nil {
			iban = acc.AccountID.Other.Identification
		}
		
		accounts = append(accounts, map[string]interface{}{
			"uid":      acc.UID,
			"name":     acc.Name,
			"iban":     iban,
			"currency": acc.Currency,
			"type":     acc.CashAccountType,
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"session_id":    sessionResp.SessionID,
		"budget_id":     budgetID,
		"accounts":      accounts,
		"bank_name":     sessionResp.ASPSP.Name,
		"bank_country":  sessionResp.ASPSP.Country,
	})
}

// ============================================================================
// 4. SYNC ACCOUNTS - Synchroniser les comptes dans le budget
// ============================================================================

func (h *EnableBankingHandler) SyncAccounts(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")

	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	log.Printf("ðŸ”„ SYNC START - Budget: %s, User: %s", budgetID, userID)
	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

	// Lire le body
	bodyBytes, err := io.ReadAll(c.Request.Body)
	if err != nil {
		log.Printf("âŒ Failed to read body: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot read request body"})
		return
	}

	log.Printf("ðŸ“¦ Request body: %s", string(bodyBytes))

	// Restaurer le body pour le binding
	c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

	var req struct {
		SessionID string `json:"session_id" binding:"required"`
		BankName  string `json:"bank_name"`
		Accounts  []struct {
			UID      string `json:"uid" binding:"required"`
			Name     string `json:"name" binding:"required"`
			IBAN     string `json:"iban"`
			Currency string `json:"currency" binding:"required"`
			Type     string `json:"type"`
		} `json:"accounts" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("âŒ JSON binding error: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request format",
			"details": err.Error(),
		})
		return
	}

	log.Printf("âœ… Parsed request:")
	log.Printf("   Session ID: %s", req.SessionID)
	log.Printf("   Bank: %s", req.BankName)
	log.Printf("   Accounts: %d", len(req.Accounts))

	if len(req.Accounts) == 0 {
		log.Println("âš ï¸  No accounts to sync")
		c.JSON(http.StatusOK, gin.H{
			"message":         "No accounts to sync",
			"accounts_synced": 0,
		})
		return
	}

	accountsSynced := 0
	bankName := req.BankName
	if bankName == "" {
		bankName = "Enable Banking"
	}

	for i, acc := range req.Accounts {
		log.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
		log.Printf("ðŸ’³ [%d/%d] Processing: %s", i+1, len(req.Accounts), acc.Name)
		log.Printf("    UID: %s", acc.UID)
		log.Printf("    IBAN: %s", acc.IBAN)
		log.Printf("    Currency: %s", acc.Currency)
		log.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

		// A. CrÃ©er/rÃ©cupÃ©rer la connexion
		log.Println("   â†’ Creating/updating connection...")
		connID, err := h.Service.SaveConnectionWithTokens(
			c.Request.Context(),
			userID,
			budgetID,
			acc.UID,
			bankName,
			req.SessionID,
			"enablebanking",
			"",
			time.Now().AddDate(0, 3, 0), // 3 mois
		)

		if err != nil {
			log.Printf("âŒ Failed to create connection: %v", err)
			continue
		}

		log.Printf("âœ… Connection ID: %s", connID)

		// B. RÃ©cupÃ©rer le solde
		balance := 0.0
		log.Println("   â†’ Fetching balance...")
		
		balances, err := h.EnableBankingService.GetBalances(
			c.Request.Context(),
			req.SessionID,
			acc.UID,
		)
		
		if err != nil {
			log.Printf("âš ï¸  Could not fetch balance: %v", err)
		} else if len(balances) > 0 {
			// Prendre le premier solde disponible
			amountStr := balances[0].BalanceAmount.Amount
			if parsed, err := strconv.ParseFloat(amountStr, 64); err == nil {
				balance = parsed
				log.Printf("ðŸ’° Balance: %.2f %s", balance, balances[0].BalanceAmount.Currency)
			} else {
				log.Printf("âš ï¸  Could not parse balance: '%s'", amountStr)
			}
		}

		// C. Sauvegarder le compte
		log.Println("   â†’ Saving account...")
		mask := acc.IBAN
		if len(mask) > 4 {
			mask = mask[len(mask)-4:]
		}

		err = h.Service.SaveAccount(
			c.Request.Context(),
			connID,
			acc.UID,
			acc.Name,
			mask,
			acc.Currency,
			balance,
		)

		if err != nil {
			log.Printf("âŒ Failed to save account: %v", err)
			continue
		}

		log.Printf("âœ… Account synced: %s (%.2f %s)", acc.Name, balance, acc.Currency)
		accountsSynced++
	}

	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	log.Printf("ðŸŽ‰ SYNC COMPLETE: %d/%d accounts synced", accountsSynced, len(req.Accounts))
	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

	c.JSON(http.StatusOK, gin.H{
		"message":         "Accounts synchronized successfully",
		"accounts_synced": accountsSynced,
		"total_accounts":  len(req.Accounts),
	})
}

// ============================================================================
// 5. GET CONNECTIONS - Liste des connexions du budget
// ============================================================================

func (h *EnableBankingHandler) GetConnections(c *gin.Context) {
    budgetID := c.Param("id")
    userID := middleware.GetUserID(c)

    log.Printf("ðŸ“‹ Fetching Enable Banking connections for budget %s", budgetID)

    // 1. Fetch List of Connections
    rows, err := h.DB.Query(`
        SELECT 
            bc.id,
            bc.aspsp_name as institution_name,
            bc.session_id,
            bc.created_at,
            COUNT(ba.id) as account_count
        FROM banking_connections bc
        LEFT JOIN banking_accounts ba ON ba.connection_id = bc.id
        WHERE bc.budget_id = $1 
          AND bc.user_id = $2
        GROUP BY bc.id, bc.aspsp_name, bc.session_id, bc.created_at
        ORDER BY bc.created_at DESC
    `, budgetID, userID)

    if err != nil {
        log.Printf("âŒ Error fetching connections: %v", err)
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch connections"})
        return
    }
    defer rows.Close()

    type Connection struct {
        ID              string    `json:"id"`
        InstitutionName string    `json:"institution_name"`
        SessionID       string    `json:"session_id"`
        CreatedAt       time.Time `json:"created_at"`
        AccountCount    int       `json:"account_count"`
        Provider        string    `json:"provider"`
    }

    var connections []Connection

    for rows.Next() {
        var conn Connection
        conn.Provider = "enablebanking"
        if err := rows.Scan(&conn.ID, &conn.InstitutionName, &conn.SessionID, &conn.CreatedAt, &conn.AccountCount); err != nil {
            log.Printf("âš ï¸  Error scanning row: %v", err)
            continue
        }
        connections = append(connections, conn)
    }

    // 2. Calculate Total Cash (The missing piece!)
    var totalRealCash float64
    err = h.DB.QueryRow(`
        SELECT COALESCE(SUM(balance), 0)
        FROM banking_accounts ba
        JOIN banking_connections bc ON ba.connection_id = bc.id
        WHERE bc.budget_id = $1 
          AND bc.user_id = $2
    `, budgetID, userID).Scan(&totalRealCash)

    if err != nil {
        log.Printf("âš ï¸  Error calculating total cash: %v", err)
        // We don't fail the request, just return 0
        totalRealCash = 0
    }

    log.Printf("âœ… Found %d connections, Total Cash: %.2f", len(connections), totalRealCash)

    // 3. Return both connections AND the total
    c.JSON(http.StatusOK, gin.H{
        "connections":     connections,
        "total_real_cash": totalRealCash, // <--- This is what the frontend needs
    })
}

// ============================================================================
// 6. REFRESH BALANCES - RafraÃ®chir les soldes
// ============================================================================

func (h *EnableBankingHandler) RefreshBalances(c *gin.Context) {
	var req struct {
		ConnectionID string `json:"connection_id" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "connection_id is required"})
		return
	}

	log.Printf("ðŸ”„ Refreshing balances for connection: %s", req.ConnectionID)

	// RÃ©cupÃ©rer le session ID
	var sessionID string
	err := h.DB.QueryRow(`
		SELECT session_id 
		FROM banking_connections 
		WHERE id = $1
	`, req.ConnectionID).Scan(&sessionID)

	if err != nil {
		log.Printf("âŒ Connection not found: %v", err)
		c.JSON(http.StatusNotFound, gin.H{"error": "Connection not found"})
		return
	}

	// RÃ©cupÃ©rer tous les comptes de cette connexion
	rows, err := h.DB.Query(`
		SELECT id, account_id, account_name
		FROM banking_accounts 
		WHERE connection_id = $1
	`, req.ConnectionID)

	if err != nil {
		log.Printf("âŒ Failed to fetch accounts: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch accounts"})
		return
	}
	defer rows.Close()

	updatedCount := 0
	errors := []string{}

	for rows.Next() {
		var accountID, externalID, accountName string
		if err := rows.Scan(&accountID, &externalID, &accountName); err != nil {
			continue
		}

		log.Printf("ðŸ’° Refreshing balance for: %s (UID: %s)", accountName, externalID)

		balances, err := h.EnableBankingService.GetBalances(
			c.Request.Context(),
			sessionID,
			externalID,
		)

		if err != nil {
			errMsg := fmt.Sprintf("Error fetching balance for %s: %v", accountName, err)
			log.Printf("âŒ %s", errMsg)
			errors = append(errors, errMsg)
			continue
		}

		if len(balances) > 0 {
			amountStr := balances[0].BalanceAmount.Amount
			if balance, err := strconv.ParseFloat(amountStr, 64); err == nil {
				_, err := h.DB.Exec(`
					UPDATE banking_accounts 
					SET balance = $1, last_sync_at = NOW() 
					WHERE id = $2
				`, balance, accountID)

				if err == nil {
					log.Printf("âœ… Updated balance for %s: %.2f %s", accountName, balance, balances[0].BalanceAmount.Currency)
					updatedCount++
				} else {
					errMsg := fmt.Sprintf("Failed to update balance for %s: %v", accountName, err)
					log.Printf("âŒ %s", errMsg)
					errors = append(errors, errMsg)
				}
			}
		}
	}

	response := gin.H{
		"message":          "Balances refresh completed",
		"accounts_updated": updatedCount,
	}

	if len(errors) > 0 {
		response["errors"] = errors
	}

	log.Printf("âœ… Balance refresh complete: %d accounts updated", updatedCount)

	c.JSON(http.StatusOK, response)
}

// ============================================================================
// 7. GET TRANSACTIONS - RÃ©cupÃ©rer les transactions
// ============================================================================

func (h *EnableBankingHandler) GetTransactions(c *gin.Context) {
    budgetID := c.Query("budget_id")
    userID := middleware.GetUserID(c)

    log.Printf("ðŸ’³ Fetching transactions for budget: %s", budgetID)

    // FIX: Change 'ba.external_account_id' to 'ba.account_id'
    rows, err := h.DB.Query(`
        SELECT bc.session_id, ba.account_id, ba.id, ba.account_name
        FROM banking_accounts ba
        JOIN banking_connections bc ON ba.connection_id = bc.id
        WHERE bc.user_id = $1 
          AND bc.budget_id = $2 
    `, userID, budgetID)

    if err != nil {
        log.Printf("âŒ Failed to fetch accounts: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch accounts"})
		return
	}
	defer rows.Close()

	type TransactionDisplay struct {
		ID          string  `json:"id"`
		AccountID   string  `json:"account_id"`
		AccountName string  `json:"account_name"`
		Amount      float64 `json:"amount"`
		Currency    string  `json:"currency_code"`
		Description string  `json:"clean_description"`
		Date        string  `json:"date"`
		Type        string  `json:"type"` // DBIT ou CRDT
	}

	var allTransactions []TransactionDisplay
	transactionID := 1

	// RÃ©cupÃ©rer les transactions des 90 derniers jours
	dateFrom := time.Now().AddDate(0, 0, -90).Format("2006-01-02")
	dateTo := time.Now().Format("2006-01-02")

	for rows.Next() {
		var sessionID, accountUID, accountID, accountName string
		if err := rows.Scan(&sessionID, &accountUID, &accountID, &accountName); err != nil {
			continue
		}

		log.Printf("   â†’ Fetching transactions for: %s", accountName)

		transactions, err := h.EnableBankingService.GetTransactions(
			c.Request.Context(),
			accountUID,
			dateFrom,
			dateTo,
		)

		if err != nil {
			log.Printf("âš ï¸  Error fetching transactions for %s: %v", accountName, err)
			continue
		}

		log.Printf("   âœ… Found %d transactions for %s", len(transactions), accountName)

		for _, tx := range transactions {
			// Convertir le montant
			amount := 0.0
			if parsed, err := strconv.ParseFloat(tx.TransactionAmount.Amount, 64); err == nil {
				amount = parsed
				// Si c'est un dÃ©bit, rendre le montant nÃ©gatif
				if tx.CreditDebitIndicator == "DBIT" {
					amount = -amount
				}
			}

			// Construire la description
			description := ""
			if len(tx.RemittanceInformation) > 0 {
				description = tx.RemittanceInformation[0]
			}
			if description == "" && tx.Creditor != nil {
				description = tx.Creditor.Name
			}
			if description == "" && tx.Debtor != nil {
				description = tx.Debtor.Name
			}
			if description == "" {
				description = "Transaction"
			}

			// Utiliser la date de rÃ©servation ou la date de valeur
			date := tx.BookingDate
			if date == "" {
				date = tx.ValueDate
			}
			if date == "" {
				date = tx.TransactionDate
			}

			allTransactions = append(allTransactions, TransactionDisplay{
				ID:          fmt.Sprintf("eb-%d", transactionID),
				AccountID:   accountID,
				AccountName: accountName,
				Amount:      amount,
				Currency:    tx.TransactionAmount.Currency,
				Description: description,
				Date:        date,
				Type:        tx.CreditDebitIndicator,
			})
			transactionID++
		}
	}

	log.Printf("âœ… Total transactions retrieved: %d", len(allTransactions))

	c.JSON(http.StatusOK, gin.H{
		"transactions": allTransactions,
		"total":        len(allTransactions),
	})
}

// ============================================================================
// 8. DELETE CONNECTION - Supprimer une connexion
// ============================================================================

func (h *EnableBankingHandler) DeleteConnection(c *gin.Context) {
	connectionID := c.Param("id")
	userID := middleware.GetUserID(c)

	log.Printf("ðŸ—‘ï¸  Deleting connection: %s (user: %s)", connectionID, userID)

	// RÃ©cupÃ©rer le session ID avant de supprimer
	var sessionID string
	err := h.DB.QueryRow(`
		SELECT session_id 
		FROM banking_connections 
		WHERE id = $1 AND user_id = $2
	`, connectionID, userID).Scan(&sessionID)

	if err != nil {
		if err == sql.ErrNoRows {
			log.Println("âŒ Connection not found or unauthorized")
			c.JSON(http.StatusNotFound, gin.H{"error": "Connection not found"})
		} else {
			log.Printf("âŒ Database error: %v", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
		}
		return
	}

	// Supprimer la session Enable Banking
	if sessionID != "" {
		if err := h.EnableBankingService.DeleteSession(c.Request.Context(), sessionID); err != nil {
			log.Printf("âš ï¸  Failed to delete Enable Banking session: %v", err)
			// Continue quand mÃªme avec la suppression locale
		}
	}

	// Supprimer les comptes associÃ©s
	_, err = h.DB.Exec(`
		DELETE FROM banking_accounts 
		WHERE connection_id = $1
	`, connectionID)

	if err != nil {
		log.Printf("âŒ Failed to delete accounts: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete accounts"})
		return
	}

	// Supprimer la connexion
	_, err = h.DB.Exec(`
		DELETE FROM banking_connections 
		WHERE id = $1 AND user_id = $2
	`, connectionID, userID)

	if err != nil {
		log.Printf("âŒ Failed to delete connection: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete connection"})
		return
	}

	log.Printf("âœ… Connection deleted successfully")
	c.JSON(http.StatusOK, gin.H{"message": "Connection deleted successfully"})
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\invitation.go
=========================================
package handlers

import (
	"database/sql"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"budget-api/middleware"
	"budget-api/models"
	"budget-api/utils"
)

type InvitationHandler struct {
	DB *sql.DB
}

// InviteUser sends an invitation to join a budget
func (h *InvitationHandler) InviteUser(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")

	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Check if user is a member of the budget
	var exists bool
	err := h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members
			WHERE budget_id = $1 AND user_id = $2
		)
	`, budgetID, userID).Scan(&exists)

	if err != nil || !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}

	var req models.InvitationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if user is already a member
	var alreadyMember bool
	err = h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members bm
			INNER JOIN users u ON bm.user_id = u.id
			WHERE bm.budget_id = $1 AND u.email = $2
		)
	`, budgetID, req.Email).Scan(&alreadyMember)

	if err == nil && alreadyMember {
		c.JSON(http.StatusConflict, gin.H{"error": "User is already a member"})
		return
	}

	// Check if there's a pending invitation
	var pendingInvitation bool
	err = h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM invitations
			WHERE budget_id = $1 AND email = $2 AND status = 'pending' AND expires_at > NOW()
		)
	`, budgetID, req.Email).Scan(&pendingInvitation)

	if err == nil && pendingInvitation {
		c.JSON(http.StatusConflict, gin.H{"error": "Invitation already sent"})
		return
	}

	// Generate invitation token
	token := uuid.New().String()

	// Create invitation
	var invitationID string
	expiresAt := time.Now().Add(7 * 24 * time.Hour) // 7 days
	err = h.DB.QueryRow(`
		INSERT INTO invitations (budget_id, email, invited_by, token, expires_at)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id
	`, budgetID, req.Email, userID, token, expiresAt).Scan(&invitationID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create invitation"})
		return
	}

	// Get budget and inviter info for email
	var budgetName, inviterName string
	err = h.DB.QueryRow(`
		SELECT b.name, u.name
		FROM budgets b, users u
		WHERE b.id = $1 AND u.id = $2
	`, budgetID, userID).Scan(&budgetName, &inviterName)

	if err != nil {
		inviterName = "A user"
		budgetName = "a budget"
	}

	// Send invitation email
	err = utils.SendInvitationEmail(req.Email, inviterName, budgetName, token)
	if err != nil {
		// Log error but don't fail the request
		c.JSON(http.StatusCreated, gin.H{
			"id":      invitationID,
			"token":   token,
			"message": "Invitation created but email failed to send",
			"warning": "Please share the invitation link manually",
		})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"id":      invitationID,
		"message": "Invitation sent successfully",
	})
}

// GetInvitations returns all invitations for a budget
func (h *InvitationHandler) GetInvitations(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")

	// Check access
	var exists bool
	err := h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members
			WHERE budget_id = $1 AND user_id = $2
		)
	`, budgetID, userID).Scan(&exists)

	if err != nil || !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}

	// Get invitations
	rows, err := h.DB.Query(`
		SELECT i.id, i.budget_id, i.email, i.invited_by, i.token, i.status, i.expires_at, i.created_at,
		       u.name as inviter_name
		FROM invitations i
		LEFT JOIN users u ON i.invited_by = u.id
		WHERE i.budget_id = $1
		ORDER BY i.created_at DESC
	`, budgetID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch invitations"})
		return
	}
	defer rows.Close()

	invitations := []map[string]interface{}{}
	for rows.Next() {
		var inv models.Invitation
		var inviterName sql.NullString
		err := rows.Scan(&inv.ID, &inv.BudgetID, &inv.Email, &inv.InvitedBy, &inv.Token,
			&inv.Status, &inv.ExpiresAt, &inv.CreatedAt, &inviterName)
		if err != nil {
			continue
		}

		invMap := map[string]interface{}{
			"id":         inv.ID,
			"email":      inv.Email,
			"status":     inv.Status,
			"expires_at": inv.ExpiresAt,
			"created_at": inv.CreatedAt,
		}

		if inviterName.Valid {
			invMap["inviter_name"] = inviterName.String
		}

		invitations = append(invitations, invMap)
	}

	c.JSON(http.StatusOK, invitations)
}

// AcceptInvitation accepts an invitation and adds user to budget
func (h *InvitationHandler) AcceptInvitation(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req models.AcceptInvitationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get invitation
	var inv models.Invitation
	var userEmail string
	err := h.DB.QueryRow(`
		SELECT i.id, i.budget_id, i.email, i.status, i.expires_at,
		       u.email as user_email
		FROM invitations i, users u
		WHERE i.token = $1 AND u.id = $2
	`, req.Token, userID).Scan(&inv.ID, &inv.BudgetID, &inv.Email, &inv.Status, &inv.ExpiresAt, &userEmail)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Invitation not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch invitation"})
		return
	}

	// Check if invitation is valid
	if inv.Status != "pending" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invitation already " + inv.Status})
		return
	}

	if time.Now().After(inv.ExpiresAt) {
		// Mark as expired
		h.DB.Exec(`UPDATE invitations SET status = 'expired' WHERE id = $1`, inv.ID)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invitation has expired"})
		return
	}

	// Verify email matches
	if userEmail != inv.Email {
		c.JSON(http.StatusForbidden, gin.H{"error": "This invitation is for a different email address"})
		return
	}

	// Check if already a member
	var alreadyMember bool
	err = h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members
			WHERE budget_id = $1 AND user_id = $2
		)
	`, inv.BudgetID, userID).Scan(&alreadyMember)

	if alreadyMember {
		c.JSON(http.StatusConflict, gin.H{"error": "You are already a member"})
		return
	}

	// Add user to budget
	_, err = h.DB.Exec(`
		INSERT INTO budget_members (budget_id, user_id, role, permissions)
		VALUES ($1, $2, 'member', '{"read": true, "write": true}')
	`, inv.BudgetID, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add member"})
		return
	}

	// Mark invitation as accepted
	_, err = h.DB.Exec(`
		UPDATE invitations
		SET status = 'accepted'
		WHERE id = $1
	`, inv.ID)

	if err != nil {
		// Non-critical, just log
		c.JSON(http.StatusOK, gin.H{
			"message":   "Invitation accepted successfully",
			"budget_id": inv.BudgetID,
			"warning":   "Failed to update invitation status",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":   "Invitation accepted successfully",
		"budget_id": inv.BudgetID,
	})
}

// CancelInvitation cancels a pending invitation
func (h *InvitationHandler) CancelInvitation(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")
	invitationID := c.Param("invitation_id")

	// Check if user is member of budget
	var exists bool
	err := h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members
			WHERE budget_id = $1 AND user_id = $2
		)
	`, budgetID, userID).Scan(&exists)

	if err != nil || !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}

	// Delete invitation
	result, err := h.DB.Exec(`
		DELETE FROM invitations
		WHERE id = $1 AND budget_id = $2 AND status = 'pending'
	`, invitationID, budgetID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to cancel invitation"})
		return
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Invitation not found or already processed"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Invitation cancelled successfully"})
}

// RemoveMember removes a member from a budget
func (h *InvitationHandler) RemoveMember(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")
	memberID := c.Param("member_id")

	// Check if user is owner
	var isOwner bool
	err := h.DB.QueryRow(`
		SELECT owner_id = $1
		FROM budgets
		WHERE id = $2
	`, userID, budgetID).Scan(&isOwner)

	if err != nil || !isOwner {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only owner can remove members"})
		return
	}

	// Can't remove owner
	if memberID == userID {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Owner cannot be removed"})
		return
	}

	// Remove member
	result, err := h.DB.Exec(`
		DELETE FROM budget_members
		WHERE budget_id = $1 AND user_id = $2
	`, budgetID, memberID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to remove member"})
		return
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Member not found"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Member removed successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\market_suggestions_handler.go
=========================================
package handlers

import (
	"budget-api/models"
	"budget-api/services"
	"context"
	"database/sql"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// ============================================================================
// MARKET SUGGESTIONS HANDLER
// Endpoints for obtaining personalized competitor suggestions
// ============================================================================

type MarketSuggestionsHandler struct {
	DB             *sql.DB
	MarketAnalyzer *services.MarketAnalyzerService
	AIService      *services.ClaudeAIService
}

func NewMarketSuggestionsHandler(db *sql.DB) *MarketSuggestionsHandler {
	aiService := services.NewClaudeAIService()
	marketAnalyzer := services.NewMarketAnalyzerService(db, aiService)

	return &MarketSuggestionsHandler{
		DB:             db,
		MarketAnalyzer: marketAnalyzer,
		AIService:      aiService,
	}
}

// ============================================================================
// 1. ANALYZE A SPECIFIC CHARGE
// POST /api/v1/suggestions/analyze
// ============================================================================

type AnalyzeChargeRequest struct {
	Category      string  `json:"category" binding:"required"`
	MerchantName  string  `json:"merchant_name"`
	CurrentAmount float64 `json:"current_amount" binding:"required"`
}

func (h *MarketSuggestionsHandler) AnalyzeCharge(c *gin.Context) {
	userID := c.GetString("user_id")

	var req AnalyzeChargeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
		return
	}

	userCountry, err := h.getUserCountry(c.Request.Context(), userID)
	if err != nil {
		log.Printf("Failed to get user country: %v", err)
		userCountry = "FR"
	}

	log.Printf("[MarketSuggestions] Analyzing charge for user %s: %s - %.2fâ‚¬ (%s)",
		userID, req.Category, req.CurrentAmount, userCountry)

	suggestion, err := h.MarketAnalyzer.AnalyzeCharge(
		c.Request.Context(),
		req.Category,
		req.MerchantName,
		req.CurrentAmount,
		userCountry,
	)

	if err != nil {
		log.Printf("Market analysis failed: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to analyze charge",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, suggestion)
}

// ============================================================================
// 2. BULK ANALYZE ALL CHARGES IN A BUDGET
// POST /api/v1/budgets/:id/suggestions/bulk-analyze
// ============================================================================

type ChargeToAnalyze struct {
	ID           string  `json:"id"`
	Category     string  `json:"category"`
	Label        string  `json:"label"`
	Amount       float64 `json:"amount"`
	MerchantName string  `json:"merchant_name,omitempty"`
}

type BulkAnalyzeRequest struct {
	Charges []ChargeToAnalyze `json:"charges" binding:"required"`
}

func (h *MarketSuggestionsHandler) BulkAnalyzeCharges(c *gin.Context) {
	userID := c.GetString("user_id")
	budgetID := c.Param("id")

	hasAccess, err := h.checkBudgetAccess(c.Request.Context(), userID, budgetID)
	if err != nil || !hasAccess {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}

	var req BulkAnalyzeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
		return
	}

	userCountry, err := h.getUserCountry(c.Request.Context(), userID)
	if err != nil {
		userCountry = "FR"
	}

	log.Printf("[MarketSuggestions] Bulk analyzing %d charges for budget %s", len(req.Charges), budgetID)

	var suggestions []models.ChargeSuggestion
	cacheHits := 0
	aiCalls := 0
	totalSavings := 0.0

	startTime := time.Now()

	for _, charge := range req.Charges {
		if !h.isSuggestionRelevant(charge.Category) {
			continue
		}

		suggestion, err := h.MarketAnalyzer.AnalyzeCharge(
			c.Request.Context(),
			charge.Category,
			charge.MerchantName,
			charge.Amount,
			userCountry,
		)

		if err != nil {
			log.Printf("Failed to analyze charge %s: %v", charge.ID, err)
			continue
		}

		if time.Since(suggestion.LastUpdated) < 5*time.Second {
			aiCalls++
		} else {
			cacheHits++
		}

		if len(suggestion.Competitors) > 0 {
			bestSavings := suggestion.Competitors[0].PotentialSavings
			totalSavings += bestSavings
		}

		suggestions = append(suggestions, models.ChargeSuggestion{
			ChargeID:    charge.ID,
			ChargeLabel: charge.Label,
			Suggestion:  suggestion, // FIX: Removed the "*" dereference
		})
	}

	response := models.BulkAnalyzeResponse{
		Suggestions:           suggestions,
		CacheHits:             cacheHits,
		AICallsMade:           aiCalls,
		TotalPotentialSavings: totalSavings,
	}

	log.Printf("[MarketSuggestions] âœ… Bulk analysis complete: %d suggestions, %d cache hits, %d AI calls, %.2fâ‚¬ potential savings (%.2fs)",
		len(suggestions), cacheHits, aiCalls, totalSavings, time.Since(startTime).Seconds())

	c.JSON(http.StatusOK, response)
}

// ============================================================================
// 3. GET CACHED SUGGESTIONS FOR A CATEGORY
// GET /api/v1/suggestions/category/:category
// ============================================================================

func (h *MarketSuggestionsHandler) GetCategorySuggestions(c *gin.Context) {
	userID := c.GetString("user_id")
	category := c.Param("category")

	userCountry, err := h.getUserCountry(c.Request.Context(), userID)
	if err != nil {
		userCountry = "FR"
	}

	suggestion, err := h.MarketAnalyzer.AnalyzeCharge(
		c.Request.Context(),
		category,
		"",
		0,
		userCountry,
	)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch suggestions"})
		return
	}

	if suggestion == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "No suggestions found"})
		return
	}

	c.JSON(http.StatusOK, suggestion)
}

// ============================================================================
// 4. CLEAN EXPIRED CACHE (Admin/Cron)
// POST /api/v1/admin/suggestions/clean-cache
// ============================================================================

func (h *MarketSuggestionsHandler) CleanExpiredCache(c *gin.Context) {
	// FIX: Temporarily disabled call to CleanCache as it is missing in the service
	// err := h.MarketAnalyzer.CleanCache(c.Request.Context())
	// if err != nil {
	// 	c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to clean cache"})
	// 	return
	// }

	c.JSON(http.StatusOK, gin.H{"message": "Cache cleaned successfully (Simulation)"})
}

// ============================================================================
// 5. CATEGORIZE CHARGE (Hybrid: Static + AI Fallback)
// POST /api/v1/categorize
// ============================================================================

func (h *MarketSuggestionsHandler) CategorizeCharge(c *gin.Context) {
	var req struct {
		Label string `json:"label"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Label required"})
		return
	}

	label := strings.TrimSpace(req.Label)
	if label == "" {
		c.JSON(http.StatusOK, gin.H{"label": "", "category": "OTHER"})
		return
	}

	// Step 1: Try Static Keyword Matching (Instant & Free)
	category := determineCategory(label)

	// Step 2: AI Fallback (If Static failed)
	if category == "OTHER" && len(label) > 3 {
		log.Printf("[Categorizer] Static match failed for '%s'. Calling AI...", label)
		
		ctx, cancel := context.WithTimeout(c.Request.Context(), 5*time.Second)
		defer cancel()

		aiCategory, err := h.AIService.CategorizeLabel(ctx, label)
		if err != nil {
			log.Printf("[Categorizer] AI failed: %v", err)
		} else {
			category = aiCategory
			log.Printf("[Categorizer] AI resolved '%s' -> %s", label, category)
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"label":    req.Label,
		"category": category,
	})
}

func determineCategory(label string) string {
	l := strings.ToUpper(strings.TrimSpace(label))

	keywords := map[string][]string{
		"MOBILE": {
			"MOBILE", "PORTABLE", "SOSH", "BOUYGUES", "FREE", "ORANGE", "SFR", 
			"RED BY", "PRIXTEL", "NRJ MOBILE", "LEBARA", "LYCA", "YOUPI", "CORIOLIS",
		},
		"INTERNET": {
			"BOX", "FIBRE", "ADSL", "INTERNET", "NUMERICABLE", "STARLINK", 
			"NORDNET", "OVH", "K-NET",
		},
		"ENERGY": {
			"EDF", "ENGIE", "TOTAL", "ENERGIE", "ELEC", "GAZ", "ENI", 
			"ILEK", "PLANETE OUI", "VATTENFALL", "MINT", "OHM", "MEGA", "BUTAGAZ", "SUEZ", "VEOLIA",
		},
		"INSURANCE": {
			"ASSURANCE", "AXA", "MAIF", "ALLIANZ", "MACIF", "GROUPAMA", "GMF", 
			"MATMUT", "GENERALI", "MMA", "MAAF", "DIRECT ASSURANCE", "OLIVIER", 
			"LEOCARE", "LUKO", "ALAN", "MGEN", "HARMONIE", "MUTUELLE", "PREVOYANCE",
		},
		"LOAN": {
			"PRET", "CREDIT", "ECHEANCE", "EMPRUNT", "MENSUALITE", "IMMOBILIER", 
			"COFIDIS", "CETELEM", "SOFINCO", "FLOA", "BOURSORAMA", "FRANFINANCE", "YOUNITED",
		},
		"BANK": {
			"BANQUE", "CREDIT AGRICOLE", "SOCIETE GENERALE", "BNP", "LCL", 
			"POSTALE", "CAISSE EPARGNE", "POPULAIRE", "CIC", "REVOLUT", "N26", 
			"BOURSO", "FORTUNEO", "MONABANQ", "HELLO", "QONTO", "SHINE",
		},
		"TRANSPORT": {
			"NAVIGO", "RATP", "SNCF", "TGV", "OUIGO", "UBER", "BOLT", "TAXI", 
			"LIME", "AUTOROUTE", "PEAGE", "VINCI", "APRR", "SANEF", "TOTAL ENERGIES", "ESSO", "BP", "SHELL",
		},
		"SUBSCRIPTION": {
			"NETFLIX", "SPOTIFY", "AMAZON", "PRIME", "DISNEY", "CANAL", 
			"APPLE", "GOOGLE", "YOUTUBE", "DEEZER", "HBO", "PARAMOUNT", "ICLOUD", "DROPBOX",
		},
		"FOOD": {
			"CARREFOUR", "LECLERC", "AUCHAN", "INTERMARCHE", "LIDL", "ALDI", "MONOPRIX", 
			"FRANPRIX", "SUPER U", "HYPER U", "CASINO", "PICARD", "UBER EATS", "DELIVEROO", 
			"MC DO", "MCDONALD", "BK", "BURGER KING", "KFC", "STARBUCKS",
		},
	}

	for cat, keys := range keywords {
		for _, k := range keys {
			if strings.Contains(l, k) {
				if (k == "SFR" || k == "ORANGE" || k == "BOUYGUES" || k == "FREE") {
					if strings.Contains(l, "BOX") || strings.Contains(l, "FIBRE") || strings.Contains(l, "FIXE") {
						return "INTERNET"
					}
					if strings.Contains(l, "MOBILE") || strings.Contains(l, "FORFAIT") {
						return "MOBILE"
					}
					return "MOBILE"
				}
				return cat
			}
		}
	}

	return "OTHER"
}

// ============================================================================
// HELPERS
// ============================================================================

func (h *MarketSuggestionsHandler) getUserCountry(ctx context.Context, userID string) (string, error) {
	var country sql.NullString
	err := h.DB.QueryRowContext(ctx,
		"SELECT country FROM users WHERE id = $1",
		userID,
	).Scan(&country)

	if err != nil {
		return "FR", err
	}

	if !country.Valid || country.String == "" {
		return "FR", nil
	}

	return country.String, nil
}

func (h *MarketSuggestionsHandler) checkBudgetAccess(ctx context.Context, userID string, budgetID string) (bool, error) {
	var exists bool
	err := h.DB.QueryRowContext(ctx,
		`SELECT EXISTS(
            SELECT 1 FROM budget_members 
            WHERE budget_id = $1 AND user_id = $2
        )`,
		budgetID, userID,
	).Scan(&exists)

	return exists, err
}

func (h *MarketSuggestionsHandler) isSuggestionRelevant(category string) bool {
	category = strings.ToUpper(category)

	relevantCategories := map[string]bool{
		"ENERGY":    true,
		"INTERNET":  true,
		"MOBILE":    true,
		"INSURANCE": true,
		"LOAN":      true,
		"BANK":      true,
	}

	return relevantCategories[category]
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\user.go
=========================================
package handlers

import (
	"database/sql"
	"net/http"
	"strings"
	"log"

	"github.com/gin-gonic/gin"
	"budget-api/middleware"
	"budget-api/models"
	"budget-api/utils"
)

type UserHandler struct {
	DB *sql.DB
}

// ============================================================================
// PROFILE MANAGEMENT
// ============================================================================

// GetProfile returns the current user's profile
func (h *UserHandler) GetProfile(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var user models.User
	// âœ… Query includes country and postal_code
	err := h.DB.QueryRow(`
		SELECT id, email, name, 
		       COALESCE(avatar, ''), 
		       COALESCE(country, 'FR'),
		       COALESCE(postal_code, ''),
		       totp_enabled, email_verified, 
		       created_at, updated_at
		FROM users
		WHERE id = $1
	`, userID).Scan(
		&user.ID, 
		&user.Email, 
		&user.Name, 
		&user.Avatar, 
		&user.Country,
		&user.PostalCode,
		&user.TOTPEnabled,
		&user.EmailVerified, 
		&user.CreatedAt, 
		&user.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}
	if err != nil {
		log.Printf("Error fetching profile: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch profile"})
		return
	}

	c.JSON(http.StatusOK, user)
}

// UpdateProfileRequest struct to validate input
type UpdateProfileRequest struct {
	Name   string `json:"name" binding:"required"`
	Avatar string `json:"avatar"` // Optional: Base64 string or Gradient CSS
}

// UpdateProfile updates user profile information
func (h *UserHandler) UpdateProfile(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req UpdateProfileRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	_, err := h.DB.Exec(`
		UPDATE users
		SET name = $1, avatar = $2, updated_at = NOW()
		WHERE id = $3
	`, req.Name, req.Avatar, userID)

	if err != nil {
		log.Printf("Error updating profile: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update profile"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Profile updated successfully",
		"user": gin.H{
			"name":   req.Name,
			"avatar": req.Avatar,
		},
	})
}

// ============================================================================
// âœ… LOCATION MANAGEMENT (NEW)
// ============================================================================

// UpdateLocationRequest struct for location updates
type UpdateLocationRequest struct {
	Country    string `json:"country" binding:"required,len=2"`
	PostalCode string `json:"postal_code"`
}

// UpdateLocation updates user's country and postal code
func (h *UserHandler) UpdateLocation(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req UpdateLocationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid country code (must be 2 characters)"})
		return
	}

	// Validate country code (list of supported countries)
	validCountries := map[string]bool{
		"FR": true, "BE": true, "DE": true, "ES": true, "IT": true,
		"PT": true, "NL": true, "LU": true, "AT": true, "IE": true,
	}
	
	countryUpper := strings.ToUpper(req.Country)
	if !validCountries[countryUpper] {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Country not supported. Supported countries: FR, BE, DE, ES, IT, PT, NL, LU, AT, IE",
		})
		return
	}

	// Update database
	_, err := h.DB.Exec(`
		UPDATE users
		SET country = $1, postal_code = $2, updated_at = NOW()
		WHERE id = $3
	`, countryUpper, req.PostalCode, userID)

	if err != nil {
		log.Printf("Failed to update location for user %s: %v", userID, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update location"})
		return
	}

	log.Printf("âœ… User %s location updated: %s %s", userID, countryUpper, req.PostalCode)

	c.JSON(http.StatusOK, gin.H{
		"message":     "Location updated successfully",
		"country":     countryUpper,
		"postal_code": req.PostalCode,
	})
}

// GetLocation returns user's current location
func (h *UserHandler) GetLocation(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var country, postalCode string
	err := h.DB.QueryRow(`
		SELECT COALESCE(country, 'FR'), COALESCE(postal_code, '')
		FROM users
		WHERE id = $1
	`, userID).Scan(&country, &postalCode)

	if err != nil {
		log.Printf("Error fetching location: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch location"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"country":     country,
		"postal_code": postalCode,
	})
}

// ============================================================================
// PASSWORD MANAGEMENT
// ============================================================================

// ChangePasswordRequest struct for password updates
type ChangePasswordRequest struct {
	CurrentPassword string `json:"current_password" binding:"required"`
	NewPassword     string `json:"new_password" binding:"required,min=6"`
}

// ChangePassword changes the user's password
func (h *UserHandler) ChangePassword(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req ChangePasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get current password hash
	var currentHash string
	err := h.DB.QueryRow(`
		SELECT password_hash FROM users WHERE id = $1
	`, userID).Scan(&currentHash)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify password"})
		return
	}

	// Verify current password
	if !utils.CheckPassword(req.CurrentPassword, currentHash) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Current password is incorrect"})
		return
	}

	// Hash new password
	newHash, err := utils.HashPassword(req.NewPassword)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash new password"})
		return
	}

	// Update password
	_, err = h.DB.Exec(`
		UPDATE users
		SET password_hash = $1, updated_at = NOW()
		WHERE id = $2
	`, newHash, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update password"})
		return
	}

	log.Printf("âœ… User %s password changed successfully", userID)

	c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})
}

// ============================================================================
// 2FA MANAGEMENT
// ============================================================================

// SetupTOTP generates a TOTP secret for the user
func (h *UserHandler) SetupTOTP(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Get user email
	var email string
	err := h.DB.QueryRow(`SELECT email FROM users WHERE id = $1`, userID).Scan(&email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user"})
		return
	}

	// Generate TOTP secret
	secret, qrCode, err := utils.GenerateTOTPSecret(email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate TOTP"})
		return
	}

	// Store secret temporarily (not enabled yet)
	_, err = h.DB.Exec(`
		UPDATE users
		SET totp_secret = $1, updated_at = NOW()
		WHERE id = $2
	`, secret, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to store TOTP secret"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"secret":  secret,
		"qr_code": qrCode,
	})
}

// VerifyTOTPRequest struct for TOTP verification
type VerifyTOTPRequest struct {
	Code string `json:"code" binding:"required"`
}

// VerifyTOTP enables 2FA after successful verification
func (h *UserHandler) VerifyTOTP(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req VerifyTOTPRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get TOTP secret
	var secret sql.NullString
	err := h.DB.QueryRow(`
		SELECT totp_secret FROM users WHERE id = $1
	`, userID).Scan(&secret)

	if err != nil || !secret.Valid {
		c.JSON(http.StatusBadRequest, gin.H{"error": "TOTP not set up"})
		return
	}

	// Verify code
	valid, err := utils.VerifyTOTP(secret.String, req.Code)
	if err != nil || !valid {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid TOTP code"})
		return
	}

	// Enable 2FA
	_, err = h.DB.Exec(`
		UPDATE users
		SET totp_enabled = TRUE, updated_at = NOW()
		WHERE id = $1
	`, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to enable 2FA"})
		return
	}

	log.Printf("âœ… 2FA enabled for user %s", userID)

	c.JSON(http.StatusOK, gin.H{
		"message": "2FA enabled successfully",
		"enabled": true,
	})
}

// DisableTOTPRequest struct for disabling 2FA
type DisableTOTPRequest struct {
	Password string `json:"password" binding:"required"`
	Code     string `json:"code" binding:"required"`
}

// DisableTOTP disables 2FA after verification
func (h *UserHandler) DisableTOTP(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req DisableTOTPRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get password hash and TOTP secret
	var passwordHash string
	var secret sql.NullString
	err := h.DB.QueryRow(`
		SELECT password_hash, totp_secret FROM users WHERE id = $1
	`, userID).Scan(&passwordHash, &secret)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify credentials"})
		return
	}

	// Check password
	if !utils.CheckPassword(req.Password, passwordHash) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid password"})
		return
	}

	// Verify TOTP code
	if secret.Valid {
		valid, err := utils.VerifyTOTP(secret.String, req.Code)
		if err != nil || !valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid 2FA code"})
			return
		}
	}

	// Disable 2FA
	_, err = h.DB.Exec(`
		UPDATE users
		SET totp_enabled = FALSE, totp_secret = NULL, updated_at = NOW()
		WHERE id = $1
	`, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to disable 2FA"})
		return
	}

	log.Printf("âœ… 2FA disabled for user %s", userID)

	c.JSON(http.StatusOK, gin.H{
		"message": "2FA disabled successfully",
		"enabled": false,
	})
}

// ============================================================================
// ACCOUNT DELETION
// ============================================================================

// DeleteAccountRequest struct for account deletion
type DeleteAccountRequest struct {
	Password string `json:"password" binding:"required"`
}

// DeleteAccount deletes the user's account
func (h *UserHandler) DeleteAccount(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req DeleteAccountRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Verify password
	var passwordHash string
	err := h.DB.QueryRow(`
		SELECT password_hash FROM users WHERE id = $1
	`, userID).Scan(&passwordHash)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify password"})
		return
	}

	if !utils.CheckPassword(req.Password, passwordHash) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid password"})
		return
	}

	// Delete user (cascade will handle related data)
	_, err = h.DB.Exec(`DELETE FROM users WHERE id = $1`, userID)

	if err != nil {
		log.Printf("Error deleting account: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete account"})
		return
	}

	log.Printf("âœ… User %s account deleted", userID)

	c.JSON(http.StatusOK, gin.H{"message": "Account deleted successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\ws.go
=========================================
package handlers

import (
	"github.com/gin-gonic/gin"
	"github.com/olahol/melody"
	"log"
	"fmt"
)

type WSHandler struct {
	M *melody.Melody
}

func NewWSHandler() *WSHandler {
	m := melody.New()
	
	// Configurer la taille max des messages
	m.Config.MaxMessageSize = 1024 * 1024 

	return &WSHandler{M: m}
}

// HandleWS gÃ¨re la connexion WebSocket
func (h *WSHandler) HandleWS(c *gin.Context) {
	budgetID := c.Param("id")
	
	// On upgrade la requÃªte HTTP en WebSocket
	// On passe le budgetID dans le contexte de la session Melody
	h.M.HandleRequest(c.Writer, c.Request)
	
	h.M.HandleConnect(func(s *melody.Session) {
		// On stocke sur quel budget l'utilisateur est connectÃ©
		// Note: Dans une vraie app, on vÃ©rifierait le Token JWT ici aussi
		s.Set("budget_id", budgetID)
		log.Printf("Client connectÃ© au budget: %s", budgetID)
	})
}

// BroadcastUpdate envoie un signal Ã  tous les clients Ã©coutant ce budget
func (h *WSHandler) BroadcastUpdate(budgetID string, updateType string, userWhoUpdated string) {
	msg := []byte(fmt.Sprintf(`{"type": "%s", "user": "%s"}`, updateType, userWhoUpdated))
	
	h.M.BroadcastFilter(msg, func(q *melody.Session) bool {
		// On n'envoie qu'aux gens connectÃ©s sur CE budget
		id, exists := q.Get("budget_id")
		return exists && id == budgetID
	})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\middleware\auth.go
=========================================
package middleware

import (
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"budget-api/utils"
)

func AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
			c.Abort()
			return
		}

		token := parts[1]

		claims, err := utils.ValidateToken(token)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			c.Abort()
			return
		}

		c.Set("user_id", claims.UserID)
		c.Set("user_email", claims.Email)

		c.Next()
	}
}

func GetUserID(c *gin.Context) string {
	userID, exists := c.Get("user_id")
	if !exists {
		return ""
	}
	return userID.(string)
}

func GetUserEmail(c *gin.Context) string {
	email, exists := c.Get("user_email")
	if !exists {
		return ""
	}
	return email.(string)
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\middleware\ratelimit.go
=========================================
package middleware

import (
	"net/http"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
)

type rateLimiter struct {
	requests map[string]*clientRequest
	mu       sync.RWMutex
	limit    int
	window   time.Duration
}

type clientRequest struct {
	count     int
	resetTime time.Time
}

var limiter *rateLimiter

func init() {
	limiter = &rateLimiter{
		requests: make(map[string]*clientRequest),
		limit:    100,
		window:   time.Minute,
	}

	go func() {
		ticker := time.NewTicker(time.Minute)
		defer ticker.Stop()
		for range ticker.C {
			limiter.cleanup()
		}
	}()
}

func RateLimiter() gin.HandlerFunc {
	return func(c *gin.Context) {
		ip := c.ClientIP()

		limiter.mu.Lock()
		defer limiter.mu.Unlock()

		client, exists := limiter.requests[ip]
		now := time.Now()

		if !exists || now.After(client.resetTime) {
			limiter.requests[ip] = &clientRequest{
				count:     1,
				resetTime: now.Add(limiter.window),
			}
			c.Next()
			return
		}

		if client.count >= limiter.limit {
			c.JSON(http.StatusTooManyRequests, gin.H{
				"error":       "Rate limit exceeded",
				"retry_after": client.resetTime.Sub(now).Seconds(),
			})
			c.Abort()
			return
		}

		client.count++
		c.Next()
	}
}

func (rl *rateLimiter) cleanup() {
	rl.mu.Lock()
	defer rl.mu.Unlock()

	now := time.Now()
	for ip, client := range rl.requests {
		if now.After(client.resetTime) {
			delete(rl.requests, ip)
		}
	}
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\migration\migrate_yearly_data.go
=========================================
// migration/migrate_yearly_data.go
// Script de migration pour convertir l'ancien format yearlyData (noms de mois)
// vers le nouveau format (annÃ©es avec tableaux indexÃ©s)
//
// USAGE:
// 1. Ajouter ce fichier dans budget-api/migration/
// 2. Appeler MigrateAllBudgets() depuis main.go ou un endpoint admin
// 3. Ou exÃ©cuter comme commande CLI: go run migration/migrate_yearly_data.go

package migration

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"budget-api/utils"
)

// Mois franÃ§ais dans l'ordre (index 0 = Janvier)
var MONTHS = []string{
	"Janvier", "FÃ©vrier", "Mars", "Avril", "Mai", "Juin",
	"Juillet", "AoÃ»t", "Septembre", "Octobre", "Novembre", "DÃ©cembre",
}

// Map pour normaliser les variantes de noms de mois (encodage UTF-8 cassÃ©, etc.)
var MONTH_NAME_VARIANTS = map[string]string{
	// Standard
	"Janvier": "Janvier", "janvier": "Janvier",
	"FÃ©vrier": "FÃ©vrier", "fÃ©vrier": "FÃ©vrier", "Fevrier": "FÃ©vrier",
	"Mars": "Mars", "mars": "Mars",
	"Avril": "Avril", "avril": "Avril",
	"Mai": "Mai", "mai": "Mai",
	"Juin": "Juin", "juin": "Juin",
	"Juillet": "Juillet", "juillet": "Juillet",
	"AoÃ»t": "AoÃ»t", "aoÃ»t": "AoÃ»t", "Aout": "AoÃ»t",
	"Septembre": "Septembre", "septembre": "Septembre",
	"Octobre": "Octobre", "octobre": "Octobre",
	"Novembre": "Novembre", "novembre": "Novembre",
	"DÃ©cembre": "DÃ©cembre", "dÃ©cembre": "DÃ©cembre", "Decembre": "DÃ©cembre",
	// Encodage UTF-8 mojibake (caractÃ¨res mal dÃ©codÃ©s)
	"FÃƒÂ©vrier":  "FÃ©vrier",
	"AoÃƒÂ»t":     "AoÃ»t",
	"DÃƒÂ©cembre": "DÃ©cembre",
}

// Structure pour les donnÃ©es chiffrÃ©es en DB
type EncryptedData struct {
	Encrypted string `json:"encrypted"`
}

// Structure pour une annÃ©e de donnÃ©es (nouveau format)
type YearData struct {
	Months          []map[string]interface{} `json:"months"`
	Expenses        []map[string]interface{} `json:"expenses"`
	MonthComments   []string                 `json:"monthComments"`
	ExpenseComments []map[string]interface{} `json:"expenseComments"`
	DeletedMonths   []int                    `json:"deletedMonths"`
}

// Normalise un nom de mois (gÃ¨re les variantes d'encodage)
func normalizeMonthName(monthKey string) (string, bool) {
	if normalized, ok := MONTH_NAME_VARIANTS[monthKey]; ok {
		return normalized, true
	}
	return "", false
}

// VÃ©rifie si une clÃ© est un nom de mois
func isMonthName(key string) bool {
	_, ok := normalizeMonthName(key)
	return ok
}

// Retourne l'index d'un mois (0-11)
func getMonthIndex(monthName string) int {
	normalized, ok := normalizeMonthName(monthName)
	if !ok {
		return -1
	}
	for i, m := range MONTHS {
		if m == normalized {
			return i
		}
	}
	return -1
}

// VÃ©rifie si yearlyData est dans l'ancien format (noms de mois comme clÃ©s)
func isLegacyFormat(yearlyData map[string]interface{}) bool {
	for key := range yearlyData {
		if isMonthName(key) {
			return true
		}
	}
	return false
}

// VÃ©rifie si yearlyData est dÃ©jÃ  dans le nouveau format (annÃ©es avec .months)
func isNewFormat(yearlyData map[string]interface{}) bool {
	for key, value := range yearlyData {
		// VÃ©rifie si la clÃ© est une annÃ©e (4 chiffres)
		if len(key) == 4 && key[0] >= '0' && key[0] <= '9' {
			if yearMap, ok := value.(map[string]interface{}); ok {
				if _, hasMonths := yearMap["months"]; hasMonths {
					return true
				}
			}
		}
	}
	return false
}

// CrÃ©e une structure d'annÃ©e vide
func createEmptyYearData() YearData {
	return YearData{
		Months:          make([]map[string]interface{}, 12),
		Expenses:        make([]map[string]interface{}, 12),
		MonthComments:   make([]string, 12),
		ExpenseComments: make([]map[string]interface{}, 12),
		DeletedMonths:   []int{},
	}
}

// Migre les donnÃ©es d'un budget de l'ancien vers le nouveau format
func MigrateBudgetData(data map[string]interface{}) (map[string]interface{}, bool, error) {
	yearlyData, ok := data["yearlyData"].(map[string]interface{})
	if !ok || yearlyData == nil {
		return data, false, nil // Pas de yearlyData, rien Ã  migrer
	}

	// VÃ©rifier si dÃ©jÃ  au nouveau format
	if isNewFormat(yearlyData) {
		log.Println("  â†’ DonnÃ©es dÃ©jÃ  au nouveau format, skip")
		return data, false, nil
	}

	// VÃ©rifier si c'est l'ancien format
	if !isLegacyFormat(yearlyData) {
		log.Println("  â†’ Format non reconnu, skip")
		return data, false, nil
	}

	log.Println("  â†’ Ancien format dÃ©tectÃ©, migration en cours...")

	// DÃ©terminer l'annÃ©e cible
	targetYear := time.Now().Year()
	if cy, ok := data["currentYear"].(float64); ok {
		targetYear = int(cy)
	}
	yearKey := fmt.Sprintf("%d", targetYear)

	// CrÃ©er la nouvelle structure
	newYearlyData := make(map[string]interface{})
	newYearData := createEmptyYearData()

	// Initialiser les tableaux
	for i := 0; i < 12; i++ {
		newYearData.Months[i] = make(map[string]interface{})
		newYearData.Expenses[i] = make(map[string]interface{})
		newYearData.MonthComments[i] = ""
		newYearData.ExpenseComments[i] = make(map[string]interface{})
	}

	// Migrer yearlyData (allocations projets)
	for monthKey, monthData := range yearlyData {
		idx := getMonthIndex(monthKey)
		if idx >= 0 && idx < 12 {
			if md, ok := monthData.(map[string]interface{}); ok {
				// VÃ©rifier que ce n'est pas une structure year-based accidentellement
				if _, hasMonths := md["months"]; !hasMonths {
					newYearData.Months[idx] = md
				}
			}
		}
	}

	// Migrer yearlyExpenses si prÃ©sent
	if yearlyExpenses, ok := data["yearlyExpenses"].(map[string]interface{}); ok {
		for monthKey, expenseData := range yearlyExpenses {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if ed, ok := expenseData.(map[string]interface{}); ok {
					newYearData.Expenses[idx] = ed
				}
			}
		}
	}

	// Migrer monthComments si prÃ©sent
	if monthComments, ok := data["monthComments"].(map[string]interface{}); ok {
		for monthKey, comment := range monthComments {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if c, ok := comment.(string); ok {
					newYearData.MonthComments[idx] = c
				}
			}
		}
	}

	// Migrer projectComments si prÃ©sent
	if projectComments, ok := data["projectComments"].(map[string]interface{}); ok {
		for monthKey, comments := range projectComments {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if pc, ok := comments.(map[string]interface{}); ok {
					newYearData.ExpenseComments[idx] = pc
				}
			}
		}
	}

	// Migrer oneTimeIncomes si prÃ©sent (ancien format: { "Janvier": 500, ... })
	if oneTimeIncomes, ok := data["oneTimeIncomes"].(map[string]interface{}); ok {
		newOneTimeIncomes := make(map[string]interface{})
		newYearIncomes := make([]map[string]interface{}, 12)
		
		for i := 0; i < 12; i++ {
			newYearIncomes[i] = map[string]interface{}{"amount": 0, "description": ""}
		}

		for monthKey, income := range oneTimeIncomes {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if amount, ok := income.(float64); ok {
					newYearIncomes[idx] = map[string]interface{}{
						"amount":      amount,
						"description": "",
					}
				}
			}
		}

		newOneTimeIncomes[yearKey] = newYearIncomes
		data["oneTimeIncomes"] = newOneTimeIncomes
	}

	// Convertir YearData en map pour JSON
	yearDataMap := map[string]interface{}{
		"months":          newYearData.Months,
		"expenses":        newYearData.Expenses,
		"monthComments":   newYearData.MonthComments,
		"expenseComments": newYearData.ExpenseComments,
		"deletedMonths":   newYearData.DeletedMonths,
	}
	newYearlyData[yearKey] = yearDataMap

	// Mettre Ã  jour les donnÃ©es
	data["yearlyData"] = newYearlyData
	data["version"] = "2.3-migrated"
	data["lastUpdated"] = time.Now().Format(time.RFC3339)

	// Supprimer les anciens champs obsolÃ¨tes
	delete(data, "yearlyExpenses")
	delete(data, "monthComments")
	delete(data, "projectComments")

	return data, true, nil
}

// MigrateBudgetRecord migre un enregistrement de la table budget_data
func MigrateBudgetRecord(ctx context.Context, db *sql.DB, budgetID string, rawJSON []byte) error {
	// 1. DÃ©crypter si nÃ©cessaire
	var data map[string]interface{}
	var wrapper EncryptedData

	if err := json.Unmarshal(rawJSON, &wrapper); err == nil && wrapper.Encrypted != "" {
		// DonnÃ©es chiffrÃ©es
		decryptedBytes, err := utils.Decrypt(wrapper.Encrypted)
		if err != nil {
			return fmt.Errorf("failed to decrypt: %w", err)
		}
		if err := json.Unmarshal(decryptedBytes, &data); err != nil {
			return fmt.Errorf("failed to unmarshal decrypted data: %w", err)
		}
	} else {
		// DonnÃ©es non chiffrÃ©es (legacy)
		if err := json.Unmarshal(rawJSON, &data); err != nil {
			return fmt.Errorf("failed to unmarshal data: %w", err)
		}
	}

	// 2. Migrer les donnÃ©es
	migratedData, wasMigrated, err := MigrateBudgetData(data)
	if err != nil {
		return fmt.Errorf("migration failed: %w", err)
	}

	if !wasMigrated {
		return nil // Rien Ã  faire
	}

	// 3. Re-chiffrer et sauvegarder
	migratedJSON, err := json.Marshal(migratedData)
	if err != nil {
		return fmt.Errorf("failed to marshal migrated data: %w", err)
	}

	encryptedString, err := utils.Encrypt(migratedJSON)
	if err != nil {
		return fmt.Errorf("failed to encrypt: %w", err)
	}

	newWrapper := EncryptedData{Encrypted: encryptedString}
	storageJSON, err := json.Marshal(newWrapper)
	if err != nil {
		return fmt.Errorf("failed to marshal wrapper: %w", err)
	}

	// 4. Mettre Ã  jour en base
	updateQuery := `
		UPDATE budget_data
		SET data = $1, version = version + 1, updated_at = $2
		WHERE budget_id = $3
	`
	_, err = db.ExecContext(ctx, updateQuery, storageJSON, time.Now(), budgetID)
	if err != nil {
		return fmt.Errorf("failed to update DB: %w", err)
	}

	log.Printf("  âœ… Budget %s migrÃ© avec succÃ¨s", budgetID)
	return nil
}

// MigrateAllBudgets migre tous les budgets de la base de donnÃ©es
func MigrateAllBudgets(db *sql.DB) error {
	ctx := context.Background()

	log.Println("ðŸš€ DÃ©marrage de la migration des donnÃ©es budget...")
	log.Println("========================================")

	// RÃ©cupÃ©rer tous les budgets avec leurs donnÃ©es
	query := `
		SELECT bd.budget_id, bd.data, b.name
		FROM budget_data bd
		JOIN budgets b ON bd.budget_id = b.id
		ORDER BY bd.updated_at DESC
	`

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to query budgets: %w", err)
	}
	defer rows.Close()

	var migrated, skipped, errors int

	for rows.Next() {
		var budgetID string
		var rawJSON []byte
		var budgetName string

		if err := rows.Scan(&budgetID, &rawJSON, &budgetName); err != nil {
			log.Printf("âŒ Erreur scan: %v", err)
			errors++
			continue
		}

		log.Printf("\nðŸ“¦ Budget: %s (%s)", budgetName, budgetID)

		if err := MigrateBudgetRecord(ctx, db, budgetID, rawJSON); err != nil {
			log.Printf("  âŒ Erreur: %v", err)
			errors++
		} else {
			migrated++
		}
	}

	log.Println("\n========================================")
	log.Printf("ðŸ“Š RÃ©sultat: %d migrÃ©s, %d skippÃ©s, %d erreurs", migrated, skipped, errors)
	log.Println("âœ… Migration terminÃ©e!")

	return nil
}

// MigrateSingleBudget migre un seul budget par son ID
func MigrateSingleBudget(db *sql.DB, budgetID string) error {
	ctx := context.Background()

	query := `SELECT data FROM budget_data WHERE budget_id = $1`
	var rawJSON []byte

	if err := db.QueryRowContext(ctx, query, budgetID).Scan(&rawJSON); err != nil {
		if err == sql.ErrNoRows {
			return fmt.Errorf("budget %s not found", budgetID)
		}
		return err
	}

	return MigrateBudgetRecord(ctx, db, budgetID, rawJSON)
}




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\banking.go
=========================================
package models

import (
	"time"
)

type BankConnection struct {
	ID                   string        `json:"id"`
	UserID               string        `json:"user_id"`
	InstitutionID        string        `json:"institution_id"`
	InstitutionName      string        `json:"institution_name"`
	ProviderConnectionID string        `json:"-"` // Internal use only
	Status               string        `json:"status"`
	ExpiresAt            time.Time     `json:"expires_at"`
	CreatedAt            time.Time     `json:"created_at"`
	UpdatedAt            time.Time     `json:"updated_at"`
	Accounts             []BankAccount `json:"accounts,omitempty"`
}

type BankAccount struct {
	ID                string    `json:"id"`
	ConnectionID      string    `json:"connection_id"`
	ExternalAccountID string    `json:"-"` // Internal use only
	Name              string    `json:"name"`
	Mask              string    `json:"mask"`
	Currency          string    `json:"currency"`
	Balance           float64   `json:"balance"`
	IsSavingsPool     bool      `json:"is_savings_pool"` // Critical for Reality Check
	LastSyncedAt      time.Time `json:"last_synced_at"`
}

// Request to toggle the pool status
type UpdateAccountPoolRequest struct {
	IsSavingsPool bool `json:"is_savings_pool"`
}

// Response for Reality Check
type RealityCheckSummary struct {
	TotalRealCash float64       `json:"total_real_cash"`
	Accounts      []BankAccount `json:"accounts"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\budget.go
=========================================
package models

import (
	"encoding/json"
	"time"
)

type Budget struct {
	ID        string    `json:"id"`
	Name      string    `json:"name" binding:"required"`
	OwnerID   string    `json:"owner_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	IsOwner   bool          `json:"is_owner"`   // To store the CASE statement result
	OwnerName string        `json:"owner_name"` // To store the user.name from the JOIN
	Members   []BudgetMember `json:"members"`    // To hold the list of members
}

type BudgetMember struct {
	ID          string          `json:"id"`
	BudgetID    string          `json:"budget_id"`
	UserID      string          `json:"user_id"`
	User        *User           `json:"user,omitempty"`
	Role        string          `json:"role"`
	Permissions json.RawMessage `json:"permissions"`
	JoinedAt    time.Time       `json:"joined_at"`
	UserName  string `json:"user_name"`  // To store u.name from the JOIN (line 236 in service)
	UserEmail string `json:"user_email"` // To store u.email from the JOIN (line 237 in service)
}

type BudgetData struct {
	ID        string          `json:"id"`
	BudgetID  string          `json:"budget_id"`
	Data      json.RawMessage `json:"data"`
	Version   int             `json:"version"`
	UpdatedBy string          `json:"updated_by"`
	UpdatedAt time.Time       `json:"updated_at"`
}

type CreateBudgetRequest struct {
	Name string `json:"name" binding:"required"`
}

type UpdateBudgetDataRequest struct {
	Data json.RawMessage `json:"data" binding:"required"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\charge.go
=========================================
package models

// Charge reprÃ©sente une dÃ©pense rÃ©currente ou une transaction Ã  catÃ©goriser
type Charge struct {
	ID       string  `json:"id"`
	Label    string  `json:"label"`
	Amount   float64 `json:"amount"`
	Category string  `json:"category"` // ex: "ENERGY", "MOBILE"
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\invitation.go
=========================================
package models

import (
	"time"
)

type Invitation struct {
	ID        string    `json:"id"`
	BudgetID  string    `json:"budget_id"`
	Email     string    `json:"email" binding:"required,email"`
	InvitedBy string    `json:"invited_by"`
	Token     string    `json:"token"`
	Status    string    `json:"status"`
	ExpiresAt time.Time `json:"expires_at"`
	CreatedAt time.Time `json:"created_at"`
}

type InvitationRequest struct {
	Email string `json:"email" binding:"required,email"`
}

type AcceptInvitationRequest struct {
	Token string `json:"token" binding:"required"`
}

type InvitationResponse struct {
	Invitation Invitation `json:"invitation"`
	Budget     Budget     `json:"budget"`
	InviterName string    `json:"inviter_name"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\suggestion.go
=========================================
package models

import "time"

// ============================================================================
// ANCIENNES STRUCTURES - GARDER POUR COMPATIBILITÃ‰
// ============================================================================

// Suggestion reprÃ©sente une suggestion d'Ã©conomie simple (ancien systÃ¨me)
type Suggestion struct {
	ID               string  `json:"id"`
	ChargeID         string  `json:"charge_id"`         // L'ID de la dÃ©pense concernÃ©e
	Type             string  `json:"type"`              // ex: "MOBILE_OFFER", "ENERGY_OFFER"
	Title            string  `json:"title"`             // ex: "Forfait mobile Ã©levÃ©"
	Message          string  `json:"message"`           // ex: "Vous payez 70â‚¬/mois. La moyenne est Ã  20â‚¬."
	PotentialSavings float64 `json:"potential_savings"` // ex: 600.00 (par an)
	ActionLink       string  `json:"action_link"`       // Lien d'affiliation direct (ex: Sosh)
	CanBeContacted   bool    `json:"can_be_contacted"`  // Si TRUE, affiche le bouton "ÃŠtre rappelÃ©"
}

// ============================================================================
// NOUVELLES STRUCTURES - SystÃ¨me avancÃ© avec recherche de concurrents
// ============================================================================

// Competitor reprÃ©sente un concurrent avec dÃ©tails complets
type Competitor struct {
	Name             string   `json:"name"`
	TypicalPrice     float64  `json:"typical_price"`
	BestOffer        string   `json:"best_offer"`
	PotentialSavings float64  `json:"potential_savings"`
	AffiliateLink    string   `json:"affiliate_link,omitempty"`
	Pros             []string `json:"pros"`
	Cons             []string `json:"cons"`
	ContactAvailable bool     `json:"contact_available"`
}

// MarketSuggestion reprÃ©sente une suggestion de marchÃ© avec liste de concurrents
type MarketSuggestion struct {
	ID           string       `json:"id"`
	Category     string       `json:"category"`
	Country      string       `json:"country"`
	MerchantName string       `json:"merchant_name,omitempty"`
	Competitors  []Competitor `json:"competitors"`
	LastUpdated  time.Time    `json:"last_updated"`
	ExpiresAt    time.Time    `json:"expires_at"`
}

// ChargeSuggestion associe une charge avec sa suggestion de marchÃ©
type ChargeSuggestion struct {
	ChargeID    string            `json:"charge_id"`
	ChargeLabel string            `json:"charge_label"`
	Suggestion  *MarketSuggestion `json:"suggestion"`
}

// BulkAnalyzeResponse retourne les rÃ©sultats d'une analyse bulk
type BulkAnalyzeResponse struct {
	Suggestions           []ChargeSuggestion `json:"suggestions"`
	CacheHits             int                `json:"cache_hits"`
	AICallsMade           int                `json:"ai_calls_made"`
	TotalPotentialSavings float64            `json:"total_potential_savings"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\user.go
=========================================
package models

import "time"

// ============================================================================
// USER MODEL
// ============================================================================

type User struct {
	ID            string    `json:"id"`
	Email         string    `json:"email"`
	Name          string    `json:"name"`
	Avatar        string    `json:"avatar,omitempty"`
	Country       string    `json:"country,omitempty"`       // âœ… NEW
	PostalCode    string    `json:"postal_code,omitempty"`   // âœ… NEW
	PasswordHash  string    `json:"-"` // Never expose in JSON
	TOTPSecret    string    `json:"-"` // Never expose in JSON
	TOTPEnabled   bool      `json:"totp_enabled"`
	EmailVerified bool      `json:"email_verified"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

// ============================================================================
// USER LOCATION
// ============================================================================

type UserLocation struct {
	Country    string `json:"country"`
	PostalCode string `json:"postal_code,omitempty"`
}

// ============================================================================
// AUTHENTICATION REQUESTS
// ============================================================================

type SignupRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required,min=6"`
	Name     string `json:"name" binding:"required"`
}

type LoginRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required"`
	TOTPCode string `json:"totp_code,omitempty"`
}

type AuthResponse struct {
	Token string `json:"token"`
	User  User   `json:"user"`
}

// ============================================================================
// PASSWORD & 2FA
// ============================================================================

type ChangePasswordRequest struct {
	CurrentPassword string `json:"current_password" binding:"required"`
	NewPassword     string `json:"new_password" binding:"required,min=6"`
}

type TOTPSetupResponse struct {
	Secret string `json:"secret"`
	QRCode string `json:"qr_code"`
}

type VerifyTOTPRequest struct {
	Code string `json:"code" binding:"required,len=6"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\routes\routes.go
=========================================
package routes

import (
	"database/sql"
	"budget-api/handlers"
	"budget-api/services"
	"github.com/gin-gonic/gin"
)

// SetupAuthRoutes sets up public authentication routes.
func SetupAuthRoutes(rg *gin.RouterGroup, db *sql.DB) {
	authHandler := &handlers.AuthHandler{DB: db}
	rg.POST("/auth/signup", authHandler.Signup)
	rg.POST("/auth/login", authHandler.Login)
	rg.GET("/auth/verify", authHandler.VerifyEmail)
	rg.POST("/auth/verify/resend", authHandler.ResendVerification)
}

// SetupBudgetRoutes sets up protected budget and related routes.
func SetupBudgetRoutes(rg *gin.RouterGroup, db *sql.DB) {
	budgetService := services.NewBudgetService(db)
	emailService := services.NewEmailService()
	h := handlers.NewHandler(budgetService, emailService)

	rg.GET("/budgets", h.GetBudgets)
	rg.POST("/budgets", h.CreateBudget)
	rg.GET("/budgets/:id", h.GetBudget)
	rg.PUT("/budgets/:id", h.UpdateBudget)
	rg.DELETE("/budgets/:id", h.DeleteBudget)
	rg.GET("/budgets/:id/data", h.GetBudgetData)
	rg.PUT("/budgets/:id/data", h.UpdateBudgetData)
	rg.POST("/budgets/:id/invite", h.InviteMember)
	rg.POST("/invitations/accept", h.AcceptInvitation)
}

func SetupUserRoutes(rg *gin.RouterGroup, db *sql.DB) {
	userHandler := &handlers.UserHandler{DB: db}
	rg.GET("/user/profile", userHandler.GetProfile)
	rg.PUT("/user/profile", userHandler.UpdateProfile)
	
	// âœ… NEW: Location routes
	rg.PUT("/user/location", userHandler.UpdateLocation)
	rg.GET("/user/location", userHandler.GetLocation)
	
	rg.POST("/user/password", userHandler.ChangePassword)
	rg.POST("/user/2fa/setup", userHandler.SetupTOTP)
	rg.POST("/user/2fa/verify", userHandler.VerifyTOTP)
	rg.POST("/user/2fa/disable", userHandler.DisableTOTP)
	rg.DELETE("/user/account", userHandler.DeleteAccount)
}

func SetupInvitationRoutes(rg *gin.RouterGroup, db *sql.DB) {
	invitationHandler := &handlers.InvitationHandler{DB: db}
	rg.GET("/budgets/:id/invitations", invitationHandler.GetInvitations)
	rg.DELETE("/budgets/:id/invitations/:invitation_id", invitationHandler.CancelInvitation)
	rg.DELETE("/budgets/:id/members/:member_id", invitationHandler.RemoveMember)
}

func SetupAdminRoutes(rg *gin.RouterGroup, db *sql.DB) {
	adminHandler := &handlers.AdminHandler{DB: db}
	
	// Migration endpoints
	rg.POST("/admin/migrate-budgets", adminHandler.MigrateAllBudgets)
	rg.POST("/admin/migrate-budget/:id", adminHandler.MigrateSingleBudget)
}

// SetupEnableBankingRoutes configure les routes Enable Banking
func SetupEnableBankingRoutes(rg *gin.RouterGroup, db *sql.DB) {
	handler := handlers.NewEnableBankingHandler(db)

	// Liste des banques disponibles
	rg.GET("/banking/enablebanking/banks", handler.GetBanks)

	// Connexion d'une banque (crÃ©ation auth request)
	rg.POST("/banking/enablebanking/connect", handler.CreateConnection)

	// Callback aprÃ¨s autorisation
	rg.GET("/banking/enablebanking/callback", handler.HandleCallback)

	// RÃ©cupÃ©ration des connexions d'un budget
	rg.GET("/budgets/:id/banking/enablebanking/connections", handler.GetConnections)

	// Synchronisation des comptes dans un budget
	rg.POST("/budgets/:id/banking/enablebanking/sync", handler.SyncAccounts)

	// RafraÃ®chissement des soldes
	rg.POST("/banking/enablebanking/refresh", handler.RefreshBalances)

	// RÃ©cupÃ©ration des transactions
	rg.GET("/banking/enablebanking/transactions", handler.GetTransactions)

	// Suppression d'une connexion
	rg.DELETE("/banking/enablebanking/connections/:id", handler.DeleteConnection)
	rg.GET("/banking/budgets/:id/reality-check", handler.GetConnections)
}

// â­ CORRIGÃ‰: Utiliser :id au lieu de :budget_id pour Ã©viter le conflit
func SetupMarketSuggestionsRoutes(rg *gin.RouterGroup, db *sql.DB) {
	handler := handlers.NewMarketSuggestionsHandler(db)

	// Route pour analyser une charge spÃ©cifique
	rg.POST("/suggestions/analyze", handler.AnalyzeCharge)

	// Route pour rÃ©cupÃ©rer suggestions en cache pour une catÃ©gorie
	rg.GET("/suggestions/category/:category", handler.GetCategorySuggestions)

	// â­ FIX: Utiliser :id au lieu de :budget_id
	rg.POST("/budgets/:id/suggestions/bulk-analyze", handler.BulkAnalyzeCharges)
	rg.POST("/categorize", handler.CategorizeCharge)
}

func SetupAdminSuggestionsRoutes(rg *gin.RouterGroup, db *sql.DB) {
	handler := handlers.NewMarketSuggestionsHandler(db)

	// Route pour nettoyer le cache expirÃ© (admin/cron)
	rg.POST("/admin/suggestions/clean-cache", handler.CleanExpiredCache)

	adminHandler := handlers.NewAdminSuggestionHandler(db)
	// Run this once to fix all legacy data
	rg.POST("/admin/suggestions/retroactive-analyze", adminHandler.RetroactiveAnalysis)
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\ai_categorizer.go
=========================================
package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

type AICategorizer struct {
	apiKey string
	client *http.Client
}

func NewAICategorizer() *AICategorizer {
	return &AICategorizer{
		apiKey: os.Getenv("ANTHROPIC_API_KEY"), // ClÃ© Claude
		client: &http.Client{Timeout: 10 * time.Second},
	}
}

// Structures pour l'API Anthropic
type anthropicMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type anthropicRequest struct {
	Model     string             `json:"model"`
	MaxTokens int                `json:"max_tokens"`
	Messages  []anthropicMessage `json:"messages"`
}

type anthropicResponse struct {
	Content []struct {
		Text string `json:"text"`
	} `json:"content"`
	Error *struct {
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

// PredictCategory demande Ã  Claude de classifier un libellÃ©
func (s *AICategorizer) PredictCategory(label string) (string, error) {
	if s.apiKey == "" {
		// Fallback silencieux si pas de clÃ© configurÃ©e
		return "OTHER", fmt.Errorf("ANTHROPIC_API_KEY not set")
	}

	prompt := fmt.Sprintf(`
    Tu es un expert bancaire. Analyse le libellÃ© : "%s".
    CatÃ©gorise-le STRICTEMENT dans une seule de ces catÃ©gories (en majuscules) :
    - ENERGY (Ã©lectricitÃ©, gaz, eau)
    - MOBILE (forfait tÃ©lÃ©phone)
    - INTERNET (box, fibre, hÃ©bergement)
    - INSURANCE (assurance)
    - BANK (frais bancaires)
    - LOAN (crÃ©dit)
    - FOOD (courses, resto)
    - LEISURE (loisirs, streaming, sport)
    - TRANSPORT (essence, pÃ©age, transport)
    - HOUSING (loyer, travaux)
    - SHOPPING (achats divers)
    - HEALTH (santÃ©)
    - SUBSCRIPTION (abonnements divers)
    - OTHER (si incertain)

    RÃ©ponds UNIQUEMENT par le mot clÃ©. Pas de phrase.`, label)

	reqBody := anthropicRequest{
		Model:     "claude-3-haiku-20240307", // ModÃ¨le rapide et Ã©conomique
		MaxTokens: 10,
		Messages: []anthropicMessage{
			{Role: "user", Content: prompt},
		},
	}

	jsonData, _ := json.Marshal(reqBody)

	req, err := http.NewRequest("POST", "https://api.anthropic.com/v1/messages", bytes.NewBuffer(jsonData))
	if err != nil {
		return "OTHER", err
	}

	req.Header.Set("x-api-key", s.apiKey)
	req.Header.Set("anthropic-version", "2023-06-01")
	req.Header.Set("content-type", "application/json")

	resp, err := s.client.Do(req)
	if err != nil {
		return "OTHER", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return "OTHER", fmt.Errorf("anthropic error %d: %s", resp.StatusCode, string(body))
	}

	var result anthropicResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "OTHER", err
	}

	if len(result.Content) > 0 {
		category := strings.TrimSpace(strings.ToUpper(result.Content[0].Text))
		return category, nil
	}

	return "OTHER", nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\banking.go
=========================================
package services

import (
	"context"
	"database/sql"
	"time"
	"fmt"

	"budget-api/models"
	"budget-api/utils"

)

type BankingService struct {
	db *sql.DB
}

func NewBankingService(db *sql.DB) *BankingService {
	return &BankingService{db: db}
}

// GetBudgetConnections renvoie les connexions pour un BUDGET spÃ©cifique
func (s *BankingService) GetBudgetConnections(ctx context.Context, budgetID string) ([]models.BankConnection, error) {
	query := `
		SELECT id, institution_id, institution_name, status, expires_at, created_at
		FROM bank_connections
		WHERE budget_id = $1
		ORDER BY created_at DESC
	`

	rows, err := s.db.QueryContext(ctx, query, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var connections []models.BankConnection
	for rows.Next() {
		var conn models.BankConnection
		err := rows.Scan(&conn.ID, &conn.InstitutionID, &conn.InstitutionName, &conn.Status, &conn.ExpiresAt, &conn.CreatedAt)
		if err != nil {
			return nil, err
		}

		accounts, err := s.GetAccountsByConnection(ctx, conn.ID)
		if err == nil {
			conn.Accounts = accounts
		}

		connections = append(connections, conn)
	}

	return connections, nil
}

// GetAccountsByConnection fetches accounts for a specific connection
func (s *BankingService) GetAccountsByConnection(ctx context.Context, connectionID string) ([]models.BankAccount, error) {
	query := `
		SELECT id, connection_id, name, mask, currency, balance, is_savings_pool, last_synced_at
		FROM bank_accounts
		WHERE connection_id = $1
		ORDER BY name
	`
	rows, err := s.db.QueryContext(ctx, query, connectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var accounts []models.BankAccount
	for rows.Next() {
		var acc models.BankAccount
		err := rows.Scan(
			&acc.ID, &acc.ConnectionID, &acc.Name, &acc.Mask,
			&acc.Currency, &acc.Balance, &acc.IsSavingsPool, &acc.LastSyncedAt,
		)
		if err != nil {
			continue
		}
		accounts = append(accounts, acc)
	}
	return accounts, nil
}

// GetRealityCheckSum calcule le total pour un BUDGET spÃ©cifique
func (s *BankingService) GetRealityCheckSum(ctx context.Context, budgetID string) (float64, error) {
	query := `
		SELECT COALESCE(SUM(ba.balance), 0)
		FROM bank_accounts ba
		JOIN bank_connections bc ON ba.connection_id = bc.id
		WHERE bc.budget_id = $1 AND ba.is_savings_pool = TRUE
	`
	var total float64
	err := s.db.QueryRowContext(ctx, query, budgetID).Scan(&total)
	return total, err
}

// UpdateAccountPool toggles whether an account counts towards the Reality Check
func (s *BankingService) UpdateAccountPool(ctx context.Context, accountID string, isSavingsPool bool) error {
	_, err := s.db.ExecContext(ctx, "UPDATE bank_accounts SET is_savings_pool = $1 WHERE id = $2", isSavingsPool, accountID)
	return err
}

// DeleteConnection removes a connection and its accounts
func (s *BankingService) DeleteConnection(ctx context.Context, connectionID string) error {
	return utils.WithTransaction(s.db, func(tx *sql.Tx) error {
		if _, err := tx.ExecContext(ctx, "DELETE FROM bank_accounts WHERE connection_id = $1", connectionID); err != nil {
			return err
		}
		if _, err := tx.ExecContext(ctx, "DELETE FROM bank_connections WHERE id = $1", connectionID); err != nil {
			return err
		}
		return nil
	})
}

// SaveConnectionWithTokens sauvegarde une connexion Enable Banking
func (s *BankingService) SaveConnectionWithTokens(
	ctx context.Context,
	userID string,
	budgetID string,
	accountUID string,
	bankName string,
	sessionID string,
	provider string,
	accessToken string,
	expiresAt time.Time,
) (string, error) {
	
	// Extraire le pays du nom de la banque (ou utiliser une valeur par dÃ©faut)
	country := "FR" // Par dÃ©faut
	
	// Pour Enable Banking, on utilise le session_id comme identifiant
	// et on stocke le nom de la banque dans aspsp_name
	
	query := `
		INSERT INTO banking_connections (
			user_id,
			budget_id,
			aspsp_name,
			aspsp_country,
			session_id,
			access_token,
			expires_at,
			status,
			created_at,
			updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
		ON CONFLICT (user_id, budget_id, aspsp_name, aspsp_country)
		DO UPDATE SET
			session_id = EXCLUDED.session_id,
			access_token = EXCLUDED.access_token,
			expires_at = EXCLUDED.expires_at,
			updated_at = NOW()
		RETURNING id
	`
	
	var connectionID string
	err := s.db.QueryRowContext(
		ctx,
		query,
		userID,
		budgetID,
		bankName,
		country,
		sessionID,
		accessToken,
		expiresAt,
		"active",
	).Scan(&connectionID)
	
	if err != nil {
		return "", fmt.Errorf("failed to save connection: %w", err)
	}
	
	return connectionID, nil
}

// SaveAccount sauvegarde un compte bancaire Enable Banking
func (s *BankingService) SaveAccount(
	ctx context.Context,
	connectionID string,
	accountID string, // C'est le UID du compte Enable Banking
	name string,
	mask string,
	currency string,
	balance float64,
) error {
	
	query := `
		INSERT INTO banking_accounts (
			connection_id,
			account_id,
			account_name,
			account_type,
			currency,
			balance,
			last_sync_at,
			created_at
		) VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
		ON CONFLICT (connection_id, account_id)
		DO UPDATE SET
			account_name = EXCLUDED.account_name,
			currency = EXCLUDED.currency,
			balance = EXCLUDED.balance,
			last_sync_at = NOW()
	`
	
	_, err := s.db.ExecContext(
		ctx,
		query,
		connectionID,
		accountID,
		name,
		"CACC", // Type par dÃ©faut, pourrait Ãªtre passÃ© en paramÃ¨tre
		currency,
		balance,
	)
	
	if err != nil {
		return fmt.Errorf("failed to save account: %w", err)
	}
	
	return nil
}




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\budget.go
=========================================
package services

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"budget-api/models"
	"budget-api/utils"

	"github.com/google/uuid"
)

type BudgetService struct {
	db *sql.DB
}

func NewBudgetService(db *sql.DB) *BudgetService {
	return &BudgetService{db: db}
}

// Helper struct for DB storage of encrypted blobs
type EncryptedData struct {
	Encrypted string `json:"encrypted"`
}

// Create creates a new budget with transactional safety
func (s *BudgetService) Create(ctx context.Context, name, ownerID string) (*models.Budget, error) {
	budget := &models.Budget{
		ID:        uuid.New().String(),
		Name:      name,
		OwnerID:   ownerID,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	err := utils.WithTransaction(s.db, func(tx *sql.Tx) error {
		// 1. Insert Budget
		query := `
			INSERT INTO budgets (id, name, owner_id, created_at, updated_at)
			VALUES ($1, $2, $3, $4, $5)
		`
		if _, err := tx.ExecContext(ctx, query, budget.ID, budget.Name, budget.OwnerID, budget.CreatedAt, budget.UpdatedAt); err != nil {
			return err
		}

		// 2. Add Owner as Member
		memberQuery := `
			INSERT INTO budget_members (id, budget_id, user_id, role, joined_at)
			VALUES ($1, $2, $3, $4, $5)
		`
		if _, err := tx.ExecContext(ctx, memberQuery, uuid.New().String(), budget.ID, ownerID, "owner", time.Now()); err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return budget, nil
}

// GetByID gets a budget by ID
func (s *BudgetService) GetByID(ctx context.Context, id, userID string) (*models.Budget, error) {
	query := `
		SELECT b.id, b.name, b.owner_id, b.created_at, b.updated_at,
		       CASE WHEN b.owner_id = $2 THEN true ELSE false END as is_owner,
		       u.name as owner_name
		FROM budgets b
		LEFT JOIN users u ON b.owner_id = u.id
		INNER JOIN budget_members bm ON b.id = bm.budget_id
		WHERE b.id = $1 AND bm.user_id = $2
	`

	var budget models.Budget
	err := s.db.QueryRowContext(ctx, query, id, userID).Scan(
		&budget.ID,
		&budget.Name,
		&budget.OwnerID,
		&budget.CreatedAt,
		&budget.UpdatedAt,
		&budget.IsOwner,
		&budget.OwnerName,
	)

	if err != nil {
		return nil, err
	}

	// Get members
	members, err := s.GetMembers(ctx, id)
	if err != nil {
		return nil, err
	}
	budget.Members = members

	return &budget, nil
}

// GetUserBudgets gets all budgets for a user
func (s *BudgetService) GetUserBudgets(ctx context.Context, userID string) ([]models.Budget, error) {
	query := `
		SELECT b.id, b.name, b.owner_id, b.created_at, b.updated_at,
		       CASE WHEN b.owner_id = $1 THEN true ELSE false END as is_owner
		FROM budgets b
		INNER JOIN budget_members bm ON b.id = bm.budget_id
		WHERE bm.user_id = $1
		ORDER BY b.created_at DESC
	`

	rows, err := s.db.QueryContext(ctx, query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var budgets []models.Budget
	for rows.Next() {
		var budget models.Budget
		err := rows.Scan(
			&budget.ID,
			&budget.Name,
			&budget.OwnerID,
			&budget.CreatedAt,
			&budget.UpdatedAt,
			&budget.IsOwner,
		)
		if err != nil {
			return nil, err
		}

		members, _ := s.GetMembers(ctx, budget.ID)
		budget.Members = members

		budgets = append(budgets, budget)
	}

	return budgets, nil
}

// Update updates a budget name
func (s *BudgetService) Update(ctx context.Context, id, name string) error {
	query := `
		UPDATE budgets
		SET name = $1, updated_at = $2
		WHERE id = $3
	`
	_, err := s.db.ExecContext(ctx, query, name, time.Now(), id)
	return err
}

// Delete deletes a budget completely
func (s *BudgetService) Delete(ctx context.Context, budgetID string) error {
	return utils.WithTransaction(s.db, func(tx *sql.Tx) error {
		// Delete related records first
		if _, err := tx.ExecContext(ctx, "DELETE FROM budget_members WHERE budget_id = $1", budgetID); err != nil { return err }
		if _, err := tx.ExecContext(ctx, "DELETE FROM invitations WHERE budget_id = $1", budgetID); err != nil { return err }
		if _, err := tx.ExecContext(ctx, "DELETE FROM budget_data WHERE budget_id = $1", budgetID); err != nil { return err }
		// Delete budget
		if _, err := tx.ExecContext(ctx, "DELETE FROM budgets WHERE id = $1", budgetID); err != nil { return err }
		return nil
	})
}

// GetData gets the data for a budget and DECRYPTS it
func (s *BudgetService) GetData(ctx context.Context, budgetID string) (interface{}, error) {
	query := `SELECT data FROM budget_data WHERE budget_id = $1 ORDER BY updated_at DESC LIMIT 1`

	var rawJSON []byte
	err := s.db.QueryRowContext(ctx, query, budgetID).Scan(&rawJSON)
	if err == sql.ErrNoRows {
		return map[string]interface{}{}, nil
	}
	if err != nil {
		return nil, err
	}

	if len(rawJSON) == 0 {
		return map[string]interface{}{}, nil
	}

	// 1. Try to unmarshal as EncryptedData wrapper
	var wrapper EncryptedData
	if err := json.Unmarshal(rawJSON, &wrapper); err == nil && wrapper.Encrypted != "" {
		// 2. It IS encrypted -> Decrypt it
		decryptedBytes, err := utils.Decrypt(wrapper.Encrypted)
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt data: %w", err)
		}
		
		// 3. Unmarshal the real data
		var realData interface{}
		if err := json.Unmarshal(decryptedBytes, &realData); err != nil {
			return nil, err
		}
		return realData, nil
	}

	// Fallback: If it wasn't encrypted (legacy data), return it as is
	var data interface{}
	if err := json.Unmarshal(rawJSON, &data); err != nil {
		return nil, err
	}

	return data, nil
}

// UpdateData ENCRYPTS the data before saving it
func (s *BudgetService) UpdateData(ctx context.Context, budgetID string, data interface{}) error {
	// 1. Convert real data to JSON bytes
	realDataJSON, err := json.Marshal(data)
	if err != nil {
		return err
	}

	// 2. Encrypt the bytes
	encryptedString, err := utils.Encrypt(realDataJSON)
	if err != nil {
		return err
	}

	// 3. Wrap in a JSON object so Postgres JSONB column accepts it
	wrapper := EncryptedData{Encrypted: encryptedString}
	storageJSON, err := json.Marshal(wrapper)
	if err != nil {
		return err
	}

	// 4. Save to DB
	var existingID string
	checkQuery := `SELECT id FROM budget_data WHERE budget_id = $1 LIMIT 1`
	err = s.db.QueryRowContext(ctx, checkQuery, budgetID).Scan(&existingID)

	if err == sql.ErrNoRows {
		insertQuery := `
			INSERT INTO budget_data (id, budget_id, data, version, updated_at)
			VALUES ($1, $2, $3, 1, $4)
		`
		_, err = s.db.ExecContext(ctx, insertQuery, uuid.New().String(), budgetID, storageJSON, time.Now())
		return err
	}

	if err != nil {
		return err
	}

	updateQuery := `
		UPDATE budget_data
		SET data = $1, version = version + 1, updated_at = $2
		WHERE budget_id = $3
	`
	_, err = s.db.ExecContext(ctx, updateQuery, storageJSON, time.Now(), budgetID)
	return err
}

// GetMembers gets all members of a budget (Populates Avatar)
func (s *BudgetService) GetMembers(ctx context.Context, budgetID string) ([]models.BudgetMember, error) {
	query := `
		SELECT bm.id, bm.user_id, bm.role, bm.joined_at, u.name, u.email, COALESCE(u.avatar, '')
		FROM budget_members bm
		JOIN users u ON bm.user_id = u.id
		WHERE bm.budget_id = $1
		ORDER BY bm.joined_at
	`

	rows, err := s.db.QueryContext(ctx, query, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var members []models.BudgetMember
	for rows.Next() {
		var member models.BudgetMember
		var avatar string

		err := rows.Scan(
			&member.ID,
			&member.UserID,
			&member.Role,
			&member.JoinedAt,
			&member.UserName,
			&member.UserEmail,
			&avatar,
		)
		if err != nil {
			return nil, err
		}
		
		member.User = &models.User{
			ID:    member.UserID,
			Name:  member.UserName,
			Email: member.UserEmail,
			Avatar: avatar,
		}
		
		members = append(members, member)
	}

	return members, nil
}

// CreateInvitation creates an invitation
func (s *BudgetService) CreateInvitation(ctx context.Context, budgetID, email, invitedBy string) (*models.Invitation, error) {
	invitation := &models.Invitation{
		ID:        uuid.New().String(),
		BudgetID:  budgetID,
		Email:     email,
		Token:     uuid.New().String(),
		Status:    "pending",
		InvitedBy: invitedBy,
		ExpiresAt: time.Now().Add(7 * 24 * time.Hour),
		CreatedAt: time.Now(),
	}

	query := `
		INSERT INTO invitations (id, budget_id, email, token, status, invited_by, expires_at, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
	`

	_, err := s.db.ExecContext(ctx, query,
		invitation.ID, invitation.BudgetID, invitation.Email,
		invitation.Token, invitation.Status, invitation.InvitedBy,
		invitation.ExpiresAt, invitation.CreatedAt,
	)

	if err != nil {
		return nil, err
	}

	return invitation, nil
}

// GetPendingInvitation gets a pending invitation
func (s *BudgetService) GetPendingInvitation(ctx context.Context, budgetID, email string) (*models.Invitation, error) {
	query := `
		SELECT id, budget_id, email, token, expires_at, created_at
		FROM invitations
		WHERE budget_id = $1 AND email = $2 AND status = 'pending' AND expires_at > NOW()
		LIMIT 1
	`

	var invitation models.Invitation
	err := s.db.QueryRowContext(ctx, query, budgetID, email).Scan(
		&invitation.ID,
		&invitation.BudgetID,
		&invitation.Email,
		&invitation.Token,
		&invitation.ExpiresAt,
		&invitation.CreatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil
	}

	if err != nil {
		return nil, err
	}

	return &invitation, nil
}

// DeleteInvitation deletes an invitation
func (s *BudgetService) DeleteInvitation(ctx context.Context, invitationID string) error {
	query := `DELETE FROM invitations WHERE id = $1`
	_, err := s.db.ExecContext(ctx, query, invitationID)
	return err
}

// IsMemberByEmail checks if an email is already a member of a budget
func (s *BudgetService) IsMemberByEmail(ctx context.Context, budgetID, email string) (bool, error) {
    query := `
        SELECT EXISTS(
            SELECT 1 FROM budget_members bm
            JOIN users u ON bm.user_id = u.id
            WHERE bm.budget_id = $1 AND u.email = $2
        )
    `
    var exists bool
    err := s.db.QueryRowContext(ctx, query, budgetID, email).Scan(&exists)
    return exists, err
}

// AcceptInvitation accepts invitation, cleans up duplicates, and notifies others via "fake update"
func (s *BudgetService) AcceptInvitation(ctx context.Context, token, userID string) error {
	var invitation models.Invitation
	query := `
		SELECT id, budget_id, email, expires_at
		FROM invitations
		WHERE token = $1 AND status = 'pending'
	`

	err := s.db.QueryRowContext(ctx, query, token).Scan(
		&invitation.ID,
		&invitation.BudgetID,
		&invitation.Email,
		&invitation.ExpiresAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return sql.ErrNoRows
		}
		return err
	}

	if time.Now().After(invitation.ExpiresAt) {
		return sql.ErrNoRows
	}

	return utils.WithTransaction(s.db, func(tx *sql.Tx) error {
        // 1. Get User Name for Notification
        var userName string
        if err := tx.QueryRowContext(ctx, "SELECT name FROM users WHERE id = $1", userID).Scan(&userName); err != nil {
            return err
        }

		// 2. Add Member
		memberQuery := `
			INSERT INTO budget_members (id, budget_id, user_id, role, joined_at)
			VALUES ($1, $2, $3, $4, $5)
		`
		if _, err := tx.ExecContext(ctx, memberQuery, uuid.New().String(), invitation.BudgetID, userID, "member", time.Now()); err != nil {
			return err
		}

		// 3. Mark CURRENT invitation accepted
		updateQuery := `
			UPDATE invitations
			SET status = 'accepted', updated_at = $1
			WHERE id = $2
		`
		if _, err := tx.ExecContext(ctx, updateQuery, time.Now(), invitation.ID); err != nil {
			return err
		}

        // 4. CLEANUP: Delete pending invites for this email
        cleanupQuery := `DELETE FROM invitations WHERE budget_id = $1 AND email = $2 AND status = 'pending'`
        if _, err := tx.ExecContext(ctx, cleanupQuery, invitation.BudgetID, invitation.Email); err != nil {
            return err
        }

        // 5. NOTIFICATION TRIGGER: Update budget metadata (forces polling frontend to notice a change)
        timestamp := time.Now().Format(time.RFC3339)
        notifyQuery := `
            UPDATE budget_data 
            SET data = data || jsonb_build_object('lastUpdated', $1::text, 'updatedBy', $2::text),
                version = version + 1,
                updated_at = NOW()
            WHERE budget_id = $3
        `
        tx.ExecContext(ctx, notifyQuery, timestamp, userName, invitation.BudgetID)

		return nil
	})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\categorizer.go
=========================================
package services

import (
	"context"
	"database/sql"
	"log"
	"strings"
)

type CategorizerService struct {
	db *sql.DB
	ai *AICategorizer
}

func NewCategorizerService(db *sql.DB) *CategorizerService {
	return &CategorizerService{
		db: db,
		ai: NewAICategorizer(),
	}
}

// --- STATIC DICTIONARY (Gratuit) ---
var staticRules = map[string]string{
	// ENERGIE
	"edf": "ENERGY", "engie": "ENERGY", "total energie": "ENERGY", "totalenergies": "ENERGY",
	"eni": "ENERGY", "ilek": "ENERGY", "sowee": "ENERGY", "veolia": "ENERGY", "suez": "ENERGY",
	
	// TELECOM
	"orange": "INTERNET", "sosh": "MOBILE", "sfr": "INTERNET", "red by sfr": "MOBILE",
	"bouygues": "INTERNET", "bbox": "INTERNET", "free": "INTERNET", "free mobile": "MOBILE",
	
	// ASSURANCE
	"axa": "INSURANCE", "allianz": "INSURANCE", "macif": "INSURANCE", "maif": "INSURANCE",
	"matmut": "INSURANCE", "groupama": "INSURANCE", "maaf": "INSURANCE", "alan": "INSURANCE",
	
	// BANQUE
	"boursorama": "BANK", "boursobank": "BANK", "revolut": "BANK", "n26": "BANK",
	"bnp": "BANK", "societe generale": "BANK", "credit agricole": "BANK", "lcl": "BANK",
	
	// LOISIRS
	"netflix": "LEISURE", "spotify": "LEISURE", "deezer": "LEISURE", "apple": "LEISURE",
	"disney": "LEISURE", "prime video": "LEISURE", "basic fit": "LEISURE", "fitness park": "LEISURE",
	
	// ALIMENTATION
	"leclerc": "FOOD", "carrefour": "FOOD", "auchan": "FOOD", "intermarche": "FOOD",
	"lidl": "FOOD", "aldi": "FOOD", "monoprix": "FOOD", "franprix": "FOOD", "uber eats": "FOOD",
	
	// TRANSPORT
	"sncf": "TRANSPORT", "ratp": "TRANSPORT", "uber": "TRANSPORT", "bolt": "TRANSPORT",
	"total access": "TRANSPORT", "shell": "TRANSPORT", "vinci": "TRANSPORT",
}

// GetCategory dÃ©termine la catÃ©gorie
func (s *CategorizerService) GetCategory(ctx context.Context, rawLabel string) (string, error) {
	// 1. Normalisation
	normalizedLabel := strings.ToLower(strings.TrimSpace(rawLabel))
	if normalizedLabel == "" {
		return "OTHER", nil
	}

	// 2. RÃ¨gles Statiques
	if category, exists := staticRules[normalizedLabel]; exists {
		return category, nil
	}
	for key, cat := range staticRules {
		if strings.Contains(normalizedLabel, key) {
			return cat, nil
		}
	}

	// 3. Cache DB
	var dbCategory string
	err := s.db.QueryRowContext(ctx, 
		"SELECT category FROM label_mappings WHERE normalized_label = $1", 
		normalizedLabel).Scan(&dbCategory)

	if err == nil {
		return dbCategory, nil
	}

	// 4. Appel Claude AI
	log.Printf("[Categorizer] Calling Claude AI for '%s'...", normalizedLabel)
	aiCategory, err := s.ai.PredictCategory(rawLabel)
	
	if err != nil {
		log.Printf("[Categorizer] AI Error: %v", err)
		return "OTHER", nil 
	}

	// 5. Sauvegarde Cache
	go func(lbl, cat string) {
		_, err := s.db.Exec(
			"INSERT INTO label_mappings (normalized_label, category, source) VALUES ($1, $2, 'AI') ON CONFLICT (normalized_label) DO NOTHING",
			lbl, cat,
		)
		if err != nil {
			log.Printf("[Categorizer] Failed to cache: %v", err)
		}
	}(normalizedLabel, aiCategory)

	return aiCategory, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\claude_ai_service.go
=========================================
package services

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

// ============================================================================
// CLAUDE AI SERVICE - Pour recherche de concurrents dÃ©taillÃ©e
// Utilise Claude Sonnet 3.5 (le plus intelligent pour analyses complexes)
// ============================================================================

type ClaudeAIService struct {
	apiKey     string
	model      string
	maxTokens  int
	httpClient *http.Client
}

type ClaudeRequest struct {
	Model     string          `json:"model"`
	MaxTokens int             `json:"max_tokens"`
	System    string          `json:"system,omitempty"` // Added System prompt support
	Messages  []ClaudeMessage `json:"messages"`
}

type ClaudeMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type ClaudeResponse struct {
	ID         string `json:"id"`
	Type       string `json:"type"`
	Role       string `json:"role"`
	Content    []struct {
		Type string `json:"type"`
		Text string `json:"text"`
	} `json:"content"`
	Model      string `json:"model"`
	StopReason string `json:"stop_reason"`
	Usage      struct {
		InputTokens  int `json:"input_tokens"`
		OutputTokens int `json:"output_tokens"`
	} `json:"usage"`
}

func NewClaudeAIService() *ClaudeAIService {
	// Fallback to a valid model if env var is missing or incorrect
	model := "claude-3-5-sonnet-20240620" // Use latest stable Sonnet
	
	return &ClaudeAIService{
		apiKey:     os.Getenv("ANTHROPIC_API_KEY"),
		model:      model,
		maxTokens:  2000,
		httpClient: &http.Client{Timeout: 60 * time.Second},
	}
}

// ============================================================================
// 1. APPEL PRINCIPAL Ã€ CLAUDE (ANALYSE CONCURRENTIELLE)
// ============================================================================

func (s *ClaudeAIService) CallClaude(ctx context.Context, prompt string) (string, error) {
	if s.apiKey == "" {
		return "", fmt.Errorf("ANTHROPIC_API_KEY not set")
	}

	requestBody := ClaudeRequest{
		Model:     s.model,
		MaxTokens: s.maxTokens,
		Messages: []ClaudeMessage{
			{
				Role:    "user",
				Content: prompt,
			},
		},
	}

	return s.executeRequest(ctx, requestBody)
}

// ============================================================================
// 2. CATEGORISATION INTELLIGENTE (NOUVEAU)
// AppelÃ© si le mapping statique Ã©choue. Utilise un prompt systÃ¨me strict.
// ============================================================================

func (s *ClaudeAIService) CategorizeLabel(ctx context.Context, label string) (string, error) {
	if s.apiKey == "" {
		return "OTHER", fmt.Errorf("ANTHROPIC_API_KEY not set")
	}

	// Prompt SystÃ¨me : Instructions strictes pour la catÃ©gorisation
	systemPrompt := `You are a financial transaction classifier. 
	Classify the user's transaction label into exactly ONE of these categories:
	MOBILE, INTERNET, ENERGY, INSURANCE, LOAN, BANK, TRANSPORT, SUBSCRIPTION, FOOD, HOUSING, HEALTH, SHOPPING.
	
	Rules:
	1. If it looks like a phone bill (Sosh, Free, SFR), return MOBILE.
	2. If it looks like an internet box (Livebox, Freebox), return INTERNET.
	3. If it looks like electricity/gas (EDF, Engie), return ENERGY.
	4. If it looks like insurance (Macif, AXA, Allianz), return INSURANCE.
	5. If it looks like a loan (Credit, Pret, Mensualite), return LOAN.
	6. If it matches nothing well, return OTHER.
	
	IMPORTANT: Return ONLY the category name (uppercase). No other text.`

	requestBody := ClaudeRequest{
		Model:     "claude-3-haiku-20240307", // Use Haiku for speed & low cost
		MaxTokens: 20,                       // Very short response needed
		System:    systemPrompt,
		Messages: []ClaudeMessage{
			{
				Role:    "user",
				Content: fmt.Sprintf("Label: %s", label),
			},
		},
	}

	category, err := s.executeRequest(ctx, requestBody)
	if err != nil {
		return "OTHER", err
	}

	// Clean up response (remove whitespace, potential dots)
	cleanCat := strings.ToUpper(strings.TrimSpace(category))
	cleanCat = strings.Trim(cleanCat, ".")
	
	return cleanCat, nil
}

// ============================================================================
// HELPER: EXECUTE REQUEST
// ============================================================================

func (s *ClaudeAIService) executeRequest(ctx context.Context, requestBody ClaudeRequest) (string, error) {
	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return "", fmt.Errorf("failed to marshal request: %w", err)
	}

	req, err := http.NewRequestWithContext(
		ctx,
		"POST",
		"https://api.anthropic.com/v1/messages",
		bytes.NewBuffer(jsonData),
	)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("x-api-key", s.apiKey)
	req.Header.Set("anthropic-version", "2023-06-01")

	resp, err := s.httpClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("HTTP request failed: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
	}

	var claudeResp ClaudeResponse
	if err := json.Unmarshal(body, &claudeResp); err != nil {
		return "", fmt.Errorf("failed to parse response: %w", err)
	}

	if len(claudeResp.Content) == 0 {
		return "", fmt.Errorf("empty response from Claude")
	}

	// Log usage stats
	fmt.Printf("[Claude AI] Model: %s | Tokens: In %d / Out %d | Cost: $%.5f\n",
		claudeResp.Model,
		claudeResp.Usage.InputTokens,
		claudeResp.Usage.OutputTokens,
		s.EstimateCost(claudeResp.Usage.InputTokens, claudeResp.Usage.OutputTokens),
	)

	return claudeResp.Content[0].Text, nil
}

// ============================================================================
// ESTIMATION DES COÃ›TS
// ============================================================================

// Pricing (approximate for Claude 3.5 Sonnet)
const (
	InputTokenPrice  = 0.000003 // $3 per million
	OutputTokenPrice = 0.000015 // $15 per million
)

func (s *ClaudeAIService) EstimateCost(inputTokens int, outputTokens int) float64 {
	inputCost := float64(inputTokens) * InputTokenPrice
	outputCost := float64(outputTokens) * OutputTokenPrice
	return inputCost + outputCost
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\email.go
=========================================
package services

import (
	"budget-api/utils"
)

// EmailService struct
type EmailService struct {
}

// NewEmailService constructor
func NewEmailService() *EmailService {
	return &EmailService{}
}

// SendInvitation wrapper qui appelle la fonction dans utils
func (s *EmailService) SendInvitation(toEmail, inviterName, budgetName, invitationToken string) error {
	return utils.SendInvitationEmail(toEmail, inviterName, budgetName, invitationToken)
}

// SendVerification wrapper qui appelle la fonction dans utils
func (s *EmailService) SendVerification(toEmail, userName, token string) error {
	return utils.SendVerificationEmail(toEmail, userName, token)
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\enable_banking.go
=========================================
package services

import (
	"bytes"
	"context"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

// ============================================================================
// SERVICE STRUCTURE
// ============================================================================

type EnableBankingService struct {
	BaseURL    string
	AppID      string
	PrivateKey *rsa.PrivateKey
	Client     *http.Client
}

// ============================================================================
// INITIALIZATION
// ============================================================================

func NewEnableBankingService() *EnableBankingService {
	log.Println("ðŸ” Initializing Enable Banking Service...")
	
	appID := os.Getenv("ENABLE_BANKING_APP_ID")
	if appID == "" {
		log.Fatal("âŒ ENABLE_BANKING_APP_ID environment variable is not set")
	}
	log.Printf("âœ… App ID configured: %s...", appID[:min(8, len(appID))])
	
	privateKey := loadPrivateKey()
	
	return &EnableBankingService{
		BaseURL:    "https://api.enablebanking.com",
		AppID:      appID,
		PrivateKey: privateKey,
		Client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

func loadPrivateKey() *rsa.PrivateKey {
	log.Println("ðŸ”‘ Loading private key...")
	var pemData []byte
	
	// Essayer base64 d'abord
	if base64Key := os.Getenv("ENABLE_BANKING_PRIVATE_KEY_BASE64"); base64Key != "" {
		log.Println("ðŸ“¦ Found ENABLE_BANKING_PRIVATE_KEY_BASE64")
		
		decoded, err := base64.StdEncoding.DecodeString(base64Key)
		if err != nil {
			log.Fatalf("âŒ Failed to decode base64 private key: %v", err)
		}
		log.Printf("âœ… Successfully decoded base64 key, size: %d bytes", len(decoded))
		pemData = decoded
	} else if keyPath := os.Getenv("ENABLE_BANKING_PRIVATE_KEY_PATH"); keyPath != "" {
		log.Printf("ðŸ“ Loading private key from file: %s", keyPath)
		data, err := os.ReadFile(keyPath)
		if err != nil {
			log.Fatalf("âŒ Failed to read private key file: %v", err)
		}
		log.Printf("âœ… Successfully read key file, size: %d bytes", len(data))
		pemData = data
	} else {
		log.Fatal("âŒ No private key configured. Set ENABLE_BANKING_PRIVATE_KEY_BASE64 or ENABLE_BANKING_PRIVATE_KEY_PATH")
	}

	// Parse PEM
	block, _ := pem.Decode(pemData)
	if block == nil {
		log.Fatal("âŒ Failed to parse PEM block")
	}
	log.Printf("âœ… PEM block type: %s", block.Type)

	// Parse RSA key
	key, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	if err == nil {
		privateKey, ok := key.(*rsa.PrivateKey)
		if !ok {
			log.Fatal("âŒ Key is not RSA private key")
		}
		log.Println("âœ… Successfully parsed PKCS8 RSA private key")
		return privateKey
	}

	// Fallback PKCS1
	privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		log.Fatalf("âŒ Failed to parse private key: %v", err)
	}
	log.Println("âœ… Successfully parsed PKCS1 RSA private key")
	return privateKey
}

// ============================================================================
// JWT GENERATION
// ============================================================================

func (s *EnableBankingService) generateJWT() (string, error) {
	now := time.Now()
	
	claims := jwt.MapClaims{
		"iss": "enablebanking.com",
		"aud": "api.enablebanking.com",
		"iat": now.Unix(),
		"exp": now.Add(1 * time.Hour).Unix(),
	}
	
	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	token.Header["kid"] = s.AppID
	
	signed, err := token.SignedString(s.PrivateKey)
	if err != nil {
		return "", fmt.Errorf("failed to sign JWT: %w", err)
	}
	
	return signed, nil
}

func (s *EnableBankingService) setHeaders(req *http.Request) error {
	token, err := s.generateJWT()
	if err != nil {
		return err
	}
	
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	return nil
}

// ============================================================================
// DATA STRUCTURES
// ============================================================================

type SandboxUser struct {
    Username string `json:"username,omitempty"`
    Password string `json:"password,omitempty"`
    OTP      string `json:"otp,omitempty"`
}

type ASPSP struct {
    Name    string `json:"name"`
    Country string `json:"country"`
    Logo    string `json:"logo"`
    BIC     string `json:"bic,omitempty"`
    Sandbox *struct {
        Users []SandboxUser `json:"users"`  // âœ… CORRECT
    } `json:"sandbox,omitempty"`
    Beta bool `json:"beta"`
}

type Access struct {
	ValidUntil string `json:"valid_until"`
}

type ASPSPIdentifier struct {
	Name    string `json:"name"`
	Country string `json:"country"`
}

type AuthRequest struct {
	Access      Access          `json:"access"`
	ASPSP       ASPSPIdentifier `json:"aspsp"`
	State       string          `json:"state"`
	RedirectURL string          `json:"redirect_url"`
	PSUType     string          `json:"psu_type"`
}

type AuthResponse struct {
	URL             string `json:"url"`
	AuthorizationID string `json:"authorization_id"`
	PSUIDHash       string `json:"psu_id_hash"`
}

type SessionRequest struct {
	Code string `json:"code"`
}

type AccountIdentification struct {
	IBAN  string `json:"iban,omitempty"`
	Other *struct {
		Identification string `json:"identification"`
		SchemeName     string `json:"scheme_name"`
	} `json:"other,omitempty"`
}

type Account struct {
	AccountID       AccountIdentification `json:"account_id"`
	Name            string                `json:"name"`
	Currency        string                `json:"currency"`
	CashAccountType string                `json:"cash_account_type"`
	Details         string                `json:"details,omitempty"`
	Product         string                `json:"product,omitempty"`
	UID             string                `json:"uid"`
}

type SessionResponse struct {
	SessionID string    `json:"session_id"`
	Accounts  []Account `json:"accounts"`
	ASPSP     struct {
		Name    string `json:"name"`
		Country string `json:"country"`
	} `json:"aspsp"`
	PSUType string `json:"psu_type"`
}

type AmountType struct {
	Currency string `json:"currency"`
	Amount   string `json:"amount"`
}

type Balance struct {
	Name          string     `json:"name"`
	BalanceAmount AmountType `json:"balance_amount"`
	BalanceType   string     `json:"balance_type"`
	ReferenceDate string     `json:"reference_date,omitempty"`
}

type BalancesResponse struct {
	Balances []Balance `json:"balances"`
}

type Transaction struct {
	EntryReference          string     `json:"entry_reference,omitempty"`
	TransactionID           string     `json:"transaction_id,omitempty"`
	TransactionAmount       AmountType `json:"transaction_amount"`
	CreditDebitIndicator    string     `json:"credit_debit_indicator"`
	Status                  string     `json:"status"`
	BookingDate             string     `json:"booking_date,omitempty"`
	ValueDate               string     `json:"value_date,omitempty"`
	TransactionDate         string     `json:"transaction_date,omitempty"`
	RemittanceInformation   []string   `json:"remittance_information,omitempty"`
	BalanceAfterTransaction AmountType `json:"balance_after_transaction,omitempty"`
	Creditor                *struct {
		Name string `json:"name"`
	} `json:"creditor,omitempty"`
	Debtor *struct {
		Name string `json:"name"`
	} `json:"debtor,omitempty"`
}

type TransactionsResponse struct {
	Transactions    []Transaction `json:"transactions"`
	ContinuationKey string        `json:"continuation_key,omitempty"`
}

// ============================================================================
// API METHODS
// ============================================================================

// GetASPSPs rÃ©cupÃ¨re la liste des banques disponibles
func (s *EnableBankingService) GetASPSPs(ctx context.Context, country string) ([]ASPSP, error) {
	url := s.BaseURL + "/aspsps"
	if country != "" {
		url += "?country=" + country + "&psu_type=personal&service=AIS"
	}

	log.Printf("ðŸŒ Fetching ASPSPs from: %s", url)

	req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err := s.setHeaders(req); err != nil {
		return nil, fmt.Errorf("failed to set headers: %w", err)
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != 200 {
		log.Printf("âŒ API Error Response: %s", string(respBody))
		return nil, fmt.Errorf("status %d: %s", resp.StatusCode, string(respBody))
	}

	var result struct {
		ASPSPs []ASPSP `json:"aspsps"`
	}

	if err := json.Unmarshal(respBody, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	log.Printf("âœ… Found %d ASPSPs", len(result.ASPSPs))
	return result.ASPSPs, nil
}

// CreateAuthRequest crÃ©e une demande d'autorisation
func (s *EnableBankingService) CreateAuthRequest(ctx context.Context, authReq AuthRequest) (*AuthResponse, error) {
	log.Printf("ðŸ” Creating auth request for %s (%s)", authReq.ASPSP.Name, authReq.ASPSP.Country)

	body, _ := json.Marshal(authReq)
	req, _ := http.NewRequestWithContext(ctx, "POST", s.BaseURL+"/auth", bytes.NewBuffer(body))
	if err := s.setHeaders(req); err != nil {
		return nil, err
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	log.Printf("ðŸ“¥ Auth response status: %d", resp.StatusCode)

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		log.Printf("âŒ Auth Error: %s", string(respBody))
		return nil, fmt.Errorf("auth failed (%d): %s", resp.StatusCode, string(respBody))
	}

	var authResp AuthResponse
	if err := json.Unmarshal(respBody, &authResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	log.Printf("âœ… Authorization URL created: %s", authResp.URL)
	return &authResp, nil
}

// CreateSession crÃ©e une session aprÃ¨s autorisation
func (s *EnableBankingService) CreateSession(ctx context.Context, code, state string) (*SessionResponse, error) {
	log.Printf("ðŸ”„ Creating session with code: %s...", code[:min(10, len(code))])

	sessionReq := SessionRequest{Code: code}
	body, _ := json.Marshal(sessionReq)

	req, _ := http.NewRequestWithContext(ctx, "POST", s.BaseURL+"/sessions", bytes.NewBuffer(body))
	if err := s.setHeaders(req); err != nil {
		return nil, err
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	log.Printf("ðŸ“¥ Session response status: %d", resp.StatusCode)

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		log.Printf("âŒ Session Error: %s", string(respBody))
		return nil, fmt.Errorf("session creation failed (%d): %s", resp.StatusCode, string(respBody))
	}

	var sessionResp SessionResponse
	if err := json.Unmarshal(respBody, &sessionResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	log.Printf("âœ… Session created: %s with %d accounts", sessionResp.SessionID, len(sessionResp.Accounts))
	
	for i, acc := range sessionResp.Accounts {
		iban := acc.AccountID.IBAN
		if iban == "" && acc.AccountID.Other != nil {
			iban = acc.AccountID.Other.Identification
		}
		log.Printf("   ðŸ“Š Account %d: %s | IBAN: %s | UID: %s", i+1, acc.Name, iban, acc.UID)
	}
	
	return &sessionResp, nil
}

// GetBalances rÃ©cupÃ¨re les soldes d'un compte
func (s *EnableBankingService) GetBalances(ctx context.Context, sessionID, accountUID string) ([]Balance, error) {
	url := fmt.Sprintf("%s/accounts/%s/balances", s.BaseURL, accountUID)
	log.Printf("ðŸ’° Fetching balances for account UID: %s", accountUID)
	
	req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err := s.setHeaders(req); err != nil {
		return nil, err
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != 200 {
		log.Printf("âŒ Error response: %s", string(respBody))
		return nil, fmt.Errorf("status %d: %s", resp.StatusCode, string(respBody))
	}

	var balancesResp BalancesResponse
	if err := json.Unmarshal(respBody, &balancesResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	log.Printf("âœ… Retrieved %d balances", len(balancesResp.Balances))
	for i, bal := range balancesResp.Balances {
		log.Printf("   ðŸ’° Balance %d: %s = %s %s", i+1, bal.Name, bal.BalanceAmount.Amount, bal.BalanceAmount.Currency)
	}
	
	return balancesResp.Balances, nil
}

// GetTransactions rÃ©cupÃ¨re les transactions d'un compte
func (s *EnableBankingService) GetTransactions(ctx context.Context, accountUID string, dateFrom, dateTo string) ([]Transaction, error) {
	url := fmt.Sprintf("%s/accounts/%s/transactions", s.BaseURL, accountUID)
	if dateFrom != "" && dateTo != "" {
		url += fmt.Sprintf("?date_from=%s&date_to=%s", dateFrom, dateTo)
	}
	
	log.Printf("ðŸ’³ Fetching transactions for account: %s (from %s to %s)", accountUID, dateFrom, dateTo)

	req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err := s.setHeaders(req); err != nil {
		return nil, err
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != 200 {
		log.Printf("âŒ Error response: %s", string(respBody))
		return nil, fmt.Errorf("status %d: %s", resp.StatusCode, string(respBody))
	}

	var transResp TransactionsResponse
	if err := json.Unmarshal(respBody, &transResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	log.Printf("âœ… Retrieved %d transactions", len(transResp.Transactions))
	return transResp.Transactions, nil
}

// DeleteSession supprime une session
func (s *EnableBankingService) DeleteSession(ctx context.Context, sessionID string) error {
	url := fmt.Sprintf("%s/sessions/%s", s.BaseURL, sessionID)
	log.Printf("ðŸ—‘ï¸  Deleting session: %s", sessionID)
	
	req, _ := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err := s.setHeaders(req); err != nil {
		return err
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 && resp.StatusCode != 204 {
		respBody, _ := io.ReadAll(resp.Body)
		log.Printf("âŒ Delete failed: %s", string(respBody))
		return fmt.Errorf("delete failed (%d): %s", resp.StatusCode, string(respBody))
	}

	log.Println("âœ… Session deleted successfully")
	return nil
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\market_analyzer_service.go
=========================================
package services

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"time"

	"budget-api/models"
)

// ============================================================================
// MARKET ANALYZER SERVICE
// Analyse les charges et trouve des concurrents meilleurs marchÃ©s
// ============================================================================

type MarketAnalyzerService struct {
	DB        *sql.DB
	AIService *ClaudeAIService
}

func NewMarketAnalyzerService(db *sql.DB, aiService *ClaudeAIService) *MarketAnalyzerService {
	return &MarketAnalyzerService{
		DB:        db,
		AIService: aiService,
	}
}

// ============================================================================
// MAIN ANALYSIS FUNCTION
// ============================================================================

func (s *MarketAnalyzerService) AnalyzeCharge(
	ctx context.Context,
	category string,
	merchantName string,
	currentAmount float64,
	country string,
) (*models.MarketSuggestion, error) {
	// â­ Trim spaces pour Ã©viter les bugs avec " " vs ""
	merchantName = strings.TrimSpace(merchantName)
	
	log.Printf("[MarketAnalyzer] Analyzing: category=%s, merchant=%s, amount=%.2f, country=%s",
		category, merchantName, currentAmount, country)

	// 1. Essayer de rÃ©cupÃ©rer depuis le cache
	cached, err := s.getCachedSuggestion(ctx, category, country, merchantName)
	if err == nil && cached != nil {
		log.Printf("[MarketAnalyzer] âœ… Cache HIT")
		return cached, nil
	}

	// 2. Cache MISS - Appeler Claude AI
	log.Printf("[MarketAnalyzer] âš ï¸  Cache MISS - Calling Claude AI...")

	competitors, err := s.searchCompetitors(ctx, category, merchantName, currentAmount, country)
	if err != nil {
		return nil, fmt.Errorf("failed to search competitors: %w", err)
	}

	// 3. CrÃ©er la suggestion
	suggestion := &models.MarketSuggestion{
		Category:     category,
		Country:      country,
		MerchantName: merchantName,
		Competitors:  competitors,
		LastUpdated:  time.Now(),
		ExpiresAt:    time.Now().Add(30*24*time.Hour + 1*time.Minute), // 30 jours + 1 minute de marge
	}

	// 4. Sauvegarder dans le cache
	if err := s.saveSuggestionToCache(ctx, suggestion); err != nil {
		log.Printf("[MarketAnalyzer] âš ï¸  Failed to save to cache: %v", err)
		// Ne pas Ã©chouer l'analyse si le cache ne fonctionne pas
	}

	return suggestion, nil
}

// ============================================================================
// COMPETITOR SEARCH via Claude AI
// ============================================================================

func (s *MarketAnalyzerService) searchCompetitors(
	ctx context.Context,
	category string,
	merchantName string,
	currentAmount float64,
	country string,
) ([]models.Competitor, error) {

	// Construire le prompt
	prompt := s.buildCompetitorSearchPrompt(category, merchantName, currentAmount, country)

	// Appeler Claude AI
	response, err := s.AIService.CallClaude(ctx, prompt)
	if err != nil {
		return nil, fmt.Errorf("AI call failed: %w", err)
	}

	// Parser la rÃ©ponse
	competitors, err := parseCompetitorsFromResponse(response)
	if err != nil {
		return nil, fmt.Errorf("failed to parse AI response: %w", err)
	}

	return competitors, nil
}

// ============================================================================
// PROMPT BUILDING
// ============================================================================

func (s *MarketAnalyzerService) buildCompetitorSearchPrompt(
	category string,
	merchantName string,
	currentAmount float64,
	country string,
) string {

	// Contexte par catÃ©gorie et pays
	categoryContexts := map[string]map[string]string{
		"ENERGY": {
			"FR": "Fournisseurs d'Ã©nergie franÃ§ais populaires: EDF, Engie, TotalEnergies, Eni, Vattenfall, Ekwateur, PlanÃ¨te OUI. Prix moyen: 90-120â‚¬/mois pour un appartement.",
			"BE": "Fournisseurs d'Ã©nergie belges: Engie, Luminus, Eni, TotalEnergies, Mega, Bolt. Prix moyen: 100-130â‚¬/mois.",
		},
		"INTERNET": {
			"FR": "Fournisseurs Internet franÃ§ais: Orange, SFR, Free, Bouygues Telecom, RED by SFR, Sosh. Prix fibre: 20-45â‚¬/mois.",
			"BE": "Fournisseurs Internet belges: Proximus, Telenet, VOO, Orange Belgium, Scarlet. Prix moyen: 30-50â‚¬/mois.",
		},
		"MOBILE": {
			"FR": "Forfaits mobiles franÃ§ais: Free Mobile, RED by SFR, Sosh, B&YOU, Prixtel, La Poste Mobile. Prix: 5-20â‚¬/mois pour 50-100 Go.",
			"BE": "Forfaits mobiles belges: Proximus, Orange Belgium, BASE, Mobile Vikings, Scarlet. Prix: 10-25â‚¬/mois.",
		},
		"INSURANCE": {
			"FR": "Assurances franÃ§aises: AXA, Allianz, Macif, MAIF, Groupama, GMF, Generali. Prix habitation: 15-40â‚¬/mois.",
			"BE": "Assurances belges: AG Insurance, Ethias, Belfius, AXA Belgium, Baloise. Prix habitation: 20-50â‚¬/mois.",
		},
		"LOAN": {
			"FR": "Banques et prÃªts franÃ§ais: Boursorama, Fortuneo, Hello bank, BNP Paribas, CrÃ©dit Agricole, LCL. Taux moyens: 3-4%.",
			"BE": "Banques belges: BNP Paribas Fortis, ING, Belfius, KBC, Argenta. Taux moyens: 3.5-4.5%.",
		},
		"BANK": {
			"FR": "Banques franÃ§aises: Boursorama, Fortuneo, Hello bank, N26, Revolut, BNP Paribas.",
			"BE": "Banques belges: BNP Paribas Fortis, ING, Belfius, KBC, Argenta.",
		},
	}

	context := categoryContexts[category][country]
	if context == "" {
		context = "Fournisseurs locaux pour " + category
	}

	currentProvider := merchantName
	if currentProvider == "" {
		currentProvider = "fournisseur actuel"
	}

	prompt := fmt.Sprintf(`Tu es un expert en comparaison de services et produits en %s. Un utilisateur paie actuellement %.2fâ‚¬/mois Ã  %s pour la catÃ©gorie %s.

CONTEXTE: %s

Ta mission: Trouver 3-5 alternatives RÃ‰ELLES et ACTUELLES qui pourraient lui faire Ã©conomiser de l'argent.

RÃˆGLES IMPORTANTES:
1. UNIQUEMENT des fournisseurs/services RÃ‰ELS qui existent en %s
2. Prix RÃ‰ALISTES basÃ©s sur les offres actuelles de fin 2024 / dÃ©but 2025
3. Prioriser les meilleures Ã©conomies potentielles
4. Indiquer les avantages ET inconvÃ©nients honnÃªtement
5. Si le prix actuel est dÃ©jÃ  excellent, le mentionner

RÃ©ponds UNIQUEMENT en JSON valide (pas de markdown, pas de backticks), selon ce format EXACT:

{
  "competitors": [
    {
      "name": "Nom du concurrent",
      "typical_price": 39.99,
      "best_offer": "Description courte de la meilleure offre actuelle",
      "potential_savings": 120.00,
      "pros": ["Avantage 1", "Avantage 2"],
      "cons": ["InconvÃ©nient 1", "InconvÃ©nient 2"],
      "affiliate_link": "",
      "contact_available": true
    }
  ]
}

EXEMPLE pour INTERNET Ã  50â‚¬/mois:
{
  "competitors": [
    {
      "name": "Free",
      "typical_price": 29.99,
      "best_offer": "Freebox Pop - Fibre 5 Gb/s Ã  29.99â‚¬/mois la premiÃ¨re annÃ©e",
      "potential_savings": 240.00,
      "pros": ["Prix attractif premiÃ¨re annÃ©e", "DÃ©bit Ã©levÃ©", "Sans engagement"],
      "cons": ["Service client perfectible", "Prix augmente aprÃ¨s 1 an"],
      "affiliate_link": "",
      "contact_available": false
    },
    {
      "name": "RED by SFR",
      "typical_price": 25.00,
      "best_offer": "RED Box Fibre Ã  25â‚¬/mois sans engagement",
      "potential_savings": 300.00,
      "pros": ["Prix fixe Ã  vie", "Sans engagement", "Appels illimitÃ©s"],
      "cons": ["DÃ©bit limitÃ© Ã  1 Gb/s", "Pas de TV incluse"],
      "affiliate_link": "",
      "contact_available": false
    }
  ]
}

Analyse maintenant et rÃ©ponds en JSON pur (sans markdown):`,
		country, currentAmount, currentProvider, category, context, country)

	return prompt
}

// ============================================================================
// â­ JSON PARSING - AMÃ‰LIORÃ‰ POUR GÃ‰RER LES BACKTICKS MARKDOWN
// ============================================================================

type CompetitorSearchResponse struct {
	Competitors []models.Competitor `json:"competitors"`
}

func parseCompetitorsFromResponse(content string) ([]models.Competitor, error) {
	// â­ NOUVEAU: Nettoyer les backticks Markdown et espaces
	content = strings.TrimSpace(content)
	
	// Enlever les blocs markdown ```json et ```
	content = strings.TrimPrefix(content, "```json")
	content = strings.TrimPrefix(content, "```")
	content = strings.TrimSuffix(content, "```")
	content = strings.TrimSpace(content)
	
	// Enlever d'Ã©ventuels backticks simples au dÃ©but/fin
	content = strings.Trim(content, "`")
	content = strings.TrimSpace(content)
	
	// Log pour debug
	if len(content) > 200 {
		log.Printf("[Parser] Cleaned JSON (first 200 chars): %s...", content[:200])
	} else {
		log.Printf("[Parser] Cleaned JSON: %s", content)
	}

	// Parser le JSON
	var response CompetitorSearchResponse
	if err := json.Unmarshal([]byte(content), &response); err != nil {
		// Log l'erreur avec plus de contexte
		log.Printf("[Parser] âŒ JSON parse error: %v", err)
		log.Printf("[Parser] Problematic content: %s", content)
		return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
	}

	if len(response.Competitors) == 0 {
		return nil, fmt.Errorf("no competitors found in response")
	}

	log.Printf("[Parser] âœ… Successfully parsed %d competitors", len(response.Competitors))

	// Calculer les Ã©conomies si pas fournies
	for i := range response.Competitors {
		if response.Competitors[i].PotentialSavings == 0 {
			// Calculer sur 12 mois
			response.Competitors[i].PotentialSavings = 0 // Sera calculÃ© par le frontend
		}
	}

	return response.Competitors, nil
}

// ============================================================================
// CACHE MANAGEMENT
// ============================================================================

func (s *MarketAnalyzerService) getCachedSuggestion(
	ctx context.Context,
	category string,
	country string,
	merchantName string,
) (*models.MarketSuggestion, error) {

	log.Printf("[MarketAnalyzer] ðŸ” Cache lookup: category=%s, country=%s, merchant=%s", category, country, merchantName)

	var query string
	var args []interface{}

	// Ensure we pass time.Now() to match App time vs DB time
	if merchantName == "" {
		query = `
			SELECT id, category, country, merchant_name, competitors, last_updated, expires_at
			FROM market_suggestions
			WHERE category = $1 
			  AND country = $2 
			  AND merchant_name IS NULL
			  AND expires_at > $3
			ORDER BY last_updated DESC
			LIMIT 1
		`
		args = []interface{}{category, country, time.Now()}
	} else {
		query = `
			SELECT id, category, country, merchant_name, competitors, last_updated, expires_at
			FROM market_suggestions
			WHERE category = $1 
			  AND country = $2 
			  AND merchant_name = $3
			  AND expires_at > $4
			ORDER BY last_updated DESC
			LIMIT 1
		`
		args = []interface{}{category, country, merchantName, time.Now()}
	}

	var suggestion models.MarketSuggestion
	var competitorsJSON []byte
    // FIX: Use NullString to handle potential NULLs from the DB
	var dbMerchantName sql.NullString 

    // FIX: Scan into dbMerchantName instead of &suggestion.MerchantName directly
	err := s.DB.QueryRowContext(ctx, query, args...).Scan(
		&suggestion.ID,
		&suggestion.Category,
		&suggestion.Country,
		&dbMerchantName, // <--- Change this line
		&competitorsJSON,
		&suggestion.LastUpdated,
		&suggestion.ExpiresAt,
	)

	if err == sql.ErrNoRows {
		// Log removed to reduce noise
		return nil, fmt.Errorf("not found in cache")
	}
	if err != nil {
        // This log will help verify if any other errors persist
		log.Printf("[MarketAnalyzer] âŒ Scan Error: %v", err)
		return nil, fmt.Errorf("cache query failed: %w", err)
	}

    // FIX: Convert NullString back to normal string
	if dbMerchantName.Valid {
		suggestion.MerchantName = dbMerchantName.String
	} else {
		suggestion.MerchantName = ""
	}

	if err := json.Unmarshal(competitorsJSON, &suggestion.Competitors); err != nil {
		return nil, fmt.Errorf("failed to unmarshal competitors: %w", err)
	}

	return &suggestion, nil
}

func (s *MarketAnalyzerService) saveSuggestionToCache(
	ctx context.Context,
	suggestion *models.MarketSuggestion,
) error {

	// SÃ©rialiser les competitors en JSON
	competitorsJSON, err := json.Marshal(suggestion.Competitors)
	if err != nil {
		return fmt.Errorf("failed to marshal competitors: %w", err)
	}

	merchantName := sql.NullString{}
	if suggestion.MerchantName != "" {
		merchantName.String = suggestion.MerchantName
		merchantName.Valid = true
	}

	// â­ Ã‰TAPE 1: Essayer d'insÃ©rer
	insertQuery := `
		INSERT INTO market_suggestions (category, country, merchant_name, competitors, last_updated, expires_at)
		VALUES ($1, $2, $3, $4, $5, $6)
		ON CONFLICT DO NOTHING
		RETURNING id
	`

	var insertedID string
	err = s.DB.QueryRowContext(ctx, insertQuery,
		suggestion.Category,
		suggestion.Country,
		merchantName,
		competitorsJSON,
		suggestion.LastUpdated,
		suggestion.ExpiresAt,
	).Scan(&insertedID)

	if err == sql.ErrNoRows {
		// Conflit - la ligne existe dÃ©jÃ , on update (opÃ©ration normale)
		log.Printf("[MarketAnalyzer] âœ… Refreshing existing cache entry")
		
		var updateQuery string
		var updateArgs []interface{}
		
		if suggestion.MerchantName == "" {
			// Update pour suggestion gÃ©nÃ©rique (merchant_name IS NULL)
			updateQuery = `
				UPDATE market_suggestions 
				SET competitors = $1, last_updated = $2, expires_at = $3
				WHERE category = $4 AND country = $5 AND merchant_name IS NULL
			`
			updateArgs = []interface{}{
				competitorsJSON,
				suggestion.LastUpdated,
				suggestion.ExpiresAt,
				suggestion.Category,
				suggestion.Country,
			}
		} else {
			// Update pour suggestion merchant spÃ©cifique
			updateQuery = `
				UPDATE market_suggestions 
				SET competitors = $1, last_updated = $2, expires_at = $3
				WHERE category = $4 AND country = $5 AND merchant_name = $6
			`
			updateArgs = []interface{}{
				competitorsJSON,
				suggestion.LastUpdated,
				suggestion.ExpiresAt,
				suggestion.Category,
				suggestion.Country,
				suggestion.MerchantName,
			}
		}
		
		result, err := s.DB.ExecContext(ctx, updateQuery, updateArgs...)
		if err != nil {
			return fmt.Errorf("failed to update suggestion: %w", err)
		}
		
		rowsAffected, _ := result.RowsAffected()
		log.Printf("[MarketAnalyzer] âœ… Updated cache: %s/%s (%d rows affected)", suggestion.Category, suggestion.Country, rowsAffected)
	} else if err != nil {
		return fmt.Errorf("failed to save suggestion: %w", err)
	} else {
		log.Printf("[MarketAnalyzer] âœ… Saved to cache: %s/%s (ID: %s)", suggestion.Category, suggestion.Country, insertedID)
	}

	// â­ Ã‰TAPE 2: VÃ©rifier immÃ©diatement que c'est bien sauvegardÃ©
	verifyQuery := `
		SELECT COUNT(*), MIN(expires_at), MAX(expires_at), NOW() 
		FROM market_suggestions 
		WHERE category = $1 AND country = $2
	`
	var count int
	var minExpires, maxExpires, now time.Time
	err = s.DB.QueryRowContext(ctx, verifyQuery, suggestion.Category, suggestion.Country).Scan(&count, &minExpires, &maxExpires, &now)
	if err == nil {
		log.Printf("[MarketAnalyzer] ðŸ” Verification: %d entries - App time: %s, DB time: %s, expires: %s (valid: %v)", 
			count, 
			time.Now().Format("2006-01-02 15:04:05"), 
			now.Format("2006-01-02 15:04:05"),
			maxExpires.Format("2006-01-02 15:04:05"),
			maxExpires.After(time.Now()))
	}

	return nil
}

func (s *MarketAnalyzerService) CleanExpiredCache(ctx context.Context) error {
	query := `DELETE FROM market_suggestions WHERE expires_at < NOW()`

	result, err := s.DB.ExecContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to clean cache: %w", err)
	}

	rows, _ := result.RowsAffected()
	log.Printf("[MarketAnalyzer] ðŸ§¹ Cleaned %d expired cache entries", rows)

	return nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\suggestions.go
=========================================
package services

import (
	"budget-api/models"
	"fmt"
	"strings"
)

type SuggestionService struct{}

func NewSuggestionService() *SuggestionService {
	return &SuggestionService{}
}

// Logic pour dÃ©terminer si une dÃ©pense mÃ©rite une affiliation
func (s *SuggestionService) AnalyzeCharges(charges []models.Charge) []models.Suggestion {
	var suggestions []models.Suggestion

	// 1. Groupement pour les dÃ©penses "Foyer" (ex: Energie, Internet)
	// On veut savoir si le foyer paie trop cher au total, mÃªme si c'est divisÃ© en deux prÃ©lÃ¨vements
	householdCategories := map[string]float64{
		"ENERGY":   0,
		"INTERNET": 0,
		"INSURANCE": 0, // Souvent habitation = foyer
	}

	// 2. Analyse Individuelle (ex: Mobile, Sport)
	// On analyse chaque ligne sÃ©parÃ©ment
	for _, c := range charges {
		category := strings.ToUpper(c.Category)
		
		// Si c'est une catÃ©gorie foyer, on cumule d'abord
		if _, isHousehold := householdCategories[category]; isHousehold {
			householdCategories[category] += c.Amount
		} else {
			// Analyse immÃ©diate pour les charges individuelles
			if sugg := s.evaluateIndividualCharge(c); sugg != nil {
				suggestions = append(suggestions, *sugg)
			}
		}
	}

	// 3. Analyse des totaux Foyer
	for cat, totalAmount := range householdCategories {
		if sugg := s.evaluateHouseholdTotal(cat, totalAmount); sugg != nil {
			suggestions = append(suggestions, *sugg)
		}
	}

	return suggestions
}

func (s *SuggestionService) evaluateIndividualCharge(c models.Charge) *models.Suggestion {
	// MOBILE : Si > 25â‚¬, c'est cher aujourd'hui
	if c.Category == "MOBILE" && c.Amount > 25 {
		return &models.Suggestion{
			ID:               "sug_" + c.ID,
			ChargeID:         c.ID,
			Type:             "MOBILE_SWITCH",
			Title:            "Forfait Mobile Optimisable",
			Message:          fmt.Sprintf("Vous payez %.0fâ‚¬/mois. Des forfaits 50Go existent dÃ¨s 10â‚¬.", c.Amount),
			PotentialSavings: (c.Amount - 10) * 12,
			ActionLink:       "https://www.ariase.com/mobile", // Ã€ remplacer par lien trackÃ©
			CanBeContacted:   false,
		}
	}
	// LOAN : Si > 500â‚¬, vÃ©rifier l'assurance emprunteur
	if c.Category == "LOAN" && c.Amount > 500 {
		return &models.Suggestion{
			ID:               "sug_" + c.ID,
			ChargeID:         c.ID,
			Type:             "LOAN_INSURANCE",
			Title:            "Assurance Emprunteur",
			Message:          "Sur un gros crÃ©dit, changer d'assurance peut rapporter gros.",
			PotentialSavings: 1500, // Estimation
			ActionLink:       "https://www.meilleurtaux.com/",
			CanBeContacted:   true,
		}
	}
	return nil
}

func (s *SuggestionService) evaluateHouseholdTotal(category string, amount float64) *models.Suggestion {
	// ENERGY : Si foyer > 120â‚¬ / mois
	if category == "ENERGY" && amount > 120 {
		return &models.Suggestion{
			ID:               "sug_household_energy",
			Type:             "ENERGY_SWITCH",
			Title:            "Facture Ã‰nergie Ã‰levÃ©e",
			Message:          fmt.Sprintf("Le foyer paie %.0fâ‚¬/mois. Comparez les fournisseurs.", amount),
			PotentialSavings: (amount * 0.15) * 12, // ~15% d'Ã©conomie
			ActionLink:       "https://www.papernest.com/energie/",
			CanBeContacted:   true,
		}
	}
	// INTERNET : Si > 45â‚¬ / mois
	if category == "INTERNET" && amount > 45 {
		return &models.Suggestion{
			ID:               "sug_household_net",
			Type:             "BOX_SWITCH",
			Title:            "Box Internet",
			Message:          "Plus de 45â‚¬/mois ? La fibre commence Ã  20â‚¬ la premiÃ¨re annÃ©e.",
			PotentialSavings: (amount - 25) * 12,
			ActionLink:       "https://www.ariase.com/box",
			CanBeContacted:   false,
		}
	}
	return nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\.env
=========================================
# Database Configuration
DATABASE_URL=postgresql://budget_db_uz3l_user:DfWCVdVQulVBIe0L6XvDcpyadrNyRQIl@dpg-d4n1379r0fns73ajeob0-a/budget_db_uz3l

# JWT Configuration
JWT_SECRET=change-this-to-a-random-secret-key-in-production
JWT_EXPIRY=15m
REFRESH_EXPIRY=168h

# Frontend URL (for CORS and email links)
FRONTEND_URL=http://localhost:3000

# Email Configuration (Resend)
RESEND_API_KEY=re_JU9a2NB3_7T4Fkwz5YuJGw1trYHfkNW3j
FROM_EMAIL=Budget Famille <noreply@budgetfamille.com>

# Server Configuration
PORT=8080
ENVIRONMENT=development
DATA_ENCRYPTION_KEY=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\crypto.go
=========================================
package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"io"
	"os"
)

// Encrypt encrypts a plain string/bytes and returns a base64 encoded ciphertext
func Encrypt(plaintext []byte) (string, error) {
	key := os.Getenv("DATA_ENCRYPTION_KEY")
	if len(key) != 32 {
		return "", errors.New("DATA_ENCRYPTION_KEY must be exactly 32 characters")
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return "", err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return "", err
	}

	ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Decrypt takes a base64 encoded ciphertext and returns the original bytes
func Decrypt(cryptoText string) ([]byte, error) {
	key := os.Getenv("DATA_ENCRYPTION_KEY")
	if len(key) != 32 {
		return nil, errors.New("DATA_ENCRYPTION_KEY must be exactly 32 characters")
	}

	ciphertext, err := base64.StdEncoding.DecodeString(cryptoText)
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, err
	}

	return plaintext, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\email.go
=========================================
package utils

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
)

type EmailRequest struct {
	From    string   `json:"from"`
	To      []string `json:"to"`
	Subject string   `json:"subject"`
	HTML    string   `json:"html"`
}

// SendInvitationEmail envoie l'email d'invitation
func SendInvitationEmail(toEmail, inviterName, budgetName, invitationToken string) error {
	frontendURL := os.Getenv("FRONTEND_URL")
	if frontendURL == "" {
		frontendURL = "http://localhost:3000"
	}

	invitationLink := fmt.Sprintf("%s/invitation/accept?token=%s", frontendURL, invitationToken)

	htmlBody := fmt.Sprintf(`
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: sans-serif; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .button { display: inline-block; background: #667eea; color: white; padding: 15px 30px; text-decoration: none; border-radius: 8px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Invitation Budget</h1>
        <p><strong>%s</strong> vous invite sur <strong>"%s"</strong>.</p>
        <a href="%s" class="button">Accepter l'invitation</a>
    </div>
</body>
</html>
	`, inviterName, budgetName, invitationLink)

	return sendEmail(toEmail, fmt.Sprintf("%s vous invite Ã  collaborer", inviterName), htmlBody)
}

// SendVerificationEmail envoie l'email de vÃ©rification
func SendVerificationEmail(toEmail, userName, token string) error {
	frontendURL := os.Getenv("FRONTEND_URL")
	if frontendURL == "" {
		frontendURL = "http://localhost:3000"
	}

	verifyLink := fmt.Sprintf("%s/verify-email?token=%s", frontendURL, token)

	htmlBody := fmt.Sprintf(`
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: sans-serif; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .button { display: inline-block; background: #10b981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h2>Bienvenue %s !</h2>
        <p>Veuillez vÃ©rifier votre email pour activer votre compte.</p>
        <a href="%s" class="button">VÃ©rifier mon email</a>
    </div>
</body>
</html>
	`, userName, verifyLink)

	return sendEmail(toEmail, "VÃ©rifiez votre compte", htmlBody)
}

// sendEmail (fonction privÃ©e)
func sendEmail(to, subject, htmlBody string) error {
	apiKey := os.Getenv("RESEND_API_KEY")
	if apiKey == "" {
		return fmt.Errorf("RESEND_API_KEY not set")
	}

	fromEmail := os.Getenv("FROM_EMAIL")
	if fromEmail == "" {
		fromEmail = "Budget Famille <noreply@budgetfamille.com>"
	}

	emailReq := EmailRequest{
		From:    fromEmail,
		To:      []string{to},
		Subject: subject,
		HTML:    htmlBody,
	}

	jsonData, err := json.Marshal(emailReq)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", "https://api.resend.com/emails", bytes.NewBuffer(jsonData))
	if err != nil {
		return err
	}

	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("email API status: %d", resp.StatusCode)
	}

	return nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\jwt.go
=========================================
package utils

import (
	"fmt"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

type Claims struct {
	UserID string `json:"user_id"`
	Email  string `json:"email"`
	jwt.RegisteredClaims
}

func GenerateAccessToken(userID, email string) (string, error) {
	secret := os.Getenv("JWT_SECRET")
	if secret == "" {
		return "", fmt.Errorf("JWT_SECRET not set")
	}

	expiryStr := os.Getenv("JWT_EXPIRY")
	if expiryStr == "" {
		expiryStr = "15m"
	}

	expiry, err := time.ParseDuration(expiryStr)
	if err != nil {
		expiry = 15 * time.Minute
	}

	claims := Claims{
		UserID: userID,
		Email:  email,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiry)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
			Issuer:    "budget-api",
			Subject:   userID,
			ID:        uuid.New().String(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(secret))
}

func GenerateRefreshToken() (string, error) {
	return uuid.New().String(), nil
}

func ValidateToken(tokenString string) (*Claims, error) {
	secret := os.Getenv("JWT_SECRET")
	if secret == "" {
		return nil, fmt.Errorf("JWT_SECRET not set")
	}

	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(secret), nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(*Claims); ok && token.Valid {
		return claims, nil
	}

	return nil, fmt.Errorf("invalid token")
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\password.go
=========================================
package utils

import (
	"golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(bytes), err
}

func CheckPassword(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\totp.go
=========================================
package utils

import (
	"github.com/pquerna/otp/totp"
)

func GenerateTOTPSecret(email string) (string, string, error) {
	key, err := totp.Generate(totp.GenerateOpts{
		Issuer:      "Budget Famille",
		AccountName: email,
	})
	if err != nil {
		return "", "", err
	}

	return key.Secret(), key.URL(), nil
}

func VerifyTOTP(secret, code string) (bool, error) {
	valid := totp.Validate(code, secret)
	return valid, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\transaction.go
=========================================
package utils

import (
	"database/sql"
	"fmt"
)

// WithTransaction executes a function within a database transaction
func WithTransaction(db *sql.DB, fn func(*sql.Tx) error) error {
	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	defer func() {
		if p := recover(); p != nil {
			tx.Rollback()
			panic(p) // Re-throw panic after rollback
		}
	}()

	if err := fn(tx); err != nil {
		tx.Rollback()
		return err
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}



