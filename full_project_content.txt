=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\.env.example
=========================================
# Database Configuration
DATABASE_URL=postgresql://budget_db_uz3l_user:DfWCVdVQulVBIe0L6XvDcpyadrNyRQIl@dpg-d4n1379r0fns73ajeob0-a/budget_db_uz3l

# JWT Configuration
JWT_SECRET=test
JWT_EXPIRY=15m
REFRESH_EXPIRY=168h

# Frontend URL (for CORS and email links)
FRONTEND_URL=http://localhost:3000

# Email Configuration (Resend)
RESEND_API_KEY=re_test
FROM_EMAIL=Budget Famille <noreply@budgetfamille.com>

# Server Configuration
PORT=8080
ENVIRONMENT=development

BRIDGE_CLIENT_ID=your_client_id_here
BRIDGE_CLIENT_SECRET=your_client_secret_here
BRIDGE_ENV=sandbox  

ANTHROPIC_API_KEY=key
ADMIN_SECRET=test

ENABLE_BANKING_APP_ID=xxxxf836-6cd4-0000-b398-77fxxxxef930
ENABLE_BANKING_PRIVATE_KEY_PATH=./private-key.pem
ENABLE_BANKING_PRIVATE_KEY_BASE64=test




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\.gitignore
=========================================
# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
main
budget-api

# Test binary
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# Environment files
.env
.env.local
.env.*.local

# IDE files
.idea/
.vscode/
*.swp
*.swo
*~

# OS files
.DS_Store
Thumbs.db

# Logs
*.log

# Temporary files
tmp/
temp/



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\DEPLOYMENT.md
=========================================




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\Dockerfile
=========================================
# Build stage
FROM golang:1.21-alpine AS builder

# Install build dependencies
RUN apk add --no-cache git

# Set working directory
WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Final stage
FROM alpine:latest

# Install ca-certificates for HTTPS
RUN apk --no-cache add ca-certificates

WORKDIR /root/

# Copy the binary from builder
COPY --from=builder /app/main .

# Expose port
EXPOSE 8080

# Run the application
CMD ["./main"]



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\go.mod
=========================================
module budget-api

go 1.21

require (
	github.com/gin-contrib/cors v1.5.0
	github.com/gin-gonic/gin v1.9.1
	github.com/golang-jwt/jwt/v5 v5.2.0
	github.com/google/uuid v1.5.0
	github.com/joho/godotenv v1.5.1
	github.com/lib/pq v1.10.9
	github.com/pquerna/otp v1.4.0
	golang.org/x/crypto v0.17.0
	github.com/olahol/melody v1.1.4
	github.com/kr/text v0.2.0
)



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\main.go
=========================================
package main

import (
	"log"
	"os"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	
	"budget-api/config"
	"budget-api/middleware"
	"budget-api/handlers" // Assurez-vous que handlers inclut le nouveau ws.go
	"budget-api/routes"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found")
	}

	// Initialize database connection
	db, err := config.InitDB()
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}
	defer db.Close()

	// Run migrations
	if err := config.RunMigrations(db); err != nil {
		log.Fatal("Failed to run migrations:", err)
	}

	// Initialize WebSocket Handler
	wsHandler := handlers.NewWSHandler()

	// Initialize Gin router
	router := gin.Default()

	// CORS configuration
	frontendURL := os.Getenv("FRONTEND_URL")
	if frontendURL == "" {
		frontendURL = "http://localhost:3000" // Fallback pour dev local
	}

	allowedOrigins := []string{
		frontendURL,
		"https://budgetfamille.com",
		"https://www.budgetfamille.com",
		"https://budget-ui-two.vercel.app",
	}

	log.Printf("ðŸŒ CORS: Allowing origins:")
	for _, origin := range allowedOrigins {
		log.Printf("   - %s", origin)
	}

	corsConfig := cors.Config{
		AllowOrigins:     allowedOrigins,
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           86400, 
	}
	router.Use(cors.New(corsConfig))

	// Add logging middleware
	router.Use(func(c *gin.Context) {
		log.Printf("ðŸ“¨ %s %s from %s", c.Request.Method, c.Request.URL.Path, c.ClientIP())
		c.Next()
	})

	// Rate limiting middleware
	router.Use(middleware.RateLimiter())

	// API v1 routes
	v1 := router.Group("/api/v1")
	{
		// Public routes
		routes.SetupAuthRoutes(v1, db)
		
		// WebSocket Route (Protected check handled inside handler or via query token)
		v1.GET("/ws/budgets/:id", wsHandler.HandleWS)

		//routes.SetupAdminRoutes(v1, db)

		// Protected routes
		protected := v1.Group("/")
		protected.Use(middleware.AuthMiddleware())
		{
			// Note: Vous devrez mettre Ã  jour SetupBudgetRoutes pour passer wsHandler si vous voulez broadcaster des events
			routes.SetupBudgetRoutes(protected, db) 
			routes.SetupUserRoutes(protected, db)
			routes.SetupInvitationRoutes(protected, db)
			routes.SetupBankingRoutes(protected, db)
			routes.SetupEnableBankingRoutes(protected, db)
		}
	}

	// Health check endpoint
	router.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"status": "ok",
			"service": "budget-api",
			"frontend_url": frontendURL,
		})
	})

	// Start server
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("ðŸš€ Server starting on port %s", port)
	if err := router.Run(":" + port); err != nil {
		log.Fatal("Failed to start server:", err)
	}
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\Makefile
=========================================
.PHONY: help build run test clean docker-up docker-down

APP_NAME=budget-api
POSTGRES_CONTAINER=budget-postgres

help:
	@echo "Available commands:"
	@echo "  make setup       - Setup complete (Docker + deps)"
	@echo "  make run         - Run the API"
	@echo "  make test-api    - Test the API"
	@echo "  make docker-up   - Start PostgreSQL"
	@echo "  make docker-down - Stop PostgreSQL"

install:
	go mod download
	go mod tidy

build:
	go build -o $(APP_NAME) main.go

run:
	go run main.go

test-api:
	chmod +x test.sh
	./test.sh

docker-up:
	docker run --name $(POSTGRES_CONTAINER) \
		-e POSTGRES_PASSWORD=mysecret \
		-e POSTGRES_DB=budget_db \
		-p 5432:5432 \
		-d postgres:15 || docker start $(POSTGRES_CONTAINER)

docker-down:
	docker stop $(POSTGRES_CONTAINER) || true
	docker rm $(POSTGRES_CONTAINER) || true

setup: docker-up install
	@echo "âœ… Setup complete!"
	@echo "Create .env: cp .env.example .env"
	@echo "Then: make run"

clean:
	rm -f $(APP_NAME)



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\private-key.pem
=========================================




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\QUICKSTART.md
=========================================




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\README.md
=========================================
# Budget API - Backend Go

API REST pour Budget Famille avec JWT, 2FA, multi-utilisateurs.

## Quick Start

### 1. Setup

\`\`\`bash
# Start PostgreSQL
make docker-up

# Configure
cp .env.example .env
# Edit .env with your values

# Run
make run
\`\`\`

### 2. Test

\`\`\`bash
# Health check
curl http://localhost:8080/health

# Run all tests
make test-api
\`\`\`

## API Endpoints

### Auth
- `POST /api/v1/auth/signup` - Create account
- `POST /api/v1/auth/login` - Login

### Budgets
- `POST /api/v1/budgets` - Create budget
- `GET /api/v1/budgets` - List budgets
- `GET /api/v1/budgets/:id` - Get budget
- `PUT /api/v1/budgets/:id/data` - Update data
- `DELETE /api/v1/budgets/:id` - Delete budget

### Invitations
- `POST /api/v1/budgets/:id/invite` - Invite user
- `POST /api/v1/invitations/accept` - Accept invitation

### User
- `GET /api/v1/user/profile` - Get profile
- `PUT /api/v1/user/profile` - Update profile
- `POST /api/v1/user/2fa/setup` - Setup 2FA
- `POST /api/v1/user/2fa/verify` - Enable 2FA

## Environment Variables

\`\`\`bash
DATABASE_URL=postgres://user:pass@localhost:5432/budget_db
JWT_SECRET=your-secret-key
FRONTEND_URL=http://localhost:3000
RESEND_API_KEY=re_your_key
PORT=8080
\`\`\`

## Deploy on Render.com (Free)

1. Create PostgreSQL on Render
2. Create Web Service
3. Add environment variables
4. Deploy!

See DEPLOYMENT.md for details.

## Stack

- Go 1.21+
- Gin (web framework)
- PostgreSQL 15+
- JWT authentication
- TOTP 2FA
- Resend (emails)
\`\`\`

---

## File 24: QUICKSTART.md
`````markdown
# Quick Start - 5 Minutes

## 1. Start Database

\`\`\`bash
make docker-up
\`\`\`

## 2. Configure

\`\`\`bash
cp .env.example .env

# Edit .env:
DATABASE_URL=postgres://postgres:mysecret@localhost:5432/budget_db?sslmode=disable
JWT_SECRET=$(openssl rand -base64 32)
FRONTEND_URL=http://localhost:3000
\`\`\`

## 3. Run

\`\`\`bash
go mod download
go run main.go
\`\`\`

## 4. Test

\`\`\`bash
# Health check
curl http://localhost:8080/health

# Create user
curl -X POST http://localhost:8080/api/v1/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"Test1234","name":"Test"}'

# Run test suite
make test-api
\`\`\`

âœ… Done!
\`\`\`

---

## File 25: DEPLOYMENT.md
````markdown
# Deployment on Render.com

## Step 1: Create PostgreSQL

1. Go to render.com
2. New â†’ PostgreSQL
3. Name: budget-db
4. Region: Frankfurt
5. Plan: Free
6. Copy Internal Database URL

## Step 2: Create Web Service

1. New â†’ Web Service
2. Connect GitHub repo
3. Settings:
   - Name: budget-api
   - Runtime: Go
   - Build: `go build -o main`
   - Start: `./main`
   - Plan: Free

## Step 3: Environment Variables

Add in Render dashboard:

\`\`\`
DATABASE_URL=<Internal URL from Step 1>
JWT_SECRET=<random secret>
FRONTEND_URL=https://your-frontend.vercel.app
RESEND_API_KEY=<resend key>
PORT=8080
\`\`\`

## Step 4: Deploy

Push to GitHub â†’ Render auto-deploys!

\`\`\`bash
git push origin main
\`\`\`

## Test Production

\`\`\`bash
curl https://budget-api.onrender.com/health
\`\`\`

âœ… Done! API is live at: https://budget-api.onrender.com
\`\`\`

---


---

# ðŸš€ How to Use

## Option 1: Use setup.sh script
```bash
# 1. Run setup script
bash setup.sh

# 2. Copy-paste each file content from above into the corresponding file

# 3. Setup and run
make setup
make run
```

## Option 2: Manual creation
```bash
# 1. Create directory structure
mkdir -p config models handlers middleware routes utils

# 2. Copy each file content from this document

# 3. Paste into corresponding files:
# - main.go â†’ root
# - go.mod â†’ root
# - .env.example â†’ root
# - etc.

# 4. Run
make setup
make run
```

## File Checklist

- [x] 1. main.go
- [x] 2. go.mod
- [x] 3. .env.example
- [x] 4. .gitignore
- [x] 5. Dockerfile
- [x] 6. Makefile
- [x] 7. config/database.go
- [x] 8. models/user.go
- [x] 9. models/budget.go
- [x] 10. models/invitation.go
- [x] 11. utils/jwt.go
- [x] 12. utils/password.go
- [x] 13. utils/totp.go
- [x] 14. utils/email.go
- [x] 15. middleware/auth.go
- [x] 16. middleware/ratelimit.go
- [x] 17. routes/routes.go
- [x] 18. handlers/auth.go
- [x] 19. handlers/budget.go
- [x] 20. handlers/user.go
- [x] 21. handlers/invitation.go
- [x] 22. test.sh
- [x] 23. README.md
- [x] 24. QUICKSTART.md
- [x] 25. DEPLOYMENT.md

**Total: 25 files**

---

# âœ… Next Steps

1. Create all files
2. `cp .env.example .env`
3. Edit `.env` with your values
4. `make setup`
5. `make run`
6. `make test-api`

Done! ðŸŽ‰



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\test.sh
=========================================
#!/bin/bash

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

API_URL="${API_URL:-http://localhost:8080}"
TEST_EMAIL="test_$(date +%s)@example.com"
TEST_PASSWORD="TestPass123!"
TEST_NAME="Test User"

echo -e "${YELLOW}ðŸ§ª Budget API - Test Suite${NC}"
echo "API URL: $API_URL"
echo "=========================================="

echo -e "\n${YELLOW}1. Health Check${NC}"
curl -s "$API_URL/health" | grep -q "ok" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"

echo -e "\n${YELLOW}2. User Signup${NC}"
SIGNUP_RESPONSE=$(curl -s -X POST "$API_URL/api/v1/auth/signup" \
    -H "Content-Type: application/json" \
    -d "{\"email\":\"$TEST_EMAIL\",\"password\":\"$TEST_PASSWORD\",\"name\":\"$TEST_NAME\"}")

if echo "$SIGNUP_RESPONSE" | grep -q "access_token"; then
    echo -e "${GREEN}âœ“ Signup successful${NC}"
    ACCESS_TOKEN=$(echo "$SIGNUP_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
    USER_ID=$(echo "$SIGNUP_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
    echo "Token: ${ACCESS_TOKEN:0:50}..."
else
    echo -e "${RED}âœ— Signup failed${NC}"
    echo "$SIGNUP_RESPONSE"
    exit 1
fi

echo -e "\n${YELLOW}3. User Login${NC}"
LOGIN_RESPONSE=$(curl -s -X POST "$API_URL/api/v1/auth/login" \
    -H "Content-Type: application/json" \
    -d "{\"email\":\"$TEST_EMAIL\",\"password\":\"$TEST_PASSWORD\"}")
echo "$LOGIN_RESPONSE" | grep -q "access_token" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"

echo -e "\n${YELLOW}4. Get User Profile${NC}"
PROFILE_RESPONSE=$(curl -s -X GET "$API_URL/api/v1/user/profile" \
    -H "Authorization: Bearer $ACCESS_TOKEN")
echo "$PROFILE_RESPONSE" | grep -q "$TEST_EMAIL" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"

echo -e "\n${YELLOW}5. Create Budget${NC}"
BUDGET_RESPONSE=$(curl -s -X POST "$API_URL/api/v1/budgets" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -d '{"name":"Test Budget"}')

if echo "$BUDGET_RESPONSE" | grep -q "id"; then
    echo -e "${GREEN}âœ“ Budget creation successful${NC}"
    BUDGET_ID=$(echo "$BUDGET_RESPONSE" | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
    echo "Budget ID: $BUDGET_ID"
else
    echo -e "${RED}âœ— Budget creation failed${NC}"
fi

echo -e "\n${YELLOW}6. Get All Budgets${NC}"
BUDGETS_RESPONSE=$(curl -s -X GET "$API_URL/api/v1/budgets" \
    -H "Authorization: Bearer $ACCESS_TOKEN")
echo "$BUDGETS_RESPONSE" | grep -q "Test Budget" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"

if [ ! -z "$BUDGET_ID" ]; then
    echo -e "\n${YELLOW}7. Update Budget Data${NC}"
    BUDGET_DATA='{"data": {"budgetTitle": "Test Budget Updated","people": [],"charges": [],"projects": [],"yearlyData": {}}}'
    UPDATE_RESPONSE=$(curl -s -X PUT "$API_URL/api/v1/budgets/$BUDGET_ID/data" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $ACCESS_TOKEN" \
        -d "$BUDGET_DATA")
    echo "$UPDATE_RESPONSE" | grep -q "version" && echo -e "${GREEN}âœ“ PASSED${NC}" || echo -e "${RED}âœ— FAILED${NC}"
fi

echo -e "\n${GREEN}ðŸŽ‰ All tests completed!${NC}"
echo ""
echo "Test User: $TEST_EMAIL"
echo "Password: $TEST_PASSWORD"
if [ ! -z "$BUDGET_ID" ]; then
    echo "Budget ID: $BUDGET_ID"
fi



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\config\database.go
=========================================
package config

import (
	"database/sql"
	"fmt"
	"os"

	_ "github.com/lib/pq"
)

func InitDB() (*sql.DB, error) {
	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		return nil, fmt.Errorf("DATABASE_URL environment variable is required")
	}

	db, err := sql.Open("postgres", dbURL)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5)

	return db, nil
}

func RunMigrations(db *sql.DB) error {
	migrations := []string{
		`CREATE EXTENSION IF NOT EXISTS "uuid-ossp"`,
		
		`CREATE TABLE IF NOT EXISTS users (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			email VARCHAR(255) UNIQUE NOT NULL,
			password_hash VARCHAR(255) NOT NULL,
			name VARCHAR(255) NOT NULL,
			totp_secret VARCHAR(255),
			totp_enabled BOOLEAN DEFAULT FALSE,
			email_verified BOOLEAN DEFAULT FALSE,
			avatar TEXT,
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS budgets (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			name VARCHAR(255) NOT NULL,
			owner_id UUID REFERENCES users(id) ON DELETE CASCADE,
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS budget_members (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE,
			user_id UUID REFERENCES users(id) ON DELETE CASCADE,
			role VARCHAR(50) DEFAULT 'member',
			permissions JSONB DEFAULT '{"read": true, "write": true}',
			joined_at TIMESTAMP DEFAULT NOW(),
			UNIQUE(budget_id, user_id)
		)`,
		
		`CREATE TABLE IF NOT EXISTS invitations (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE,
			email VARCHAR(255) NOT NULL,
			invited_by UUID REFERENCES users(id),
			token VARCHAR(255) UNIQUE NOT NULL,
			status VARCHAR(50) DEFAULT 'pending',
			expires_at TIMESTAMP NOT NULL,
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS budget_data (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE,
			data JSONB NOT NULL,
			version INTEGER DEFAULT 1,
			updated_by UUID REFERENCES users(id),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS audit_logs (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE,
			user_id UUID REFERENCES users(id),
			action VARCHAR(100) NOT NULL,
			changes JSONB,
			created_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE TABLE IF NOT EXISTS sessions (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID REFERENCES users(id) ON DELETE CASCADE,
			refresh_token VARCHAR(500) UNIQUE NOT NULL,
			expires_at TIMESTAMP NOT NULL,
			created_at TIMESTAMP DEFAULT NOW()
		)`,
		
		`CREATE INDEX IF NOT EXISTS idx_budget_members_budget_id ON budget_members(budget_id)`,
		`CREATE INDEX IF NOT EXISTS idx_budget_members_user_id ON budget_members(user_id)`,
		`CREATE INDEX IF NOT EXISTS idx_budget_data_budget_id ON budget_data(budget_id)`,
		`CREATE INDEX IF NOT EXISTS idx_invitations_email ON invitations(email)`,
		`CREATE INDEX IF NOT EXISTS idx_invitations_token ON invitations(token)`,
		`CREATE INDEX IF NOT EXISTS idx_audit_logs_budget_id ON audit_logs(budget_id)`,
		`CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON sessions(user_id)`,

		`ALTER TABLE invitations ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT NOW()`,
		`ALTER TABLE users ADD COLUMN IF NOT EXISTS avatar TEXT`,

		`CREATE TABLE IF NOT EXISTS email_verifications (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID REFERENCES users(id) ON DELETE CASCADE,
			token VARCHAR(255) NOT NULL,
			expires_at TIMESTAMP NOT NULL,
			created_at TIMESTAMP DEFAULT NOW()
		)`,
		`CREATE INDEX IF NOT EXISTS idx_email_verifications_token ON email_verifications(token)`,

		// --- BANKING TABLES ---
		`CREATE TABLE IF NOT EXISTS bank_connections (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
			institution_id VARCHAR(255) NOT NULL,
			institution_name VARCHAR(255),
			provider_connection_id VARCHAR(255) NOT NULL, -- NOTE: Removed UNIQUE constraint here manually in migration below
			encrypted_access_token TEXT,
			encrypted_refresh_token TEXT,
			expires_at TIMESTAMP,
			status VARCHAR(50) DEFAULT 'active',
			created_at TIMESTAMP DEFAULT NOW(),
			updated_at TIMESTAMP DEFAULT NOW()
		)`,

        // MIGRATION: Add budget_id support
        `ALTER TABLE bank_connections ADD COLUMN IF NOT EXISTS budget_id UUID REFERENCES budgets(id) ON DELETE CASCADE`,

        // MIGRATION: Fix Unique Constraints for Multi-Budget
        // 1. Drop the old strict constraint (if it exists from previous runs)
        `ALTER TABLE bank_connections DROP CONSTRAINT IF EXISTS bank_connections_provider_connection_id_key`,
        // 2. Drop our custom constraint if it exists (to ensure clean recreate)
        `ALTER TABLE bank_connections DROP CONSTRAINT IF EXISTS unique_provider_connection_per_budget`,
        // 3. Add the new composite constraint (Unique ProviderID + BudgetID)
        `ALTER TABLE bank_connections ADD CONSTRAINT unique_provider_connection_per_budget UNIQUE (provider_connection_id, budget_id)`,

		`CREATE TABLE IF NOT EXISTS bank_accounts (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			connection_id UUID NOT NULL REFERENCES bank_connections(id) ON DELETE CASCADE,
			external_account_id VARCHAR(255) NOT NULL,
			name VARCHAR(255),
			mask VARCHAR(10),
			currency VARCHAR(3) DEFAULT 'EUR',
			balance DECIMAL(20, 2) DEFAULT 0,
			is_savings_pool BOOLEAN DEFAULT FALSE,
			last_synced_at TIMESTAMP DEFAULT NOW()
		)`,

		`CREATE INDEX IF NOT EXISTS idx_bank_connections_user ON bank_connections(user_id)`,
		`CREATE INDEX IF NOT EXISTS idx_bank_accounts_connection ON bank_accounts(connection_id)`,
        `CREATE INDEX IF NOT EXISTS idx_bank_connections_budget ON bank_connections(budget_id)`,

        `CREATE TABLE IF NOT EXISTS label_mappings (
            normalized_label VARCHAR(255) PRIMARY KEY,
            category VARCHAR(50) NOT NULL,
            source VARCHAR(20) DEFAULT 'AI',
            created_at TIMESTAMP DEFAULT NOW()
        )`,
        `CREATE INDEX IF NOT EXISTS idx_label_mappings_label ON label_mappings(normalized_label)`,

		// FIX: EmpÃªcher les doublons de comptes bancaires
        `ALTER TABLE bank_accounts DROP CONSTRAINT IF EXISTS unique_account_per_connection`, // Nettoyage au cas oÃ¹
        `ALTER TABLE bank_accounts ADD CONSTRAINT unique_account_per_connection UNIQUE (connection_id, external_account_id)`,
	}

	for _, migration := range migrations {
		if _, err := db.Exec(migration); err != nil {
            // We log errors but don't fail hard, as some "DROP CONSTRAINT" might fail if constraint doesn't exist
            // which is expected on a fresh DB vs an existing one.
			fmt.Printf("Migration notice: %v\n", err)
		}
	}

	return nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\admin.go
=========================================
// handlers/admin.go
package handlers

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"budget-api/utils"

	"github.com/gin-gonic/gin"
)

type AdminHandler struct {
	DB *sql.DB
}

// ============================================
// Migration Logic (intÃ©grÃ©e directement ici)
// ============================================

var MONTHS = []string{
	"Janvier", "FÃ©vrier", "Mars", "Avril", "Mai", "Juin",
	"Juillet", "AoÃ»t", "Septembre", "Octobre", "Novembre", "DÃ©cembre",
}

var MONTH_NAME_VARIANTS = map[string]string{
	"Janvier": "Janvier", "janvier": "Janvier",
	"FÃ©vrier": "FÃ©vrier", "fÃ©vrier": "FÃ©vrier", "Fevrier": "FÃ©vrier",
	"Mars": "Mars", "mars": "Mars",
	"Avril": "Avril", "avril": "Avril",
	"Mai": "Mai", "mai": "Mai",
	"Juin": "Juin", "juin": "Juin",
	"Juillet": "Juillet", "juillet": "Juillet",
	"AoÃ»t": "AoÃ»t", "aoÃ»t": "AoÃ»t", "Aout": "AoÃ»t",
	"Septembre": "Septembre", "septembre": "Septembre",
	"Octobre": "Octobre", "octobre": "Octobre",
	"Novembre": "Novembre", "novembre": "Novembre",
	"DÃ©cembre": "DÃ©cembre", "dÃ©cembre": "DÃ©cembre", "Decembre": "DÃ©cembre",
	// Encodage UTF-8 mojibake
	"FÃƒÂ©vrier":  "FÃ©vrier",
	"AoÃƒÂ»t":     "AoÃ»t",
	"DÃƒÂ©cembre": "DÃ©cembre",
}

type EncryptedDataWrapper struct {
	Encrypted string `json:"encrypted"`
}

func normalizeMonthName(monthKey string) (string, bool) {
	if normalized, ok := MONTH_NAME_VARIANTS[monthKey]; ok {
		return normalized, true
	}
	return "", false
}

func isMonthName(key string) bool {
	_, ok := normalizeMonthName(key)
	return ok
}

func getMonthIndex(monthName string) int {
	normalized, ok := normalizeMonthName(monthName)
	if !ok {
		return -1
	}
	for i, m := range MONTHS {
		if m == normalized {
			return i
		}
	}
	return -1
}

func isLegacyFormat(yearlyData map[string]interface{}) bool {
	for key := range yearlyData {
		if isMonthName(key) {
			return true
		}
	}
	return false
}

func isNewFormat(yearlyData map[string]interface{}) bool {
	for key, value := range yearlyData {
		if len(key) == 4 && key[0] >= '0' && key[0] <= '9' {
			if yearMap, ok := value.(map[string]interface{}); ok {
				if _, hasMonths := yearMap["months"]; hasMonths {
					return true
				}
			}
		}
	}
	return false
}

func migrateBudgetData(data map[string]interface{}) (map[string]interface{}, bool, error) {
	yearlyData, ok := data["yearlyData"].(map[string]interface{})
	if !ok || yearlyData == nil {
		return data, false, nil
	}

	if isNewFormat(yearlyData) {
		return data, false, nil
	}

	if !isLegacyFormat(yearlyData) {
		return data, false, nil
	}

	// DÃ©terminer l'annÃ©e cible depuis currentYear du budget
	targetYear := time.Now().Year()
	if cy, ok := data["currentYear"].(float64); ok {
		targetYear = int(cy)
	}
	yearKey := fmt.Sprintf("%d", targetYear)

	// Nouvelle structure
	newYearlyData := make(map[string]interface{})
	months := make([]map[string]interface{}, 12)
	expenses := make([]map[string]interface{}, 12)
	monthComments := make([]string, 12)
	expenseComments := make([]map[string]interface{}, 12)

	for i := 0; i < 12; i++ {
		months[i] = make(map[string]interface{})
		expenses[i] = make(map[string]interface{})
		monthComments[i] = ""
		expenseComments[i] = make(map[string]interface{})
	}

	// Migrer yearlyData (allocations projets)
	for monthKey, monthData := range yearlyData {
		idx := getMonthIndex(monthKey)
		if idx >= 0 && idx < 12 {
			if md, ok := monthData.(map[string]interface{}); ok {
				if _, hasMonths := md["months"]; !hasMonths {
					months[idx] = md
				}
			}
		}
	}

	// Migrer yearlyExpenses
	if ye, ok := data["yearlyExpenses"].(map[string]interface{}); ok {
		for monthKey, expenseData := range ye {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if ed, ok := expenseData.(map[string]interface{}); ok {
					expenses[idx] = ed
				}
			}
		}
	}

	// Migrer monthComments
	if mc, ok := data["monthComments"].(map[string]interface{}); ok {
		for monthKey, comment := range mc {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if c, ok := comment.(string); ok {
					monthComments[idx] = c
				}
			}
		}
	}

	// Migrer projectComments
	if pc, ok := data["projectComments"].(map[string]interface{}); ok {
		for monthKey, comments := range pc {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if pcm, ok := comments.(map[string]interface{}); ok {
					expenseComments[idx] = pcm
				}
			}
		}
	}

	// Migrer oneTimeIncomes
	if oti, ok := data["oneTimeIncomes"].(map[string]interface{}); ok {
		newOneTimeIncomes := make(map[string]interface{})
		newYearIncomes := make([]map[string]interface{}, 12)
		for i := 0; i < 12; i++ {
			newYearIncomes[i] = map[string]interface{}{"amount": float64(0), "description": ""}
		}
		for monthKey, income := range oti {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if amount, ok := income.(float64); ok {
					newYearIncomes[idx] = map[string]interface{}{"amount": amount, "description": ""}
				}
			}
		}
		newOneTimeIncomes[yearKey] = newYearIncomes
		data["oneTimeIncomes"] = newOneTimeIncomes
	}

	// Construire la nouvelle structure
	newYearlyData[yearKey] = map[string]interface{}{
		"months":          months,
		"expenses":        expenses,
		"monthComments":   monthComments,
		"expenseComments": expenseComments,
		"deletedMonths":   []int{},
	}

	data["yearlyData"] = newYearlyData
	data["version"] = "2.3-migrated"
	data["lastUpdated"] = time.Now().Format(time.RFC3339)

	// Nettoyer les anciens champs (optionnel, garde pour compatibilitÃ©)
	// delete(data, "yearlyExpenses")
	// delete(data, "monthComments")
	// delete(data, "projectComments")

	return data, true, nil
}

// ============================================
// HTTP Handlers
// ============================================

// MigrateAllBudgets migre tous les budgets vers le nouveau format
// POST /api/v1/admin/migrate-budgets
func (h *AdminHandler) MigrateAllBudgets(c *gin.Context) {
	// VÃ©rification du secret admin
	adminSecret := c.GetHeader("X-Admin-Secret")
	expectedSecret := os.Getenv("ADMIN_SECRET")

	if expectedSecret == "" {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "ADMIN_SECRET not configured"})
		return
	}

	if adminSecret != expectedSecret {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid admin secret"})
		return
	}

	// ExÃ©cuter la migration
	result, err := h.runMigration(c.Request.Context(), "")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, result)
}

// MigrateSingleBudget migre un seul budget
// POST /api/v1/admin/migrate-budget/:id
func (h *AdminHandler) MigrateSingleBudget(c *gin.Context) {
	// VÃ©rification du secret admin
	adminSecret := c.GetHeader("X-Admin-Secret")
	expectedSecret := os.Getenv("ADMIN_SECRET")

	if expectedSecret == "" {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "ADMIN_SECRET not configured"})
		return
	}

	if adminSecret != expectedSecret {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid admin secret"})
		return
	}

	budgetID := c.Param("id")
	if budgetID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Budget ID required"})
		return
	}

	result, err := h.runMigration(c.Request.Context(), budgetID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, result)
}

// runMigration exÃ©cute la migration pour un ou tous les budgets
func (h *AdminHandler) runMigration(ctx context.Context, budgetID string) (gin.H, error) {
	var query string
	var rows *sql.Rows
	var err error

	if budgetID != "" {
		query = `
			SELECT bd.budget_id, bd.data, b.name
			FROM budget_data bd
			JOIN budgets b ON bd.budget_id = b.id
			WHERE bd.budget_id = $1
		`
		rows, err = h.DB.QueryContext(ctx, query, budgetID)
	} else {
		query = `
			SELECT bd.budget_id, bd.data, b.name
			FROM budget_data bd
			JOIN budgets b ON bd.budget_id = b.id
			ORDER BY bd.updated_at DESC
		`
		rows, err = h.DB.QueryContext(ctx, query)
	}

	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}
	defer rows.Close()

	var migrated, skipped, errors int
	var details []gin.H

	for rows.Next() {
		var id string
		var rawJSON []byte
		var name string

		if err := rows.Scan(&id, &rawJSON, &name); err != nil {
			log.Printf("âŒ Scan error: %v", err)
			errors++
			continue
		}

		log.Printf("ðŸ“¦ Processing: %s (%s)", name, id)

		// 1. DÃ©crypter les donnÃ©es
		var data map[string]interface{}
		var wrapper EncryptedDataWrapper

		if err := json.Unmarshal(rawJSON, &wrapper); err == nil && wrapper.Encrypted != "" {
			// DonnÃ©es chiffrÃ©es
			decryptedBytes, err := utils.Decrypt(wrapper.Encrypted)
			if err != nil {
				log.Printf("  âŒ Decrypt error: %v", err)
				errors++
				details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": "decrypt failed"})
				continue
			}
			if err := json.Unmarshal(decryptedBytes, &data); err != nil {
				log.Printf("  âŒ Unmarshal error: %v", err)
				errors++
				details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": "unmarshal failed"})
				continue
			}
		} else {
			// DonnÃ©es non chiffrÃ©es (legacy)
			if err := json.Unmarshal(rawJSON, &data); err != nil {
				log.Printf("  âŒ Unmarshal error: %v", err)
				errors++
				details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": "unmarshal failed"})
				continue
			}
		}

		// 2. Migrer les donnÃ©es
		migratedData, wasMigrated, err := migrateBudgetData(data)
		if err != nil {
			log.Printf("  âŒ Migration error: %v", err)
			errors++
			details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": err.Error()})
			continue
		}

		if !wasMigrated {
			log.Printf("  â­ï¸  Already migrated or no migration needed")
			skipped++
			details = append(details, gin.H{"id": id, "name": name, "status": "skipped", "reason": "already new format"})
			continue
		}

		// 3. Re-chiffrer et sauvegarder
		migratedJSON, err := json.Marshal(migratedData)
		if err != nil {
			log.Printf("  âŒ Marshal error: %v", err)
			errors++
			continue
		}

		encryptedString, err := utils.Encrypt(migratedJSON)
		if err != nil {
			log.Printf("  âŒ Encrypt error: %v", err)
			errors++
			continue
		}

		newWrapper := EncryptedDataWrapper{Encrypted: encryptedString}
		storageJSON, err := json.Marshal(newWrapper)
		if err != nil {
			log.Printf("  âŒ Wrapper marshal error: %v", err)
			errors++
			continue
		}

		// 4. Mettre Ã  jour en base
		updateQuery := `
			UPDATE budget_data
			SET data = $1, version = version + 1, updated_at = $2
			WHERE budget_id = $3
		`
		if _, err := h.DB.ExecContext(ctx, updateQuery, storageJSON, time.Now(), id); err != nil {
			log.Printf("  âŒ Update error: %v", err)
			errors++
			details = append(details, gin.H{"id": id, "name": name, "status": "error", "reason": "db update failed"})
			continue
		}

		// Extraire l'annÃ©e cible pour le log
		targetYear := "unknown"
		if yd, ok := migratedData["yearlyData"].(map[string]interface{}); ok {
			for k := range yd {
				targetYear = k
				break
			}
		}

		log.Printf("  âœ… Migrated to year %s", targetYear)
		migrated++
		details = append(details, gin.H{"id": id, "name": name, "status": "migrated", "targetYear": targetYear})
	}

	return gin.H{
		"migrated": migrated,
		"skipped":  skipped,
		"errors":   errors,
		"details":  details,
	}, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\auth.go
=========================================
package handlers

import (
	"database/sql"
	"fmt"
	"net/http"
	"os"
	"time"

	"budget-api/utils"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// --- STRUCTURES DÃ‰FINIES ICI (C'Ã©tait ce qui manquait) ---

type AuthHandler struct {
	DB *sql.DB
}

type SignupRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required,min=8"`
	Name     string `json:"name" binding:"required"`
}

type LoginRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required"`
	TOTPCode string `json:"totp_code"`
}

type ResendVerificationRequest struct {
	Email string `json:"email" binding:"required,email"`
}

// --- HANDLERS ---

// Signup crÃ©e un utilisateur et envoie un email de vÃ©rification
func (h *AuthHandler) Signup(c *gin.Context) {
	var req SignupRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if user exists
	var exists bool
	err := h.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)", req.Email).Scan(&exists)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
		return
	}

	if exists {
		c.JSON(http.StatusConflict, gin.H{"error": "Cet email est dÃ©jÃ  utilisÃ©"})
		return
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		return
	}

	// Create user (email_verified defaults to FALSE)
	userID := uuid.New().String()
	_, err = h.DB.Exec(`
		INSERT INTO users (id, email, password_hash, name, created_at, updated_at, email_verified)
		VALUES ($1, $2, $3, $4, $5, $6, FALSE)
	`, userID, req.Email, string(hashedPassword), req.Name, time.Now(), time.Now())

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur crÃ©ation utilisateur"})
		return
	}

	// Create Verification Token
	verificationToken := uuid.New().String()
	expiresAt := time.Now().Add(24 * time.Hour)

	_, err = h.DB.Exec(`
        INSERT INTO email_verifications (user_id, token, expires_at)
        VALUES ($1, $2, $3)
    `, userID, verificationToken, expiresAt)

	if err != nil {
		fmt.Println("Erreur insert verification:", err)
	}

	// Send Email (in goroutine to be faster)
	go utils.SendVerificationEmail(req.Email, req.Name, verificationToken)

	c.JSON(http.StatusCreated, gin.H{
		"message":              "Compte crÃ©Ã©. Veuillez vÃ©rifier vos emails pour l'activer.",
		"require_verification": true,
	})
}

// Login connecte l'utilisateur et vÃ©rifie si l'email est validÃ©
func (h *AuthHandler) Login(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get user
	var userID, passwordHash, name string
	var totpEnabled, emailVerified bool
	var totpSecret sql.NullString

	// Note: On rÃ©cupÃ¨re aussi email_verified
	err := h.DB.QueryRow(`
		SELECT id, password_hash, name, totp_enabled, totp_secret, email_verified
		FROM users WHERE email = $1
	`, req.Email).Scan(&userID, &passwordHash, &name, &totpEnabled, &totpSecret, &emailVerified)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Identifiants invalides"})
		return
	}

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
		return
	}

	// Verify password
	if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(req.Password)); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Identifiants invalides"})
		return
	}

	// --- CHECK VERIFICATION ---
	if !emailVerified {
		c.JSON(http.StatusForbidden, gin.H{
			"error":        "Email non vÃ©rifiÃ©. Veuillez vÃ©rifier votre boÃ®te de rÃ©ception.",
			"not_verified": true,
		})
		return
	}

	// Check TOTP if enabled
	if totpEnabled {
		if req.TOTPCode == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "2FA code required", "require_totp": true})
			return
		}
		// Verify TOTP code here (logic in user handler or util)
		valid, _ := utils.VerifyTOTP(totpSecret.String, req.TOTPCode)
		if !valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Code 2FA invalide"})
			return
		}
	}

	// Generate token
	token, err := generateJWT(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"token": token,
		"user": gin.H{
			"id":    userID,
			"email": req.Email,
			"name":  name,
		},
	})
}

// VerifyEmail valide le token reÃ§u par email
func (h *AuthHandler) VerifyEmail(c *gin.Context) {
	token := c.Query("token")
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Token manquant"})
		return
	}

	var userID string
	var expiresAt time.Time

	// Find Token
	err := h.DB.QueryRow(`
        SELECT user_id, expires_at FROM email_verifications WHERE token = $1
    `, token).Scan(&userID, &expiresAt)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Lien invalide ou expirÃ©"})
		return
	}

	if time.Now().After(expiresAt) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Le lien a expirÃ©."})
		return
	}

	// Activate User
	_, err = h.DB.Exec("UPDATE users SET email_verified = TRUE WHERE id = $1", userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur serveur"})
		return
	}

	// Delete Token
	h.DB.Exec("DELETE FROM email_verifications WHERE token = $1", token)

	c.JSON(http.StatusOK, gin.H{"message": "Email vÃ©rifiÃ© avec succÃ¨s ! Vous pouvez vous connecter."})
}

// --- HELPER FUNCTIONS ---

func generateJWT(userID string) (string, error) {
	secret := os.Getenv("JWT_SECRET")
	if secret == "" {
		if os.Getenv("ENVIRONMENT") == "production" || os.Getenv("GIN_MODE") == "release" {
			return "", fmt.Errorf("JWT_SECRET is required in production")
		}
		secret = "dev-only-insecure-secret"
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(24 * time.Hour).Unix(),
	})
	return token.SignedString([]byte(secret))
}


// ResendVerification gÃ©nÃ¨re un nouveau token et renvoie l'email
func (h *AuthHandler) ResendVerification(c *gin.Context) {
	var req ResendVerificationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// 1. VÃ©rifier si l'utilisateur existe et n'est PAS dÃ©jÃ  vÃ©rifiÃ©
	var userID string
	var isVerified bool
	var name string

	err := h.DB.QueryRow("SELECT id, name, email_verified FROM users WHERE email = $1", req.Email).Scan(&userID, &name, &isVerified)
	
	if err == sql.ErrNoRows {
		// SÃ©curitÃ© : On ne dit pas si l'email existe ou non, on renvoie OK
		c.JSON(http.StatusOK, gin.H{"message": "Si ce compte existe, un email a Ã©tÃ© envoyÃ©."})
		return
	}

	if isVerified {
		c.JSON(http.StatusConflict, gin.H{"error": "Ce compte est dÃ©jÃ  vÃ©rifiÃ©. Connectez-vous."})
		return
	}

	// 2. Nettoyer les anciens tokens
	_, err = h.DB.Exec("DELETE FROM email_verifications WHERE user_id = $1", userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur systÃ¨me"})
        return
    }

	// 3. CrÃ©er nouveau token
	verificationToken := uuid.New().String()
	expiresAt := time.Now().Add(24 * time.Hour)

	_, err = h.DB.Exec(`
		INSERT INTO email_verifications (user_id, token, expires_at)
		VALUES ($1, $2, $3)
	`, userID, verificationToken, expiresAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Impossible de gÃ©nÃ©rer le token"})
		return
	}

	// 4. Renvoyer l'email
	go utils.SendVerificationEmail(req.Email, name, verificationToken)

	c.JSON(http.StatusOK, gin.H{"message": "Email de vÃ©rification envoyÃ© !"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\banking.go
=========================================
package handlers

import (
	"database/sql"
	"net/http"

	"budget-api/models"
	"budget-api/services"

	"github.com/gin-gonic/gin"
)

type BankingHandler struct {
	Service *services.BankingService
}

func NewBankingHandler(db *sql.DB) *BankingHandler {
	return &BankingHandler{
		Service: services.NewBankingService(db),
	}
}

// GetConnections liste les connexions DU BUDGET
func (h *BankingHandler) GetConnections(c *gin.Context) {
	budgetID := c.Param("id") // RÃ©cupÃ©rÃ© depuis l'URL /budgets/:id/banking/connections
	if budgetID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Budget ID required"})
		return
	}

	connections, err := h.Service.GetBudgetConnections(c.Request.Context(), budgetID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch connections"})
		return
	}

	totalReal, err := h.Service.GetRealityCheckSum(c.Request.Context(), budgetID)
	if err != nil {
		// Si aucune ligne n'est trouvÃ©e (pas de compte Ã©pargne cochÃ©), le total est 0
		totalReal = 0
	}

	c.JSON(http.StatusOK, gin.H{
		"connections":     connections,
		"total_real_cash": totalReal,
	})
}

// UpdateAccountPool met Ã  jour le flag "is_savings_pool"
func (h *BankingHandler) UpdateAccountPool(c *gin.Context) {
	accountID := c.Param("account_id")

	var req models.UpdateAccountPoolRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	err := h.Service.UpdateAccountPool(c.Request.Context(), accountID, req.IsSavingsPool)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update account"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Account updated successfully"})
}

// DeleteConnection supprime une connexion bancaire
func (h *BankingHandler) DeleteConnection(c *gin.Context) {
	connID := c.Param("connection_id")

	err := h.Service.DeleteConnection(c.Request.Context(), connID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete connection"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Connection deleted successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\bridge.go
=========================================
package handlers

import (
	"database/sql"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"budget-api/middleware"
	"budget-api/services"

	"github.com/gin-gonic/gin"
)

type BridgeHandler struct {
	DB            *sql.DB
	Service       *services.BankingService
	BridgeService *services.BridgeService
}

func NewBridgeHandler(db *sql.DB) *BridgeHandler {
	return &BridgeHandler{
		DB:            db,
		Service:       services.NewBankingService(db),
		BridgeService: services.NewBridgeService(),
	}
}

// 1. Lister les banques disponibles
func (h *BridgeHandler) GetBanks(c *gin.Context) {
	banks, err := h.BridgeService.GetBanks(c.Request.Context())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch banks", "details": err.Error()})
		return
	}

	var displayBanks []map[string]interface{}
	for _, b := range banks {
		displayBanks = append(displayBanks, map[string]interface{}{
			"id":   b.ID,
			"name": b.Name,
			"logo": b.Images.Logo,
		})
	}

	c.JSON(http.StatusOK, gin.H{"banks": displayBanks})
}

// 2. CrÃ©er une Connect Session
func (h *BridgeHandler) CreateConnection(c *gin.Context) {
	userID := middleware.GetUserID(c)

	var userEmail string
	err := h.DB.QueryRow("SELECT email FROM users WHERE id = $1", userID).Scan(&userEmail)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user email", "details": err.Error()})
		return
	}

	// TENTATIVE SIMPLE : On n'envoie PAS redirect_url dans le body pour l'instant
	// car c'est ce qui fait planter votre appel Bridge (Erreur 500 Invalid Body).
	// On laisse Bridge utiliser l'URL par dÃ©faut configurÃ©e dans le Dashboard.
	connectURL, err := h.BridgeService.CreateConnectItem(c.Request.Context(), userEmail)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create Bridge session", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"redirect_url": connectURL,
	})
}

// 3. Synchroniser les items et comptes DANS LE BUDGET ACTUEL
func (h *BridgeHandler) SyncAccounts(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")

	if budgetID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Budget ID required"})
		return
	}

	var userEmail string
	err := h.DB.QueryRow("SELECT email FROM users WHERE id = $1", userID).Scan(&userEmail)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user email"})
		return
	}

	// 1. RÃ©cupÃ©rer TOUS les comptes depuis Bridge
	accounts, err := h.BridgeService.GetAccounts(c.Request.Context(), userEmail)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch accounts from Bridge", "details": err.Error()})
		return
	}

	if len(accounts) == 0 {
		c.JSON(http.StatusOK, gin.H{"message": "No accounts found.", "accounts_synced": 0})
		return
	}

	// 2. RÃ©cupÃ©rer les Items (pour avoir le nom des banques)
	items, _ := h.BridgeService.GetItems(c.Request.Context(), userEmail)
	itemMap := make(map[int64]services.BridgeItem)
	for _, item := range items {
		itemMap[item.ID] = item
	}

	accountsSynced := 0

	// 3. Boucle simplifiÃ©e : On sauvegarde (Upsert) la connexion puis le compte
	for _, acc := range accounts {
		// Nom de la banque
		institutionName := "Bridge Connection"
		providerIDStr := "0"
		
		if item, exists := itemMap[acc.ItemID]; exists {
			institutionName = fmt.Sprintf("Bank ID %d", item.ProviderID)
			providerIDStr = strconv.Itoa(item.ProviderID)
		}

		// A. Sauvegarder/RÃ©cupÃ©rer la Connexion (UPSERT gÃ©rÃ© par le service)
		// On utilise ItemID (string) comme identifiant unique de la connexion Bridge
		itemIDStr := strconv.FormatInt(acc.ItemID, 10)
		
		connID, err := h.Service.SaveConnectionWithTokens(
			c.Request.Context(),
			userID,
			budgetID,
			providerIDStr,   
			institutionName, 
			itemIDStr,       // Provider Connection ID (Unique key pour l'Upsert)
			"bridge-v3-managed",
			"",
			time.Now().AddDate(1, 0, 0),
		)

		if err != nil {
			fmt.Printf("Error ensuring connection for account %s: %v\n", acc.Name, err)
			continue
		}

		// B. Sauvegarder le Compte (UPSERT gÃ©rÃ© par le service)
		mask := acc.IBAN
		if len(mask) > 4 {
			mask = mask[len(mask)-4:]
		}

		err = h.Service.SaveAccount(
			c.Request.Context(),
			connID,
			strconv.FormatInt(acc.ID, 10), // External Account ID
			acc.Name,
			mask,
			acc.Currency,
			acc.Balance,
		)

		if err == nil {
			accountsSynced++
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Accounts synchronized successfully",
		"accounts_synced": accountsSynced,
	})
}

// 4. Refresh Balances (Global ou Budget scoped)
func (h *BridgeHandler) RefreshBalances(c *gin.Context) {
	userID := middleware.GetUserID(c)
	var userEmail string
	h.DB.QueryRow("SELECT email FROM users WHERE id = $1", userID).Scan(&userEmail)
	
	accounts, err := h.BridgeService.GetAccounts(c.Request.Context(), userEmail)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch accounts"})
		return
	}

	updatedCount := 0
	for _, acc := range accounts {
		accountID := strconv.FormatInt(acc.ID, 10)
		result, err := h.DB.Exec(
			`UPDATE bank_accounts SET balance = $1, last_synced_at = NOW() WHERE external_account_id = $2`,
			acc.Balance, accountID,
		)
		if err == nil {
			rows, _ := result.RowsAffected()
			if rows > 0 { updatedCount++ }
		}
	}

	c.JSON(http.StatusOK, gin.H{"message": "Balances refreshed", "updated_count": updatedCount})
}

// 5. Get Transactions
func (h *BridgeHandler) GetTransactions(c *gin.Context) {
	userID := middleware.GetUserID(c)
	var userEmail string
	h.DB.QueryRow("SELECT email FROM users WHERE id = $1", userID).Scan(&userEmail)
	
	transactions, err := h.BridgeService.GetTransactions(c.Request.Context(), userEmail, nil)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch transactions"})
		return
	}
	
	// Transformer les ID en string pour le JSON
	type DisplayTransaction struct {
		ID          string  `json:"id"`
		AccountID   string  `json:"account_id"`
		Amount      float64 `json:"amount"`
		Currency    string  `json:"currency_code"`
		Description string  `json:"clean_description"`
		Date        string  `json:"date"`
	}

	var displayTransactions []DisplayTransaction
	for _, t := range transactions {
		uniqueID := fmt.Sprintf("%d-%d", t.ID, t.AccountID)
		if t.ID == 0 {
			uniqueID = strconv.FormatInt(time.Now().UnixNano(), 10)
		}

		displayTransactions = append(displayTransactions, DisplayTransaction{
			ID:          uniqueID,
			AccountID:   strconv.FormatInt(t.AccountID, 10),
			Amount:      t.Amount,
			Currency:    t.Currency,
			Description: t.Description,
			Date:        t.Date,
		})
	}

	c.JSON(http.StatusOK, gin.H{"transactions": displayTransactions})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\budget.go
=========================================
package handlers

import (
	"log"
	"net/http"

	"budget-api/services"

	"github.com/gin-gonic/gin"
)

type Handler struct {
	budgetService *services.BudgetService
	emailService  *services.EmailService
}

func NewHandler(budgetService *services.BudgetService, emailService *services.EmailService) *Handler {
	return &Handler{
		budgetService: budgetService,
		emailService:  emailService,
	}
}

// GetBudgets returns all budgets for the authenticated user
func (h *Handler) GetBudgets(c *gin.Context) {
	userID := c.GetString("user_id")

	budgets, err := h.budgetService.GetUserBudgets(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get budgets"})
		return
	}

	c.JSON(http.StatusOK, budgets)
}

// CreateBudget creates a new budget
func (h *Handler) CreateBudget(c *gin.Context) {
	var req struct {
		Name string `json:"name" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	userID := c.GetString("user_id")

	budget, err := h.budgetService.Create(c.Request.Context(), req.Name, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create budget"})
		return
	}

	c.JSON(http.StatusCreated, budget)
}

// GetBudget returns a specific budget
func (h *Handler) GetBudget(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	budget, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	c.JSON(http.StatusOK, budget)
}

// UpdateBudget updates a budget name
func (h *Handler) UpdateBudget(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	var req struct {
		Name string `json:"name" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if user has access
	_, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	if err := h.budgetService.Update(c.Request.Context(), budgetID, req.Name); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update budget"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Budget updated successfully"})
}

// DeleteBudget deletes a budget
func (h *Handler) DeleteBudget(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	// Check if user is the owner
	budget, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	if budget.OwnerID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only the owner can delete the budget"})
		return
	}

	// Delete the budget
	if err := h.budgetService.Delete(c.Request.Context(), budgetID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete budget"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Budget deleted successfully"})
}

// GetBudgetData returns the JSON data for a budget
func (h *Handler) GetBudgetData(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	// Check access
	_, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	data, err := h.budgetService.GetData(c.Request.Context(), budgetID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get budget data"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"data": data})
}

// UpdateBudgetData updates the JSON data for a budget
func (h *Handler) UpdateBudgetData(c *gin.Context) {
	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	var req struct {
		Data interface{} `json:"data" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check access
	_, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	if err := h.budgetService.UpdateData(c.Request.Context(), budgetID, req.Data); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update budget data"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Budget data updated successfully"})
}

// InviteMember invites a member to a budget
func (h *Handler) InviteMember(c *gin.Context) {
	var req struct {
		Email string `json:"email" binding:"required,email"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	budgetID := c.Param("id")
	userID := c.GetString("user_id")

	// Check if user is the owner
	budget, err := h.budgetService.GetByID(c.Request.Context(), budgetID, userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
		return
	}

	if budget.OwnerID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only the owner can invite members"})
		return
	}

	// Check if user is already a member
	isMember, err := h.budgetService.IsMemberByEmail(c.Request.Context(), budgetID, req.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error checking membership"})
		return
	}
	if isMember {
		c.JSON(http.StatusConflict, gin.H{"error": "Cet utilisateur est dÃ©jÃ  membre du budget"})
		return
	}

	// Check if there's an existing pending invitation
	existingInvitation, _ := h.budgetService.GetPendingInvitation(c.Request.Context(), budgetID, req.Email)
	if existingInvitation != nil {
		// Delete the old invitation to create a fresh one
		if err := h.budgetService.DeleteInvitation(c.Request.Context(), existingInvitation.ID); err != nil {
			log.Printf("Failed to delete old invitation: %v", err)
		}
	}

	// Create invitation
	invitation, err := h.budgetService.CreateInvitation(c.Request.Context(), budgetID, req.Email, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Send email
	inviterName := budget.OwnerName
	if inviterName == "" {
		inviterName = "Un utilisateur"
	}

	if err := h.emailService.SendInvitation(req.Email, inviterName, budget.Name, invitation.Token); err != nil {
		log.Printf("Failed to send invitation email: %v", err)
		// Don't fail the request if email fails, but log it
	}

	c.JSON(http.StatusOK, gin.H{
		"message":    "Invitation sent successfully",
		"invitation": invitation,
	})
}

// AcceptInvitation accepts an invitation
func (h *Handler) AcceptInvitation(c *gin.Context) {
	var req struct {
		Token string `json:"token" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	userID := c.GetString("user_id")

	if err := h.budgetService.AcceptInvitation(c.Request.Context(), req.Token, userID); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Invitation accepted successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\categorization.go
=========================================
package handlers

import (
	"database/sql"
	"net/http"

	"budget-api/services"

	"github.com/gin-gonic/gin"
)

type CategorizationHandler struct {
	Service *services.CategorizerService
}

func NewCategorizationHandler(db *sql.DB) *CategorizationHandler {
	return &CategorizationHandler{
		Service: services.NewCategorizerService(db),
	}
}

type CategorizeRequest struct {
	Label string `json:"label" binding:"required"`
}

func (h *CategorizationHandler) CategorizeLabel(c *gin.Context) {
	var req CategorizeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	category, err := h.Service.GetCategory(c.Request.Context(), req.Label)
	if err != nil {
		// Fallback silencieux en cas d'erreur grave
		c.JSON(http.StatusOK, gin.H{"category": "OTHER", "source": "fallback"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"label":    req.Label,
		"category": category,
	})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\enable_banking_handler.go
=========================================
package handlers

import (
	"bytes"
	"database/sql"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"budget-api/middleware"
	"budget-api/services"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type EnableBankingHandler struct {
	DB                    *sql.DB
	Service               *services.BankingService
	EnableBankingService  *services.EnableBankingService
}

func NewEnableBankingHandler(db *sql.DB) *EnableBankingHandler {
	return &EnableBankingHandler{
		DB:                   db,
		Service:              services.NewBankingService(db),
		EnableBankingService: services.NewEnableBankingService(),
	}
}

// ========== 1. GET BANKS ==========

func (h *EnableBankingHandler) GetBanks(c *gin.Context) {
	country := c.DefaultQuery("country", "FR")
	
	aspsps, err := h.EnableBankingService.GetASPSPs(c.Request.Context(), country)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to fetch banks",
			"details": err.Error(),
		})
		return
	}

	var banks []map[string]interface{}
	for _, aspsp := range aspsps {
		bank := map[string]interface{}{
			"id":      aspsp.Name,
			"name":    aspsp.Name,
			"country": aspsp.Country,
			"logo":    aspsp.Logo,
			"beta":    aspsp.Beta,
		}
		
		if aspsp.BIC != "" {
			bank["bic"] = aspsp.BIC
		}
		
		if aspsp.Sandbox != nil {
			bank["sandbox"] = true
			bank["sandbox_users"] = aspsp.Sandbox.Users
		} else {
			bank["sandbox"] = false
		}
		
		banks = append(banks, bank)
	}

	c.JSON(http.StatusOK, gin.H{"banks": banks})
}

// ========== 2. CREATE CONNECTION ==========

func (h *EnableBankingHandler) CreateConnection(c *gin.Context) {
	var req struct {
		ASPSPID string `json:"aspsp_id" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "aspsp_id is required"})
		return
	}

	state := uuid.New().String()
	validUntil := time.Now().AddDate(0, 0, 90).Format(time.RFC3339)

	callbackURL := os.Getenv("FRONTEND_URL")
	if callbackURL == "" {
		callbackURL = "https://www.budgetfamille.com"
	}
	callbackURL += "/beta2/callback"

	authReq := services.AuthRequest{
		Access: services.Access{
			ValidUntil: validUntil,
		},
		ASPSP: services.ASPSPIdentifier{
			Name:    req.ASPSPID,
			Country: "FR",
		},
		State:       state,
		RedirectURL: callbackURL,
		PSUType:     "personal",
	}

	authResp, err := h.EnableBankingService.CreateAuthRequest(c.Request.Context(), authReq)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to create connection",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"redirect_url": authResp.AuthURL,
		"state":        authResp.State,
	})
}

// ========== 3. CALLBACK ==========

func (h *EnableBankingHandler) HandleCallback(c *gin.Context) {
	code := c.Query("code")
	state := c.Query("state")

	if code == "" || state == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing code or state"})
		return
	}

	sessionResp, err := h.EnableBankingService.CreateSession(c.Request.Context(), code, state)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to create session",
			"details": err.Error(),
		})
		return
	}

	var accounts []map[string]interface{}
	for _, acc := range sessionResp.Accounts {
		iban := acc.AccountID.IBAN
		if iban == "" && acc.AccountID.Other != nil {
			iban = acc.AccountID.Other.Identification
		}
		
		accounts = append(accounts, map[string]interface{}{
			"uid":      acc.UID,
			"name":     acc.Name,
			"iban":     iban,
			"currency": acc.Currency,
			"type":     acc.CashAccountType,
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"session_id": sessionResp.SessionID,
		"accounts":   accounts,
	})
}

// ========== 4. SYNC ACCOUNTS (VERSION DEBUG COMPLÃˆTE) ==========

func (h *EnableBankingHandler) SyncAccounts(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")

	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	log.Printf("ðŸ”µ [SYNC DEBUG] START")
	log.Printf("ðŸ”µ [SYNC DEBUG] User ID: %s", userID)
	log.Printf("ðŸ”µ [SYNC DEBUG] Budget ID: %s", budgetID)
	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

	// Lire le body brut AVANT le parsing
	bodyBytes, err := io.ReadAll(c.Request.Body)
	if err != nil {
		log.Printf("âŒ [SYNC DEBUG] Failed to read body: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot read request body"})
		return
	}

	log.Printf("ðŸ”µ [SYNC DEBUG] Raw Body Length: %d bytes", len(bodyBytes))
	log.Printf("ðŸ”µ [SYNC DEBUG] Raw Body Content: %s", string(bodyBytes))

	// Re-crÃ©er le body reader pour le binding JSON
	c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

	var req struct {
		SessionID string `json:"session_id"`
		Accounts  []struct {
			UID      string `json:"uid"`
			Name     string `json:"name"`
			IBAN     string `json:"iban"`
			Currency string `json:"currency"`
			Type     string `json:"type"`
		} `json:"accounts"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("âŒ [SYNC DEBUG] JSON Binding Error: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid JSON format",
			"details": err.Error(),
			"received_body": string(bodyBytes),
		})
		return
	}

	log.Printf("ðŸ”µ [SYNC DEBUG] Parsed SessionID: '%s'", req.SessionID)
	log.Printf("ðŸ”µ [SYNC DEBUG] Parsed Accounts Count: %d", len(req.Accounts))

	for i, acc := range req.Accounts {
		log.Printf("ðŸ”µ [SYNC DEBUG] Account[%d]: UID=%s, Name=%s, IBAN=%s", i, acc.UID, acc.Name, acc.IBAN)
	}

	// Validation
	if req.SessionID == "" {
		log.Printf("âŒ [SYNC DEBUG] SessionID is EMPTY after parsing!")
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "session_id is required",
			"received_session_id": req.SessionID,
		})
		return
	}

	if len(req.Accounts) == 0 {
		log.Printf("âš ï¸  [SYNC DEBUG] No accounts in request!")
		c.JSON(http.StatusOK, gin.H{
			"message": "No accounts to sync",
			"accounts_synced": 0,
		})
		return
	}

	log.Printf("âœ… [SYNC DEBUG] Validation passed, starting sync...")
	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

	accountsSynced := 0

	for i, acc := range req.Accounts {
		log.Printf("ðŸ’³ [%d/%d] Processing: %s (UID: %s)", i+1, len(req.Accounts), acc.Name, acc.UID)
		
		// A. CrÃ©er/rÃ©cupÃ©rer la connexion
		log.Printf("   â†’ Creating connection...")
		connID, err := h.Service.SaveConnectionWithTokens(
			c.Request.Context(),
			userID,
			budgetID,
			acc.UID,
			"Enable Banking",
			req.SessionID,
			"enablebanking-managed",
			"",
			time.Now().AddDate(0, 3, 0),
		)

		if err != nil {
			log.Printf("âŒ [%d/%d] Error creating connection: %v", i+1, len(req.Accounts), err)
			continue
		}

		log.Printf("âœ… [%d/%d] Connection created: %s", i+1, len(req.Accounts), connID)

		// B. RÃ©cupÃ©rer le solde
		balance := 0.0
		log.Printf("   â†’ Fetching balance...")
		
		balances, err := h.EnableBankingService.GetBalances(
			c.Request.Context(),
			req.SessionID,
			acc.UID,
		)
		
		if err != nil {
			log.Printf("âš ï¸  [%d/%d] Could not fetch balance: %v", i+1, len(req.Accounts), err)
		} else if len(balances) > 0 {
			amountStr := balances[0].BalanceAmount.Amount
			if parsed, err := strconv.ParseFloat(amountStr, 64); err == nil {
				balance = parsed
				log.Printf("ðŸ’° [%d/%d] Balance: %.2f %s", i+1, len(req.Accounts), balance, balances[0].BalanceAmount.Currency)
			} else {
				log.Printf("âš ï¸  [%d/%d] Could not parse balance: '%s' (error: %v)", i+1, len(req.Accounts), amountStr, err)
			}
		} else {
			log.Printf("âš ï¸  [%d/%d] No balances returned", i+1, len(req.Accounts))
		}

		// C. Sauvegarder le compte
		log.Printf("   â†’ Saving account...")
		mask := acc.IBAN
		if len(mask) > 4 {
			mask = mask[len(mask)-4:]
		}

		err = h.Service.SaveAccount(
			c.Request.Context(),
			connID,
			acc.UID,
			acc.Name,
			mask,
			acc.Currency,
			balance,
		)

		if err != nil {
			log.Printf("âŒ [%d/%d] Error saving account: %v", i+1, len(req.Accounts), err)
		} else {
			log.Printf("âœ… [%d/%d] Account saved: %s (%.2f %s)", i+1, len(req.Accounts), acc.Name, balance, acc.Currency)
			accountsSynced++
		}
	}

	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	log.Printf("ðŸŽ‰ SYNC COMPLETE: %d/%d accounts synced", accountsSynced, len(req.Accounts))
	log.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

	c.JSON(http.StatusOK, gin.H{
		"message": "Accounts synchronized successfully",
		"accounts_synced": accountsSynced,
	})
}

// ========== 5. GET CONNECTIONS (NOUVEAU - FIX 404) ==========

// GET /api/v1/budgets/:id/banking/enablebanking/connections
func (h *EnableBankingHandler) GetConnections(c *gin.Context) {
	budgetID := c.Param("id")
	userID := middleware.GetUserID(c)

	log.Printf("ðŸ“‹ Fetching Enable Banking connections for budget %s", budgetID)

	rows, err := h.DB.Query(`
		SELECT 
			bc.id,
			bc.institution_name,
			bc.created_at,
			COUNT(ba.id) as account_count
		FROM banking_connections bc
		LEFT JOIN banking_accounts ba ON ba.connection_id = bc.id
		WHERE bc.budget_id = $1 AND bc.user_id = $2 AND bc.provider = 'enablebanking'
		GROUP BY bc.id, bc.institution_name, bc.created_at
		ORDER BY bc.created_at DESC
	`, budgetID, userID)

	if err != nil {
		log.Printf("âŒ Error fetching connections: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch connections"})
		return
	}
	defer rows.Close()

	type Connection struct {
		ID              string    `json:"id"`
		InstitutionName string    `json:"institution_name"`
		CreatedAt       time.Time `json:"created_at"`
		AccountCount    int       `json:"account_count"`
	}

	var connections []Connection

	for rows.Next() {
		var conn Connection
		if err := rows.Scan(&conn.ID, &conn.InstitutionName, &conn.CreatedAt, &conn.AccountCount); err != nil {
			continue
		}
		connections = append(connections, conn)
	}

	log.Printf("âœ… Found %d Enable Banking connections", len(connections))

	c.JSON(http.StatusOK, gin.H{"connections": connections})
}

// ========== 6. REFRESH BALANCES ==========

func (h *EnableBankingHandler) RefreshBalances(c *gin.Context) {
	var req struct {
		ConnectionID string `json:"connection_id" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "connection_id is required"})
		return
	}

	var sessionID string
	err := h.DB.QueryRow(`
		SELECT provider_connection_id 
		FROM banking_connections 
		WHERE id = $1
	`, req.ConnectionID).Scan(&sessionID)

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Connection not found"})
		return
	}

	rows, err := h.DB.Query(`
		SELECT id, external_account_id 
		FROM banking_accounts 
		WHERE connection_id = $1
	`, req.ConnectionID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch accounts"})
		return
	}
	defer rows.Close()

	updatedCount := 0

	for rows.Next() {
		var accountID, externalID string
		if err := rows.Scan(&accountID, &externalID); err != nil {
			continue
		}

		balances, err := h.EnableBankingService.GetBalances(
			c.Request.Context(), 
			sessionID, 
			externalID,
		)

		if err != nil {
			fmt.Printf("Error fetching balance for account %s: %v\n", externalID, err)
			continue
		}

		if len(balances) > 0 {
			amountStr := balances[0].BalanceAmount.Amount
			if balance, err := strconv.ParseFloat(amountStr, 64); err == nil {
				_, err := h.DB.Exec(`
					UPDATE banking_accounts 
					SET balance = $1, last_synced = NOW() 
					WHERE id = $2
				`, balance, accountID)

				if err == nil {
					updatedCount++
				}
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Balances refreshed",
		"accounts_updated": updatedCount,
	})
}

// ========== 7. GET TRANSACTIONS ==========

func (h *EnableBankingHandler) GetTransactions(c *gin.Context) {
	userID := middleware.GetUserID(c)
	
	rows, err := h.DB.Query(`
		SELECT bc.provider_connection_id, ba.external_account_id, ba.id
		FROM banking_accounts ba
		JOIN banking_connections bc ON ba.connection_id = bc.id
		WHERE bc.user_id = $1 AND bc.provider = 'enablebanking'
	`, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch accounts"})
		return
	}
	defer rows.Close()

	type TransactionDisplay struct {
		ID          string  `json:"id"`
		AccountID   string  `json:"account_id"`
		Amount      float64 `json:"amount"`
		Currency    string  `json:"currency_code"`
		Description string  `json:"clean_description"`
		Date        string  `json:"date"`
	}

	var allTransactions []TransactionDisplay
	transactionID := 1

	dateFrom := time.Now().AddDate(0, 0, -90).Format("2006-01-02")
	dateTo := time.Now().Format("2006-01-02")

	for rows.Next() {
		var sessionID, accountUID, accountID string
		if err := rows.Scan(&sessionID, &accountUID, &accountID); err != nil {
			continue
		}

		transactions, err := h.EnableBankingService.GetTransactions(
			c.Request.Context(),
			sessionID,
			accountUID,
			dateFrom,
			dateTo,
		)

		if err != nil {
			log.Printf("âš ï¸  Error fetching transactions for account %s: %v", accountUID, err)
			continue
		}

		for _, tx := range transactions {
			amount := 0.0
			if parsed, err := strconv.ParseFloat(tx.TransactionAmount.Amount, 64); err == nil {
				amount = parsed
				if tx.CreditDebitIndicator == "DBIT" {
					amount = -amount
				}
			}

			description := tx.RemittanceInfo
			if description == "" && tx.CreditorName != "" {
				description = tx.CreditorName
			}
			if description == "" && tx.DebtorName != "" {
				description = tx.DebtorName
			}
			if description == "" {
				description = "Transaction"
			}

			allTransactions = append(allTransactions, TransactionDisplay{
				ID:          fmt.Sprintf("eb-%d", transactionID),
				AccountID:   accountID,
				Amount:      amount,
				Currency:    tx.TransactionAmount.Currency,
				Description: description,
				Date:        tx.BookingDate,
			})
			transactionID++
		}
	}

	c.JSON(http.StatusOK, gin.H{"transactions": allTransactions})
}

// ========== 8. DELETE CONNECTION ==========

func (h *EnableBankingHandler) DeleteConnection(c *gin.Context) {
	connectionID := c.Param("id")

	var sessionID string
	err := h.DB.QueryRow(`
		SELECT provider_connection_id 
		FROM banking_connections 
		WHERE id = $1
	`, connectionID).Scan(&sessionID)

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Connection not found"})
		return
	}

	if err := h.EnableBankingService.DeleteSession(c.Request.Context(), sessionID); err != nil {
		fmt.Printf("Warning: Failed to delete Enable Banking session: %v\n", err)
	}

	_, err = h.DB.Exec(`DELETE FROM banking_connections WHERE id = $1`, connectionID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete connection"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Connection deleted successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\invitation.go
=========================================
package handlers

import (
	"database/sql"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"budget-api/middleware"
	"budget-api/models"
	"budget-api/utils"
)

type InvitationHandler struct {
	DB *sql.DB
}

// InviteUser sends an invitation to join a budget
func (h *InvitationHandler) InviteUser(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")

	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Check if user is a member of the budget
	var exists bool
	err := h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members
			WHERE budget_id = $1 AND user_id = $2
		)
	`, budgetID, userID).Scan(&exists)

	if err != nil || !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}

	var req models.InvitationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if user is already a member
	var alreadyMember bool
	err = h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members bm
			INNER JOIN users u ON bm.user_id = u.id
			WHERE bm.budget_id = $1 AND u.email = $2
		)
	`, budgetID, req.Email).Scan(&alreadyMember)

	if err == nil && alreadyMember {
		c.JSON(http.StatusConflict, gin.H{"error": "User is already a member"})
		return
	}

	// Check if there's a pending invitation
	var pendingInvitation bool
	err = h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM invitations
			WHERE budget_id = $1 AND email = $2 AND status = 'pending' AND expires_at > NOW()
		)
	`, budgetID, req.Email).Scan(&pendingInvitation)

	if err == nil && pendingInvitation {
		c.JSON(http.StatusConflict, gin.H{"error": "Invitation already sent"})
		return
	}

	// Generate invitation token
	token := uuid.New().String()

	// Create invitation
	var invitationID string
	expiresAt := time.Now().Add(7 * 24 * time.Hour) // 7 days
	err = h.DB.QueryRow(`
		INSERT INTO invitations (budget_id, email, invited_by, token, expires_at)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id
	`, budgetID, req.Email, userID, token, expiresAt).Scan(&invitationID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create invitation"})
		return
	}

	// Get budget and inviter info for email
	var budgetName, inviterName string
	err = h.DB.QueryRow(`
		SELECT b.name, u.name
		FROM budgets b, users u
		WHERE b.id = $1 AND u.id = $2
	`, budgetID, userID).Scan(&budgetName, &inviterName)

	if err != nil {
		inviterName = "A user"
		budgetName = "a budget"
	}

	// Send invitation email
	err = utils.SendInvitationEmail(req.Email, inviterName, budgetName, token)
	if err != nil {
		// Log error but don't fail the request
		c.JSON(http.StatusCreated, gin.H{
			"id":      invitationID,
			"token":   token,
			"message": "Invitation created but email failed to send",
			"warning": "Please share the invitation link manually",
		})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"id":      invitationID,
		"message": "Invitation sent successfully",
	})
}

// GetInvitations returns all invitations for a budget
func (h *InvitationHandler) GetInvitations(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")

	// Check access
	var exists bool
	err := h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members
			WHERE budget_id = $1 AND user_id = $2
		)
	`, budgetID, userID).Scan(&exists)

	if err != nil || !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}

	// Get invitations
	rows, err := h.DB.Query(`
		SELECT i.id, i.budget_id, i.email, i.invited_by, i.token, i.status, i.expires_at, i.created_at,
		       u.name as inviter_name
		FROM invitations i
		LEFT JOIN users u ON i.invited_by = u.id
		WHERE i.budget_id = $1
		ORDER BY i.created_at DESC
	`, budgetID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch invitations"})
		return
	}
	defer rows.Close()

	invitations := []map[string]interface{}{}
	for rows.Next() {
		var inv models.Invitation
		var inviterName sql.NullString
		err := rows.Scan(&inv.ID, &inv.BudgetID, &inv.Email, &inv.InvitedBy, &inv.Token,
			&inv.Status, &inv.ExpiresAt, &inv.CreatedAt, &inviterName)
		if err != nil {
			continue
		}

		invMap := map[string]interface{}{
			"id":         inv.ID,
			"email":      inv.Email,
			"status":     inv.Status,
			"expires_at": inv.ExpiresAt,
			"created_at": inv.CreatedAt,
		}

		if inviterName.Valid {
			invMap["inviter_name"] = inviterName.String
		}

		invitations = append(invitations, invMap)
	}

	c.JSON(http.StatusOK, invitations)
}

// AcceptInvitation accepts an invitation and adds user to budget
func (h *InvitationHandler) AcceptInvitation(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req models.AcceptInvitationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get invitation
	var inv models.Invitation
	var userEmail string
	err := h.DB.QueryRow(`
		SELECT i.id, i.budget_id, i.email, i.status, i.expires_at,
		       u.email as user_email
		FROM invitations i, users u
		WHERE i.token = $1 AND u.id = $2
	`, req.Token, userID).Scan(&inv.ID, &inv.BudgetID, &inv.Email, &inv.Status, &inv.ExpiresAt, &userEmail)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Invitation not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch invitation"})
		return
	}

	// Check if invitation is valid
	if inv.Status != "pending" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invitation already " + inv.Status})
		return
	}

	if time.Now().After(inv.ExpiresAt) {
		// Mark as expired
		h.DB.Exec(`UPDATE invitations SET status = 'expired' WHERE id = $1`, inv.ID)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invitation has expired"})
		return
	}

	// Verify email matches
	if userEmail != inv.Email {
		c.JSON(http.StatusForbidden, gin.H{"error": "This invitation is for a different email address"})
		return
	}

	// Check if already a member
	var alreadyMember bool
	err = h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members
			WHERE budget_id = $1 AND user_id = $2
		)
	`, inv.BudgetID, userID).Scan(&alreadyMember)

	if alreadyMember {
		c.JSON(http.StatusConflict, gin.H{"error": "You are already a member"})
		return
	}

	// Add user to budget
	_, err = h.DB.Exec(`
		INSERT INTO budget_members (budget_id, user_id, role, permissions)
		VALUES ($1, $2, 'member', '{"read": true, "write": true}')
	`, inv.BudgetID, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add member"})
		return
	}

	// Mark invitation as accepted
	_, err = h.DB.Exec(`
		UPDATE invitations
		SET status = 'accepted'
		WHERE id = $1
	`, inv.ID)

	if err != nil {
		// Non-critical, just log
		c.JSON(http.StatusOK, gin.H{
			"message":   "Invitation accepted successfully",
			"budget_id": inv.BudgetID,
			"warning":   "Failed to update invitation status",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":   "Invitation accepted successfully",
		"budget_id": inv.BudgetID,
	})
}

// CancelInvitation cancels a pending invitation
func (h *InvitationHandler) CancelInvitation(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")
	invitationID := c.Param("invitation_id")

	// Check if user is member of budget
	var exists bool
	err := h.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM budget_members
			WHERE budget_id = $1 AND user_id = $2
		)
	`, budgetID, userID).Scan(&exists)

	if err != nil || !exists {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}

	// Delete invitation
	result, err := h.DB.Exec(`
		DELETE FROM invitations
		WHERE id = $1 AND budget_id = $2 AND status = 'pending'
	`, invitationID, budgetID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to cancel invitation"})
		return
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Invitation not found or already processed"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Invitation cancelled successfully"})
}

// RemoveMember removes a member from a budget
func (h *InvitationHandler) RemoveMember(c *gin.Context) {
	userID := middleware.GetUserID(c)
	budgetID := c.Param("id")
	memberID := c.Param("member_id")

	// Check if user is owner
	var isOwner bool
	err := h.DB.QueryRow(`
		SELECT owner_id = $1
		FROM budgets
		WHERE id = $2
	`, userID, budgetID).Scan(&isOwner)

	if err != nil || !isOwner {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only owner can remove members"})
		return
	}

	// Can't remove owner
	if memberID == userID {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Owner cannot be removed"})
		return
	}

	// Remove member
	result, err := h.DB.Exec(`
		DELETE FROM budget_members
		WHERE budget_id = $1 AND user_id = $2
	`, budgetID, memberID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to remove member"})
		return
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Member not found"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Member removed successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\user.go
=========================================
package handlers

import (
	"database/sql"
	"net/http"

	"github.com/gin-gonic/gin"
	"budget-api/middleware"
	"budget-api/models"
	"budget-api/utils"
)

type UserHandler struct {
	DB *sql.DB
}

// GetProfile returns the current user's profile
func (h *UserHandler) GetProfile(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var user models.User
	// Updated query to fetch Avatar
	err := h.DB.QueryRow(`
		SELECT id, email, name, COALESCE(avatar, ''), totp_enabled, email_verified, created_at, updated_at
		FROM users
		WHERE id = $1
	`, userID).Scan(&user.ID, &user.Email, &user.Name, &user.Avatar, &user.TOTPEnabled,
		&user.EmailVerified, &user.CreatedAt, &user.UpdatedAt)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch profile"})
		return
	}

	c.JSON(http.StatusOK, user)
}

// UpdateProfileRequest struct to validate input
type UpdateProfileRequest struct {
	Name   string `json:"name" binding:"required"`
	Avatar string `json:"avatar"` // Optional: Base64 string or Gradient CSS
}

// UpdateProfile updates user profile information
func (h *UserHandler) UpdateProfile(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req UpdateProfileRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Update query including avatar
	_, err := h.DB.Exec(`
		UPDATE users
		SET name = $1, avatar = $2, updated_at = NOW()
		WHERE id = $3
	`, req.Name, req.Avatar, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update profile"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Profile updated successfully",
		"user": gin.H{
			"name":   req.Name,
			"avatar": req.Avatar,
		},
	})
}

// ChangePassword changes the user's password
func (h *UserHandler) ChangePassword(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req struct {
		CurrentPassword string `json:"current_password" binding:"required"`
		NewPassword     string `json:"new_password" binding:"required,min=8"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get current password hash
	var currentHash string
	err := h.DB.QueryRow(`
		SELECT password_hash FROM users WHERE id = $1
	`, userID).Scan(&currentHash)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify password"})
		return
	}

	// Verify current password
	if !utils.CheckPassword(req.CurrentPassword, currentHash) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Current password is incorrect"})
		return
	}

	// Hash new password
	newHash, err := utils.HashPassword(req.NewPassword)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		return
	}

	// Update password
	_, err = h.DB.Exec(`
		UPDATE users
		SET password_hash = $1, updated_at = NOW()
		WHERE id = $2
	`, newHash, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update password"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})
}

// SetupTOTP generates a TOTP secret for 2FA setup
func (h *UserHandler) SetupTOTP(c *gin.Context) {
	userID := middleware.GetUserID(c)
	email := middleware.GetUserEmail(c)

	if userID == "" || email == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	// Check if already enabled
	var totpEnabled bool
	err := h.DB.QueryRow(`
		SELECT totp_enabled FROM users WHERE id = $1
	`, userID).Scan(&totpEnabled)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check 2FA status"})
		return
	}

	if totpEnabled {
		c.JSON(http.StatusBadRequest, gin.H{"error": "2FA already enabled"})
		return
	}

	// Generate TOTP secret
	secret, qrURL, err := utils.GenerateTOTPSecret(email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate 2FA secret"})
		return
	}

	// Store secret (but don't enable yet, wait for verification)
	_, err = h.DB.Exec(`
		UPDATE users
		SET totp_secret = $1
		WHERE id = $2
	`, secret, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to store 2FA secret"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"secret":       secret,
		"qr_code_url":  qrURL,
		"instructions": "Scan the QR code with Google Authenticator or similar app, then verify with a code",
	})
}

// VerifyTOTP verifies and enables 2FA
func (h *UserHandler) VerifyTOTP(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req struct {
		Code string `json:"code" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get TOTP secret
	var secret sql.NullString
	err := h.DB.QueryRow(`
		SELECT totp_secret FROM users WHERE id = $1
	`, userID).Scan(&secret)

	if err != nil || !secret.Valid {
		c.JSON(http.StatusBadRequest, gin.H{"error": "2FA not set up"})
		return
	}

	// Verify code
	valid, err := utils.VerifyTOTP(secret.String, req.Code)
	if err != nil || !valid {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid 2FA code"})
		return
	}

	// Enable 2FA
	_, err = h.DB.Exec(`
		UPDATE users
		SET totp_enabled = TRUE, updated_at = NOW()
		WHERE id = $1
	`, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to enable 2FA"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "2FA enabled successfully",
		"enabled": true,
	})
}

// DisableTOTP disables 2FA
func (h *UserHandler) DisableTOTP(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req struct {
		Password string `json:"password" binding:"required"`
		Code     string `json:"code" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Verify password and get TOTP secret
	var passwordHash string
	var secret sql.NullString
	err := h.DB.QueryRow(`
		SELECT password_hash, totp_secret FROM users WHERE id = $1
	`, userID).Scan(&passwordHash, &secret)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify credentials"})
		return
	}

	// Check password
	if !utils.CheckPassword(req.Password, passwordHash) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid password"})
		return
	}

	// Verify TOTP code
	if secret.Valid {
		valid, err := utils.VerifyTOTP(secret.String, req.Code)
		if err != nil || !valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid 2FA code"})
			return
		}
	}

	// Disable 2FA
	_, err = h.DB.Exec(`
		UPDATE users
		SET totp_enabled = FALSE, totp_secret = NULL, updated_at = NOW()
		WHERE id = $1
	`, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to disable 2FA"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "2FA disabled successfully",
		"enabled": false,
	})
}

// DeleteAccount deletes the user's account
func (h *UserHandler) DeleteAccount(c *gin.Context) {
	userID := middleware.GetUserID(c)
	if userID == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var req struct {
		Password string `json:"password" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Verify password
	var passwordHash string
	err := h.DB.QueryRow(`
		SELECT password_hash FROM users WHERE id = $1
	`, userID).Scan(&passwordHash)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify password"})
		return
	}

	if !utils.CheckPassword(req.Password, passwordHash) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid password"})
		return
	}

	// Delete user (cascade will handle related data)
	_, err = h.DB.Exec(`DELETE FROM users WHERE id = $1`, userID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete account"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Account deleted successfully"})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\handlers\ws.go
=========================================
package handlers

import (
	"github.com/gin-gonic/gin"
	"github.com/olahol/melody"
	"log"
	"fmt"
)

type WSHandler struct {
	M *melody.Melody
}

func NewWSHandler() *WSHandler {
	m := melody.New()
	
	// Configurer la taille max des messages
	m.Config.MaxMessageSize = 1024 * 1024 

	return &WSHandler{M: m}
}

// HandleWS gÃ¨re la connexion WebSocket
func (h *WSHandler) HandleWS(c *gin.Context) {
	budgetID := c.Param("id")
	
	// On upgrade la requÃªte HTTP en WebSocket
	// On passe le budgetID dans le contexte de la session Melody
	h.M.HandleRequest(c.Writer, c.Request)
	
	h.M.HandleConnect(func(s *melody.Session) {
		// On stocke sur quel budget l'utilisateur est connectÃ©
		// Note: Dans une vraie app, on vÃ©rifierait le Token JWT ici aussi
		s.Set("budget_id", budgetID)
		log.Printf("Client connectÃ© au budget: %s", budgetID)
	})
}

// BroadcastUpdate envoie un signal Ã  tous les clients Ã©coutant ce budget
func (h *WSHandler) BroadcastUpdate(budgetID string, updateType string, userWhoUpdated string) {
	msg := []byte(fmt.Sprintf(`{"type": "%s", "user": "%s"}`, updateType, userWhoUpdated))
	
	h.M.BroadcastFilter(msg, func(q *melody.Session) bool {
		// On n'envoie qu'aux gens connectÃ©s sur CE budget
		id, exists := q.Get("budget_id")
		return exists && id == budgetID
	})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\middleware\auth.go
=========================================
package middleware

import (
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"budget-api/utils"
)

func AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
			c.Abort()
			return
		}

		token := parts[1]

		claims, err := utils.ValidateToken(token)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			c.Abort()
			return
		}

		c.Set("user_id", claims.UserID)
		c.Set("user_email", claims.Email)

		c.Next()
	}
}

func GetUserID(c *gin.Context) string {
	userID, exists := c.Get("user_id")
	if !exists {
		return ""
	}
	return userID.(string)
}

func GetUserEmail(c *gin.Context) string {
	email, exists := c.Get("user_email")
	if !exists {
		return ""
	}
	return email.(string)
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\middleware\ratelimit.go
=========================================
package middleware

import (
	"net/http"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
)

type rateLimiter struct {
	requests map[string]*clientRequest
	mu       sync.RWMutex
	limit    int
	window   time.Duration
}

type clientRequest struct {
	count     int
	resetTime time.Time
}

var limiter *rateLimiter

func init() {
	limiter = &rateLimiter{
		requests: make(map[string]*clientRequest),
		limit:    100,
		window:   time.Minute,
	}

	go func() {
		ticker := time.NewTicker(time.Minute)
		defer ticker.Stop()
		for range ticker.C {
			limiter.cleanup()
		}
	}()
}

func RateLimiter() gin.HandlerFunc {
	return func(c *gin.Context) {
		ip := c.ClientIP()

		limiter.mu.Lock()
		defer limiter.mu.Unlock()

		client, exists := limiter.requests[ip]
		now := time.Now()

		if !exists || now.After(client.resetTime) {
			limiter.requests[ip] = &clientRequest{
				count:     1,
				resetTime: now.Add(limiter.window),
			}
			c.Next()
			return
		}

		if client.count >= limiter.limit {
			c.JSON(http.StatusTooManyRequests, gin.H{
				"error":       "Rate limit exceeded",
				"retry_after": client.resetTime.Sub(now).Seconds(),
			})
			c.Abort()
			return
		}

		client.count++
		c.Next()
	}
}

func (rl *rateLimiter) cleanup() {
	rl.mu.Lock()
	defer rl.mu.Unlock()

	now := time.Now()
	for ip, client := range rl.requests {
		if now.After(client.resetTime) {
			delete(rl.requests, ip)
		}
	}
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\migration\migrate_yearly_data.go
=========================================
// migration/migrate_yearly_data.go
// Script de migration pour convertir l'ancien format yearlyData (noms de mois)
// vers le nouveau format (annÃ©es avec tableaux indexÃ©s)
//
// USAGE:
// 1. Ajouter ce fichier dans budget-api/migration/
// 2. Appeler MigrateAllBudgets() depuis main.go ou un endpoint admin
// 3. Ou exÃ©cuter comme commande CLI: go run migration/migrate_yearly_data.go

package migration

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"budget-api/utils"
)

// Mois franÃ§ais dans l'ordre (index 0 = Janvier)
var MONTHS = []string{
	"Janvier", "FÃ©vrier", "Mars", "Avril", "Mai", "Juin",
	"Juillet", "AoÃ»t", "Septembre", "Octobre", "Novembre", "DÃ©cembre",
}

// Map pour normaliser les variantes de noms de mois (encodage UTF-8 cassÃ©, etc.)
var MONTH_NAME_VARIANTS = map[string]string{
	// Standard
	"Janvier": "Janvier", "janvier": "Janvier",
	"FÃ©vrier": "FÃ©vrier", "fÃ©vrier": "FÃ©vrier", "Fevrier": "FÃ©vrier",
	"Mars": "Mars", "mars": "Mars",
	"Avril": "Avril", "avril": "Avril",
	"Mai": "Mai", "mai": "Mai",
	"Juin": "Juin", "juin": "Juin",
	"Juillet": "Juillet", "juillet": "Juillet",
	"AoÃ»t": "AoÃ»t", "aoÃ»t": "AoÃ»t", "Aout": "AoÃ»t",
	"Septembre": "Septembre", "septembre": "Septembre",
	"Octobre": "Octobre", "octobre": "Octobre",
	"Novembre": "Novembre", "novembre": "Novembre",
	"DÃ©cembre": "DÃ©cembre", "dÃ©cembre": "DÃ©cembre", "Decembre": "DÃ©cembre",
	// Encodage UTF-8 mojibake (caractÃ¨res mal dÃ©codÃ©s)
	"FÃƒÂ©vrier":  "FÃ©vrier",
	"AoÃƒÂ»t":     "AoÃ»t",
	"DÃƒÂ©cembre": "DÃ©cembre",
}

// Structure pour les donnÃ©es chiffrÃ©es en DB
type EncryptedData struct {
	Encrypted string `json:"encrypted"`
}

// Structure pour une annÃ©e de donnÃ©es (nouveau format)
type YearData struct {
	Months          []map[string]interface{} `json:"months"`
	Expenses        []map[string]interface{} `json:"expenses"`
	MonthComments   []string                 `json:"monthComments"`
	ExpenseComments []map[string]interface{} `json:"expenseComments"`
	DeletedMonths   []int                    `json:"deletedMonths"`
}

// Normalise un nom de mois (gÃ¨re les variantes d'encodage)
func normalizeMonthName(monthKey string) (string, bool) {
	if normalized, ok := MONTH_NAME_VARIANTS[monthKey]; ok {
		return normalized, true
	}
	return "", false
}

// VÃ©rifie si une clÃ© est un nom de mois
func isMonthName(key string) bool {
	_, ok := normalizeMonthName(key)
	return ok
}

// Retourne l'index d'un mois (0-11)
func getMonthIndex(monthName string) int {
	normalized, ok := normalizeMonthName(monthName)
	if !ok {
		return -1
	}
	for i, m := range MONTHS {
		if m == normalized {
			return i
		}
	}
	return -1
}

// VÃ©rifie si yearlyData est dans l'ancien format (noms de mois comme clÃ©s)
func isLegacyFormat(yearlyData map[string]interface{}) bool {
	for key := range yearlyData {
		if isMonthName(key) {
			return true
		}
	}
	return false
}

// VÃ©rifie si yearlyData est dÃ©jÃ  dans le nouveau format (annÃ©es avec .months)
func isNewFormat(yearlyData map[string]interface{}) bool {
	for key, value := range yearlyData {
		// VÃ©rifie si la clÃ© est une annÃ©e (4 chiffres)
		if len(key) == 4 && key[0] >= '0' && key[0] <= '9' {
			if yearMap, ok := value.(map[string]interface{}); ok {
				if _, hasMonths := yearMap["months"]; hasMonths {
					return true
				}
			}
		}
	}
	return false
}

// CrÃ©e une structure d'annÃ©e vide
func createEmptyYearData() YearData {
	return YearData{
		Months:          make([]map[string]interface{}, 12),
		Expenses:        make([]map[string]interface{}, 12),
		MonthComments:   make([]string, 12),
		ExpenseComments: make([]map[string]interface{}, 12),
		DeletedMonths:   []int{},
	}
}

// Migre les donnÃ©es d'un budget de l'ancien vers le nouveau format
func MigrateBudgetData(data map[string]interface{}) (map[string]interface{}, bool, error) {
	yearlyData, ok := data["yearlyData"].(map[string]interface{})
	if !ok || yearlyData == nil {
		return data, false, nil // Pas de yearlyData, rien Ã  migrer
	}

	// VÃ©rifier si dÃ©jÃ  au nouveau format
	if isNewFormat(yearlyData) {
		log.Println("  â†’ DonnÃ©es dÃ©jÃ  au nouveau format, skip")
		return data, false, nil
	}

	// VÃ©rifier si c'est l'ancien format
	if !isLegacyFormat(yearlyData) {
		log.Println("  â†’ Format non reconnu, skip")
		return data, false, nil
	}

	log.Println("  â†’ Ancien format dÃ©tectÃ©, migration en cours...")

	// DÃ©terminer l'annÃ©e cible
	targetYear := time.Now().Year()
	if cy, ok := data["currentYear"].(float64); ok {
		targetYear = int(cy)
	}
	yearKey := fmt.Sprintf("%d", targetYear)

	// CrÃ©er la nouvelle structure
	newYearlyData := make(map[string]interface{})
	newYearData := createEmptyYearData()

	// Initialiser les tableaux
	for i := 0; i < 12; i++ {
		newYearData.Months[i] = make(map[string]interface{})
		newYearData.Expenses[i] = make(map[string]interface{})
		newYearData.MonthComments[i] = ""
		newYearData.ExpenseComments[i] = make(map[string]interface{})
	}

	// Migrer yearlyData (allocations projets)
	for monthKey, monthData := range yearlyData {
		idx := getMonthIndex(monthKey)
		if idx >= 0 && idx < 12 {
			if md, ok := monthData.(map[string]interface{}); ok {
				// VÃ©rifier que ce n'est pas une structure year-based accidentellement
				if _, hasMonths := md["months"]; !hasMonths {
					newYearData.Months[idx] = md
				}
			}
		}
	}

	// Migrer yearlyExpenses si prÃ©sent
	if yearlyExpenses, ok := data["yearlyExpenses"].(map[string]interface{}); ok {
		for monthKey, expenseData := range yearlyExpenses {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if ed, ok := expenseData.(map[string]interface{}); ok {
					newYearData.Expenses[idx] = ed
				}
			}
		}
	}

	// Migrer monthComments si prÃ©sent
	if monthComments, ok := data["monthComments"].(map[string]interface{}); ok {
		for monthKey, comment := range monthComments {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if c, ok := comment.(string); ok {
					newYearData.MonthComments[idx] = c
				}
			}
		}
	}

	// Migrer projectComments si prÃ©sent
	if projectComments, ok := data["projectComments"].(map[string]interface{}); ok {
		for monthKey, comments := range projectComments {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if pc, ok := comments.(map[string]interface{}); ok {
					newYearData.ExpenseComments[idx] = pc
				}
			}
		}
	}

	// Migrer oneTimeIncomes si prÃ©sent (ancien format: { "Janvier": 500, ... })
	if oneTimeIncomes, ok := data["oneTimeIncomes"].(map[string]interface{}); ok {
		newOneTimeIncomes := make(map[string]interface{})
		newYearIncomes := make([]map[string]interface{}, 12)
		
		for i := 0; i < 12; i++ {
			newYearIncomes[i] = map[string]interface{}{"amount": 0, "description": ""}
		}

		for monthKey, income := range oneTimeIncomes {
			idx := getMonthIndex(monthKey)
			if idx >= 0 && idx < 12 {
				if amount, ok := income.(float64); ok {
					newYearIncomes[idx] = map[string]interface{}{
						"amount":      amount,
						"description": "",
					}
				}
			}
		}

		newOneTimeIncomes[yearKey] = newYearIncomes
		data["oneTimeIncomes"] = newOneTimeIncomes
	}

	// Convertir YearData en map pour JSON
	yearDataMap := map[string]interface{}{
		"months":          newYearData.Months,
		"expenses":        newYearData.Expenses,
		"monthComments":   newYearData.MonthComments,
		"expenseComments": newYearData.ExpenseComments,
		"deletedMonths":   newYearData.DeletedMonths,
	}
	newYearlyData[yearKey] = yearDataMap

	// Mettre Ã  jour les donnÃ©es
	data["yearlyData"] = newYearlyData
	data["version"] = "2.3-migrated"
	data["lastUpdated"] = time.Now().Format(time.RFC3339)

	// Supprimer les anciens champs obsolÃ¨tes
	delete(data, "yearlyExpenses")
	delete(data, "monthComments")
	delete(data, "projectComments")

	return data, true, nil
}

// MigrateBudgetRecord migre un enregistrement de la table budget_data
func MigrateBudgetRecord(ctx context.Context, db *sql.DB, budgetID string, rawJSON []byte) error {
	// 1. DÃ©crypter si nÃ©cessaire
	var data map[string]interface{}
	var wrapper EncryptedData

	if err := json.Unmarshal(rawJSON, &wrapper); err == nil && wrapper.Encrypted != "" {
		// DonnÃ©es chiffrÃ©es
		decryptedBytes, err := utils.Decrypt(wrapper.Encrypted)
		if err != nil {
			return fmt.Errorf("failed to decrypt: %w", err)
		}
		if err := json.Unmarshal(decryptedBytes, &data); err != nil {
			return fmt.Errorf("failed to unmarshal decrypted data: %w", err)
		}
	} else {
		// DonnÃ©es non chiffrÃ©es (legacy)
		if err := json.Unmarshal(rawJSON, &data); err != nil {
			return fmt.Errorf("failed to unmarshal data: %w", err)
		}
	}

	// 2. Migrer les donnÃ©es
	migratedData, wasMigrated, err := MigrateBudgetData(data)
	if err != nil {
		return fmt.Errorf("migration failed: %w", err)
	}

	if !wasMigrated {
		return nil // Rien Ã  faire
	}

	// 3. Re-chiffrer et sauvegarder
	migratedJSON, err := json.Marshal(migratedData)
	if err != nil {
		return fmt.Errorf("failed to marshal migrated data: %w", err)
	}

	encryptedString, err := utils.Encrypt(migratedJSON)
	if err != nil {
		return fmt.Errorf("failed to encrypt: %w", err)
	}

	newWrapper := EncryptedData{Encrypted: encryptedString}
	storageJSON, err := json.Marshal(newWrapper)
	if err != nil {
		return fmt.Errorf("failed to marshal wrapper: %w", err)
	}

	// 4. Mettre Ã  jour en base
	updateQuery := `
		UPDATE budget_data
		SET data = $1, version = version + 1, updated_at = $2
		WHERE budget_id = $3
	`
	_, err = db.ExecContext(ctx, updateQuery, storageJSON, time.Now(), budgetID)
	if err != nil {
		return fmt.Errorf("failed to update DB: %w", err)
	}

	log.Printf("  âœ… Budget %s migrÃ© avec succÃ¨s", budgetID)
	return nil
}

// MigrateAllBudgets migre tous les budgets de la base de donnÃ©es
func MigrateAllBudgets(db *sql.DB) error {
	ctx := context.Background()

	log.Println("ðŸš€ DÃ©marrage de la migration des donnÃ©es budget...")
	log.Println("========================================")

	// RÃ©cupÃ©rer tous les budgets avec leurs donnÃ©es
	query := `
		SELECT bd.budget_id, bd.data, b.name
		FROM budget_data bd
		JOIN budgets b ON bd.budget_id = b.id
		ORDER BY bd.updated_at DESC
	`

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to query budgets: %w", err)
	}
	defer rows.Close()

	var migrated, skipped, errors int

	for rows.Next() {
		var budgetID string
		var rawJSON []byte
		var budgetName string

		if err := rows.Scan(&budgetID, &rawJSON, &budgetName); err != nil {
			log.Printf("âŒ Erreur scan: %v", err)
			errors++
			continue
		}

		log.Printf("\nðŸ“¦ Budget: %s (%s)", budgetName, budgetID)

		if err := MigrateBudgetRecord(ctx, db, budgetID, rawJSON); err != nil {
			log.Printf("  âŒ Erreur: %v", err)
			errors++
		} else {
			migrated++
		}
	}

	log.Println("\n========================================")
	log.Printf("ðŸ“Š RÃ©sultat: %d migrÃ©s, %d skippÃ©s, %d erreurs", migrated, skipped, errors)
	log.Println("âœ… Migration terminÃ©e!")

	return nil
}

// MigrateSingleBudget migre un seul budget par son ID
func MigrateSingleBudget(db *sql.DB, budgetID string) error {
	ctx := context.Background()

	query := `SELECT data FROM budget_data WHERE budget_id = $1`
	var rawJSON []byte

	if err := db.QueryRowContext(ctx, query, budgetID).Scan(&rawJSON); err != nil {
		if err == sql.ErrNoRows {
			return fmt.Errorf("budget %s not found", budgetID)
		}
		return err
	}

	return MigrateBudgetRecord(ctx, db, budgetID, rawJSON)
}




=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\banking.go
=========================================
package models

import (
	"time"
)

type BankConnection struct {
	ID                   string        `json:"id"`
	UserID               string        `json:"user_id"`
	InstitutionID        string        `json:"institution_id"`
	InstitutionName      string        `json:"institution_name"`
	ProviderConnectionID string        `json:"-"` // Internal use only
	Status               string        `json:"status"`
	ExpiresAt            time.Time     `json:"expires_at"`
	CreatedAt            time.Time     `json:"created_at"`
	UpdatedAt            time.Time     `json:"updated_at"`
	Accounts             []BankAccount `json:"accounts,omitempty"`
}

type BankAccount struct {
	ID                string    `json:"id"`
	ConnectionID      string    `json:"connection_id"`
	ExternalAccountID string    `json:"-"` // Internal use only
	Name              string    `json:"name"`
	Mask              string    `json:"mask"`
	Currency          string    `json:"currency"`
	Balance           float64   `json:"balance"`
	IsSavingsPool     bool      `json:"is_savings_pool"` // Critical for Reality Check
	LastSyncedAt      time.Time `json:"last_synced_at"`
}

// Request to toggle the pool status
type UpdateAccountPoolRequest struct {
	IsSavingsPool bool `json:"is_savings_pool"`
}

// Response for Reality Check
type RealityCheckSummary struct {
	TotalRealCash float64       `json:"total_real_cash"`
	Accounts      []BankAccount `json:"accounts"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\budget.go
=========================================
package models

import (
	"encoding/json"
	"time"
)

type Budget struct {
	ID        string    `json:"id"`
	Name      string    `json:"name" binding:"required"`
	OwnerID   string    `json:"owner_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	IsOwner   bool          `json:"is_owner"`   // To store the CASE statement result
	OwnerName string        `json:"owner_name"` // To store the user.name from the JOIN
	Members   []BudgetMember `json:"members"`    // To hold the list of members
}

type BudgetMember struct {
	ID          string          `json:"id"`
	BudgetID    string          `json:"budget_id"`
	UserID      string          `json:"user_id"`
	User        *User           `json:"user,omitempty"`
	Role        string          `json:"role"`
	Permissions json.RawMessage `json:"permissions"`
	JoinedAt    time.Time       `json:"joined_at"`
	UserName  string `json:"user_name"`  // To store u.name from the JOIN (line 236 in service)
	UserEmail string `json:"user_email"` // To store u.email from the JOIN (line 237 in service)
}

type BudgetData struct {
	ID        string          `json:"id"`
	BudgetID  string          `json:"budget_id"`
	Data      json.RawMessage `json:"data"`
	Version   int             `json:"version"`
	UpdatedBy string          `json:"updated_by"`
	UpdatedAt time.Time       `json:"updated_at"`
}

type CreateBudgetRequest struct {
	Name string `json:"name" binding:"required"`
}

type UpdateBudgetDataRequest struct {
	Data json.RawMessage `json:"data" binding:"required"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\charge.go
=========================================
package models

// Charge reprÃ©sente une dÃ©pense rÃ©currente ou une transaction Ã  catÃ©goriser
type Charge struct {
	ID       string  `json:"id"`
	Label    string  `json:"label"`
	Amount   float64 `json:"amount"`
	Category string  `json:"category"` // ex: "ENERGY", "MOBILE"
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\invitation.go
=========================================
package models

import (
	"time"
)

type Invitation struct {
	ID        string    `json:"id"`
	BudgetID  string    `json:"budget_id"`
	Email     string    `json:"email" binding:"required,email"`
	InvitedBy string    `json:"invited_by"`
	Token     string    `json:"token"`
	Status    string    `json:"status"`
	ExpiresAt time.Time `json:"expires_at"`
	CreatedAt time.Time `json:"created_at"`
}

type InvitationRequest struct {
	Email string `json:"email" binding:"required,email"`
}

type AcceptInvitationRequest struct {
	Token string `json:"token" binding:"required"`
}

type InvitationResponse struct {
	Invitation Invitation `json:"invitation"`
	Budget     Budget     `json:"budget"`
	InviterName string    `json:"inviter_name"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\suggestion.go
=========================================
package models

// Une suggestion d'Ã©conomie liÃ©e Ã  une charge spÃ©cifique
type Suggestion struct {
    ID              string  `json:"id"`
    ChargeID        string  `json:"charge_id"`        // L'ID de la dÃ©pense concernÃ©e
    Type            string  `json:"type"`             // ex: "MOBILE_OFFER", "ENERGY_OFFER"
    Title           string  `json:"title"`            // ex: "Forfait mobile Ã©levÃ©"
    Message         string  `json:"message"`          // ex: "Vous payez 70â‚¬/mois. La moyenne est Ã  20â‚¬."
    PotentialSavings float64 `json:"potential_savings"` // ex: 600.00 (par an)
    ActionLink      string  `json:"action_link"`      // Lien d'affiliation direct (ex: Sosh)
    CanBeContacted  bool    `json:"can_be_contacted"` // Si TRUE, affiche le bouton "ÃŠtre rappelÃ©"
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\models\user.go
=========================================
package models

import (
	"time"
)

type User struct {
	ID            string    `json:"id"`
	Email         string    `json:"email" binding:"required,email"`
	PasswordHash  string    `json:"-"`
	Name          string    `json:"name" binding:"required"`
	Avatar        string    `json:"avatar"`
	TOTPSecret    *string   `json:"-"`
	TOTPEnabled   bool      `json:"totp_enabled"`
	EmailVerified bool      `json:"email_verified"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

type SignupRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required,min=8"`
	Name     string `json:"name" binding:"required"`
}

type LoginRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required"`
	TOTPCode string `json:"totp_code"`
}

type AuthResponse struct {
	User         User   `json:"user"`
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\routes\routes.go
=========================================
package routes

import (
	"database/sql"
	"budget-api/handlers"
	"budget-api/services"
	"github.com/gin-gonic/gin"
)

// SetupAuthRoutes sets up public authentication routes.
func SetupAuthRoutes(rg *gin.RouterGroup, db *sql.DB) {
	authHandler := &handlers.AuthHandler{DB: db}
	rg.POST("/auth/signup", authHandler.Signup)
	rg.POST("/auth/login", authHandler.Login)
	rg.GET("/auth/verify", authHandler.VerifyEmail)
	rg.POST("/auth/verify/resend", authHandler.ResendVerification)
}

// SetupBudgetRoutes sets up protected budget and related routes.
func SetupBudgetRoutes(rg *gin.RouterGroup, db *sql.DB) {
	budgetService := services.NewBudgetService(db)
	emailService := services.NewEmailService()
	h := handlers.NewHandler(budgetService, emailService)

	rg.GET("/budgets", h.GetBudgets)
	rg.POST("/budgets", h.CreateBudget)
	rg.GET("/budgets/:id", h.GetBudget)
	rg.PUT("/budgets/:id", h.UpdateBudget)
	rg.DELETE("/budgets/:id", h.DeleteBudget)
	rg.GET("/budgets/:id/data", h.GetBudgetData)
	rg.PUT("/budgets/:id/data", h.UpdateBudgetData)
	rg.POST("/budgets/:id/invite", h.InviteMember)
	rg.POST("/invitations/accept", h.AcceptInvitation)
}

func SetupUserRoutes(rg *gin.RouterGroup, db *sql.DB) {
	userHandler := &handlers.UserHandler{DB: db}
	rg.GET("/user/profile", userHandler.GetProfile)
	rg.PUT("/user/profile", userHandler.UpdateProfile)
	rg.POST("/user/password", userHandler.ChangePassword)
	rg.POST("/user/2fa/setup", userHandler.SetupTOTP)
	rg.POST("/user/2fa/verify", userHandler.VerifyTOTP)
	rg.POST("/user/2fa/disable", userHandler.DisableTOTP)
	rg.DELETE("/user/account", userHandler.DeleteAccount)
}

func SetupInvitationRoutes(rg *gin.RouterGroup, db *sql.DB) {
	invitationHandler := &handlers.InvitationHandler{DB: db}
	rg.GET("/budgets/:id/invitations", invitationHandler.GetInvitations)
	rg.DELETE("/budgets/:id/invitations/:invitation_id", invitationHandler.CancelInvitation)
	rg.DELETE("/budgets/:id/members/:member_id", invitationHandler.RemoveMember)
}

// SetupBankingRoutes reorganized for Budget Isolation
func SetupBankingRoutes(rg *gin.RouterGroup, db *sql.DB) {
	bankingHandler := handlers.NewBankingHandler(db)
	bridgeHandler := handlers.NewBridgeHandler(db)
	catHandler := handlers.NewCategorizationHandler(db)

	// Banking routes Scoped by Budget
	// GET /api/v1/budgets/:id/banking/connections
	rg.GET("/budgets/:id/banking/connections", bankingHandler.GetConnections)
	rg.POST("/budgets/:id/banking/sync", bridgeHandler.SyncAccounts)
	
	// Global Banking Actions (Bridge specific, not strictly budget-scoped but used in context)
	rg.POST("/banking/bridge/connect", bridgeHandler.CreateConnection)
	rg.POST("/banking/bridge/refresh", bridgeHandler.RefreshBalances)
	rg.GET("/banking/bridge/transactions", bridgeHandler.GetTransactions)
	
	// Account Specific
	rg.DELETE("/banking/connections/:connection_id", bankingHandler.DeleteConnection)
	rg.PUT("/banking/accounts/:account_id", bankingHandler.UpdateAccountPool)

	rg.POST("/categorize", catHandler.CategorizeLabel)
    rg.GET("/banking/bridge/banks", bridgeHandler.GetBanks)
}

func SetupAdminRoutes(rg *gin.RouterGroup, db *sql.DB) {
	adminHandler := &handlers.AdminHandler{DB: db}
	
	// Migration endpoints
	rg.POST("/admin/migrate-budgets", adminHandler.MigrateAllBudgets)
	rg.POST("/admin/migrate-budget/:id", adminHandler.MigrateSingleBudget)
}

// SetupEnableBankingRoutes configure les routes Enable Banking
func SetupEnableBankingRoutes(rg *gin.RouterGroup, db *sql.DB) {
	handler := handlers.NewEnableBankingHandler(db)

	// Liste des banques disponibles
	rg.GET("/banking/enablebanking/banks", handler.GetBanks)

	// Connexion d'une banque (crÃ©ation auth request)
	rg.POST("/banking/enablebanking/connect", handler.CreateConnection)

	// Callback aprÃ¨s autorisation
	rg.GET("/banking/enablebanking/callback", handler.HandleCallback)

	// â­ FIX: Route manquante ajoutÃ©e â­
	// RÃ©cupÃ©ration des connexions d'un budget
	rg.GET("/budgets/:id/banking/enablebanking/connections", handler.GetConnections)

	// Synchronisation des comptes dans un budget
	rg.POST("/budgets/:id/banking/enablebanking/sync", handler.SyncAccounts)

	// RafraÃ®chissement des soldes
	rg.POST("/banking/enablebanking/refresh", handler.RefreshBalances)

	// RÃ©cupÃ©ration des transactions
	rg.GET("/banking/enablebanking/transactions", handler.GetTransactions)

	// Suppression d'une connexion
	rg.DELETE("/banking/enablebanking/connections/:id", handler.DeleteConnection)
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\ai_categorizer.go
=========================================
package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

type AICategorizer struct {
	apiKey string
	client *http.Client
}

func NewAICategorizer() *AICategorizer {
	return &AICategorizer{
		apiKey: os.Getenv("ANTHROPIC_API_KEY"), // ClÃ© Claude
		client: &http.Client{Timeout: 10 * time.Second},
	}
}

// Structures pour l'API Anthropic
type anthropicMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type anthropicRequest struct {
	Model     string             `json:"model"`
	MaxTokens int                `json:"max_tokens"`
	Messages  []anthropicMessage `json:"messages"`
}

type anthropicResponse struct {
	Content []struct {
		Text string `json:"text"`
	} `json:"content"`
	Error *struct {
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

// PredictCategory demande Ã  Claude de classifier un libellÃ©
func (s *AICategorizer) PredictCategory(label string) (string, error) {
	if s.apiKey == "" {
		// Fallback silencieux si pas de clÃ© configurÃ©e
		return "OTHER", fmt.Errorf("ANTHROPIC_API_KEY not set")
	}

	prompt := fmt.Sprintf(`
    Tu es un expert bancaire. Analyse le libellÃ© : "%s".
    CatÃ©gorise-le STRICTEMENT dans une seule de ces catÃ©gories (en majuscules) :
    - ENERGY (Ã©lectricitÃ©, gaz, eau)
    - MOBILE (forfait tÃ©lÃ©phone)
    - INTERNET (box, fibre, hÃ©bergement)
    - INSURANCE (assurance)
    - BANK (frais bancaires)
    - LOAN (crÃ©dit)
    - FOOD (courses, resto)
    - LEISURE (loisirs, streaming, sport)
    - TRANSPORT (essence, pÃ©age, transport)
    - HOUSING (loyer, travaux)
    - SHOPPING (achats divers)
    - HEALTH (santÃ©)
    - SUBSCRIPTION (abonnements divers)
    - OTHER (si incertain)

    RÃ©ponds UNIQUEMENT par le mot clÃ©. Pas de phrase.`, label)

	reqBody := anthropicRequest{
		Model:     "claude-3-haiku-20240307", // ModÃ¨le rapide et Ã©conomique
		MaxTokens: 10,
		Messages: []anthropicMessage{
			{Role: "user", Content: prompt},
		},
	}

	jsonData, _ := json.Marshal(reqBody)

	req, err := http.NewRequest("POST", "https://api.anthropic.com/v1/messages", bytes.NewBuffer(jsonData))
	if err != nil {
		return "OTHER", err
	}

	req.Header.Set("x-api-key", s.apiKey)
	req.Header.Set("anthropic-version", "2023-06-01")
	req.Header.Set("content-type", "application/json")

	resp, err := s.client.Do(req)
	if err != nil {
		return "OTHER", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return "OTHER", fmt.Errorf("anthropic error %d: %s", resp.StatusCode, string(body))
	}

	var result anthropicResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "OTHER", err
	}

	if len(result.Content) > 0 {
		category := strings.TrimSpace(strings.ToUpper(result.Content[0].Text))
		return category, nil
	}

	return "OTHER", nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\banking.go
=========================================
package services

import (
	"context"
	"database/sql"
	"time"

	"budget-api/models"
	"budget-api/utils"

	"github.com/google/uuid"
)

type BankingService struct {
	db *sql.DB
}

func NewBankingService(db *sql.DB) *BankingService {
	return &BankingService{db: db}
}

// GetBudgetConnections renvoie les connexions pour un BUDGET spÃ©cifique
func (s *BankingService) GetBudgetConnections(ctx context.Context, budgetID string) ([]models.BankConnection, error) {
	query := `
		SELECT id, institution_id, institution_name, status, expires_at, created_at
		FROM bank_connections
		WHERE budget_id = $1
		ORDER BY created_at DESC
	`

	rows, err := s.db.QueryContext(ctx, query, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var connections []models.BankConnection
	for rows.Next() {
		var conn models.BankConnection
		err := rows.Scan(&conn.ID, &conn.InstitutionID, &conn.InstitutionName, &conn.Status, &conn.ExpiresAt, &conn.CreatedAt)
		if err != nil {
			return nil, err
		}

		accounts, err := s.GetAccountsByConnection(ctx, conn.ID)
		if err == nil {
			conn.Accounts = accounts
		}

		connections = append(connections, conn)
	}

	return connections, nil
}

// GetAccountsByConnection fetches accounts for a specific connection
func (s *BankingService) GetAccountsByConnection(ctx context.Context, connectionID string) ([]models.BankAccount, error) {
	query := `
		SELECT id, connection_id, name, mask, currency, balance, is_savings_pool, last_synced_at
		FROM bank_accounts
		WHERE connection_id = $1
		ORDER BY name
	`
	rows, err := s.db.QueryContext(ctx, query, connectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var accounts []models.BankAccount
	for rows.Next() {
		var acc models.BankAccount
		err := rows.Scan(
			&acc.ID, &acc.ConnectionID, &acc.Name, &acc.Mask,
			&acc.Currency, &acc.Balance, &acc.IsSavingsPool, &acc.LastSyncedAt,
		)
		if err != nil {
			continue
		}
		accounts = append(accounts, acc)
	}
	return accounts, nil
}

// GetRealityCheckSum calcule le total pour un BUDGET spÃ©cifique
func (s *BankingService) GetRealityCheckSum(ctx context.Context, budgetID string) (float64, error) {
	query := `
		SELECT COALESCE(SUM(ba.balance), 0)
		FROM bank_accounts ba
		JOIN bank_connections bc ON ba.connection_id = bc.id
		WHERE bc.budget_id = $1 AND ba.is_savings_pool = TRUE
	`
	var total float64
	err := s.db.QueryRowContext(ctx, query, budgetID).Scan(&total)
	return total, err
}

// UpdateAccountPool toggles whether an account counts towards the Reality Check
func (s *BankingService) UpdateAccountPool(ctx context.Context, accountID string, isSavingsPool bool) error {
	_, err := s.db.ExecContext(ctx, "UPDATE bank_accounts SET is_savings_pool = $1 WHERE id = $2", isSavingsPool, accountID)
	return err
}

// DeleteConnection removes a connection and its accounts
func (s *BankingService) DeleteConnection(ctx context.Context, connectionID string) error {
	return utils.WithTransaction(s.db, func(tx *sql.Tx) error {
		if _, err := tx.ExecContext(ctx, "DELETE FROM bank_accounts WHERE connection_id = $1", connectionID); err != nil {
			return err
		}
		if _, err := tx.ExecContext(ctx, "DELETE FROM bank_connections WHERE id = $1", connectionID); err != nil {
			return err
		}
		return nil
	})
}

// SaveConnectionWithTokens saves the connection LINKED TO A BUDGET (Upsert Logic)
func (s *BankingService) SaveConnectionWithTokens(ctx context.Context, userID, budgetID, institutionID, institutionName, providerConnID, accessToken, refreshToken string, expiresAt time.Time) (string, error) {
	// 1. Encrypt Tokens
	encAccess, err := utils.Encrypt([]byte(accessToken))
	if err != nil {
		return "", err
	}
	encRefresh, err := utils.Encrypt([]byte(refreshToken))
	if err != nil {
		return "", err
	}

    // 2. Check if connection exists for this budget (Upsert Logic)
    var existingID string
    err = s.db.QueryRowContext(ctx, 
        "SELECT id FROM bank_connections WHERE provider_connection_id = $1 AND budget_id = $2", 
        providerConnID, budgetID).Scan(&existingID)

    if err == nil {
        // UPDATE Existing
        _, err = s.db.ExecContext(ctx, `
            UPDATE bank_connections 
            SET encrypted_access_token = $1, encrypted_refresh_token = $2, expires_at = $3, updated_at = NOW(), status = 'active', institution_name = $4
            WHERE id = $5
        `, encAccess, encRefresh, expiresAt, institutionName, existingID)
        return existingID, err
    }

    // INSERT New
	connID := uuid.New().String()
	query := `
		INSERT INTO bank_connections (id, user_id, budget_id, institution_id, institution_name, provider_connection_id, encrypted_access_token, encrypted_refresh_token, expires_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
	`
	_, err = s.db.ExecContext(ctx, query, connID, userID, budgetID, institutionID, institutionName, providerConnID, encAccess, encRefresh, expiresAt)
	return connID, err
}

// SaveAccount saves a bank account using UPSERT logic (Update if exists, Insert if new)
func (s *BankingService) SaveAccount(ctx context.Context, connID, externalID, name, mask, currency string, balance float64) error {
	// Syntaxe PostgreSQL pour "Si conflit sur (connection_id, external_account_id), alors met Ã  jour"
	// Cela nÃ©cessite que la contrainte UNIQUE soit bien prÃ©sente en base (voir config/database.go)
	query := `
		INSERT INTO bank_accounts (id, connection_id, external_account_id, name, mask, currency, balance, last_synced_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
		ON CONFLICT (connection_id, external_account_id) 
		DO UPDATE SET 
			balance = EXCLUDED.balance,
			name = EXCLUDED.name,
			last_synced_at = NOW()
	`
	
	// On gÃ©nÃ¨re un nouvel UUID, mais il ne sera utilisÃ© que si c'est une nouvelle insertion
	_, err := s.db.ExecContext(ctx, query, uuid.New().String(), connID, externalID, name, mask, currency, balance)
	return err
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\bridge.go
=========================================
package services

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"
)

type BridgeService struct {
	ClientID     string
	ClientSecret string
	BaseURL      string
	Client       *http.Client
}

func NewBridgeService() *BridgeService {
	// Security: Trim spaces to prevent 401 errors
	return &BridgeService{
		ClientID:     strings.TrimSpace(os.Getenv("BRIDGE_CLIENT_ID")),
		ClientSecret: strings.TrimSpace(os.Getenv("BRIDGE_CLIENT_SECRET")),
		BaseURL:      "https://api.bridgeapi.io/v3", // V3 Base URL
		Client:       &http.Client{Timeout: 30 * time.Second},
	}
}

// hashEmail creates a safe external_user_id from an email
func hashEmail(email string) string {
	hash := sha256.Sum256([]byte(strings.ToLower(strings.TrimSpace(email))))
	return hex.EncodeToString(hash[:])
}

func (s *BridgeService) setHeaders(req *http.Request) {
	req.Header.Set("Content-Type", "application/json")
	// Utilisation de la version spÃ©cifiÃ©e dans votre code
	req.Header.Set("Bridge-Version", "2025-01-15") 
	req.Header.Set("Client-Id", s.ClientID)
	req.Header.Set("Client-Secret", s.ClientSecret)
}

// 1. Get or Create User & Generate Token
func (s *BridgeService) getOrCreateUserToken(ctx context.Context, userEmail string) (string, error) {
	externalID := hashEmail(userEmail)
	var userUUID string

	// --- STEP A: Check if user exists (List Users) ---
	listURL := fmt.Sprintf("%s/aggregation/users?external_user_id=%s", s.BaseURL, externalID)
	listReq, _ := http.NewRequestWithContext(ctx, "GET", listURL, nil)
	s.setHeaders(listReq)

	listResp, err := s.Client.Do(listReq)
	if err != nil {
		return "", fmt.Errorf("connection error checking user: %w", err)
	}
	defer listResp.Body.Close()

	if listResp.StatusCode == 200 {
		var listRes struct {
			Resources []struct {
				Uuid string `json:"uuid"`
			} `json:"resources"`
		}
		if err := json.NewDecoder(listResp.Body).Decode(&listRes); err == nil && len(listRes.Resources) > 0 {
			userUUID = listRes.Resources[0].Uuid
		}
	}

	// --- STEP B: Create User if not found ---
	if userUUID == "" {
		createPayload := map[string]string{
			"external_user_id": externalID,
		}
		body, _ := json.Marshal(createPayload)
		createReq, _ := http.NewRequestWithContext(ctx, "POST", s.BaseURL+"/aggregation/users", bytes.NewBuffer(body))
		s.setHeaders(createReq)

		createResp, err := s.Client.Do(createReq)
		if err != nil {
			return "", fmt.Errorf("user creation request failed: %w", err)
		}
		defer createResp.Body.Close()

		if createResp.StatusCode == 201 {
			var createRes struct {
				Uuid string `json:"uuid"`
			}
			if err := json.NewDecoder(createResp.Body).Decode(&createRes); err == nil {
				userUUID = createRes.Uuid
			}
		} else {
			b, _ := io.ReadAll(createResp.Body)
			log.Printf("[Bridge Error] Create User Failed: %s", string(b))
			if createResp.StatusCode == 409 {
				return "", fmt.Errorf("user conflict (409)")
			}
			return "", fmt.Errorf("bridge user creation failed (%d): %s", createResp.StatusCode, string(b))
		}
	}

	if userUUID == "" {
		return "", fmt.Errorf("could not resolve user_uuid")
	}

	// --- STEP C: Generate Token ---
	authPayload := map[string]string{"user_uuid": userUUID}
	authBody, _ := json.Marshal(authPayload)
	
	authReq, _ := http.NewRequestWithContext(ctx, "POST", s.BaseURL+"/aggregation/authorization/token", bytes.NewBuffer(authBody))
	s.setHeaders(authReq)

	authResp, err := s.Client.Do(authReq)
	if err != nil {
		return "", fmt.Errorf("token request error: %w", err)
	}
	defer authResp.Body.Close()

	if authResp.StatusCode != 200 {
		b, _ := io.ReadAll(authResp.Body)
		log.Printf("[Bridge Error] Token Failed: %s", string(b))
		return "", fmt.Errorf("token error (%d): %s", authResp.StatusCode, string(b))
	}

	var tokenRes struct {
		AccessToken string `json:"access_token"`
	}
	if err := json.NewDecoder(authResp.Body).Decode(&tokenRes); err != nil {
		return "", fmt.Errorf("token decode error: %w", err)
	}

	return tokenRes.AccessToken, nil
}

// 2. Create Connect Session (VERSION SIMPLE : 2 Arguments)
func (s *BridgeService) CreateConnectItem(ctx context.Context, userEmail string) (string, error) {
	accessToken, err := s.getOrCreateUserToken(ctx, userEmail)
	if err != nil {
		return "", err
	}

	// On n'envoie QUE l'email pour Ã©viter l'erreur "Invalid body content"
	payload := map[string]interface{}{
		"user_email": userEmail,
	}

	body, _ := json.Marshal(payload)
	req, _ := http.NewRequestWithContext(ctx, "POST", s.BaseURL+"/aggregation/connect-sessions", bytes.NewBuffer(body))
	
	req.Header.Set("Authorization", "Bearer "+accessToken)
	s.setHeaders(req)

	resp, err := s.Client.Do(req)
	if err != nil {
		return "", fmt.Errorf("connect session request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		log.Printf("[Bridge Error] Connect Session Failed: %s", string(respBody))
		return "", fmt.Errorf("bridge connect error (%d): %s", resp.StatusCode, string(respBody))
	}

	var result struct {
		URL string `json:"url"`
	}
	if err := json.Unmarshal(respBody, &result); err != nil {
		return "", fmt.Errorf("connect decode error: %w", err)
	}

	return result.URL, nil
}

// 3. Get Providers
type BridgeProvider struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	CountryCode string `json:"country_code"`
	Images      struct {
		Logo string `json:"logo"`
	} `json:"images"`
}

func (s *BridgeService) GetBanks(ctx context.Context) ([]BridgeProvider, error) {
	req, _ := http.NewRequestWithContext(ctx, "GET", s.BaseURL+"/providers?country_code=FR", nil)
	s.setHeaders(req)

	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("status %d", resp.StatusCode)
	}

	var result struct {
		Resources []BridgeProvider `json:"resources"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Resources, nil
}

// 4. Get Items
type BridgeItem struct {
	ID          int64  `json:"id"`
	Status      int    `json:"status"`
	ProviderID  int    `json:"provider_id"`
}

func (s *BridgeService) GetItems(ctx context.Context, userEmail string) ([]BridgeItem, error) {
	accessToken, err := s.getOrCreateUserToken(ctx, userEmail)
	if err != nil {
		return nil, err
	}

	req, _ := http.NewRequestWithContext(ctx, "GET", s.BaseURL+"/aggregation/items", nil)
	req.Header.Set("Authorization", "Bearer "+accessToken)
	s.setHeaders(req)

	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		b, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("status %d: %s", resp.StatusCode, string(b))
	}

	var result struct {
		Resources []BridgeItem `json:"resources"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Resources, nil
}

// 5. Get Accounts
type BridgeAccount struct {
	ID       int64   `json:"id"`
	ItemID   int64   `json:"item_id"`
	Name     string  `json:"name"`
	Balance  float64 `json:"balance"`
	Currency string  `json:"currency_code"`
	IBAN     string  `json:"iban"`
}

func (s *BridgeService) GetAccounts(ctx context.Context, userEmail string) ([]BridgeAccount, error) {
	accessToken, err := s.getOrCreateUserToken(ctx, userEmail)
	if err != nil {
		return nil, err
	}

	req, _ := http.NewRequestWithContext(ctx, "GET", s.BaseURL+"/aggregation/accounts", nil)
	req.Header.Set("Authorization", "Bearer "+accessToken)
	s.setHeaders(req)

	resp, err := s.Client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		b, _ := io.ReadAll(resp.Body)
		log.Printf("[Bridge Error] Get Accounts: %s", string(b))
		return nil, fmt.Errorf("status %d: %s", resp.StatusCode, string(b))
	}

	var result struct {
		Resources []BridgeAccount `json:"resources"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Resources, nil
}

// 6. Refresh
func (s *BridgeService) RefreshAccounts(ctx context.Context, userEmail string, itemID int64) error {
	accessToken, err := s.getOrCreateUserToken(ctx, userEmail)
	if err != nil {
		return err
	}

	req, _ := http.NewRequestWithContext(ctx, "POST", fmt.Sprintf("%s/aggregation/items/%d/refresh", s.BaseURL, itemID), nil)
	req.Header.Set("Authorization", "Bearer "+accessToken)
	s.setHeaders(req)

	resp, err := s.Client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 && resp.StatusCode != 202 {
		b, _ := io.ReadAll(resp.Body)
		log.Printf("[Bridge Error] Refresh: %s", string(b))
		return fmt.Errorf("status %d", resp.StatusCode)
	}

	return nil
}

// 7. Get Transactions
type BridgeTransaction struct {
	ID          int64   `json:"id"`
	AccountID   int64   `json:"account_id"`
	Amount      float64 `json:"amount"`
	Currency    string  `json:"currency_code"`
	Description string  `json:"clean_description"`
	Date        string  `json:"date"` // YYYY-MM-DD
}

func (s *BridgeService) GetTransactions(ctx context.Context, userEmail string, accountIDs []string) ([]BridgeTransaction, error) {
	accessToken, err := s.getOrCreateUserToken(ctx, userEmail)
	if err != nil {
		return nil, err
	}

	// Calculer la date d'il y a 40 jours (Format ISO 8601 Requis par Bridge)
	sinceDate := time.Now().AddDate(0, 0, -40).Format(time.RFC3339)

	var allTransactions []BridgeTransaction
	
	// URL initiale avec filtre de date
	nextURI := fmt.Sprintf("/aggregation/transactions?limit=50&sort=-date&since=%s", sinceDate)

	// Boucle de pagination
	for nextURI != "" {
		fullURL := s.BaseURL + strings.TrimPrefix(nextURI, "/v3")
		if strings.HasPrefix(nextURI, "http") {
			fullURL = nextURI
		}

		req, _ := http.NewRequestWithContext(ctx, "GET", fullURL, nil)
		req.Header.Set("Authorization", "Bearer "+accessToken)
		s.setHeaders(req)

		resp, err := s.Client.Do(req)
		if err != nil {
			return nil, err
		}
		
		bodyBytes, _ := io.ReadAll(resp.Body)
		resp.Body.Close()

		if resp.StatusCode != 200 {
			log.Printf("[Bridge Error] Transactions: %s", string(bodyBytes))
			return nil, fmt.Errorf("bridge error %d", resp.StatusCode)
		}

		var result struct {
			Resources  []BridgeTransaction `json:"resources"`
			Pagination struct {
				NextURI *string `json:"next_uri"` // Pointeur pour gÃ©rer null
			} `json:"pagination"`
		}
		
		if err := json.Unmarshal(bodyBytes, &result); err != nil {
			return nil, err
		}

		allTransactions = append(allTransactions, result.Resources...)

		if result.Pagination.NextURI != nil && *result.Pagination.NextURI != "" && *result.Pagination.NextURI != "null" {
			nextURI = *result.Pagination.NextURI
		} else {
			nextURI = ""
		}
	}

	return allTransactions, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\budget.go
=========================================
package services

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"budget-api/models"
	"budget-api/utils"

	"github.com/google/uuid"
)

type BudgetService struct {
	db *sql.DB
}

func NewBudgetService(db *sql.DB) *BudgetService {
	return &BudgetService{db: db}
}

// Helper struct for DB storage of encrypted blobs
type EncryptedData struct {
	Encrypted string `json:"encrypted"`
}

// Create creates a new budget with transactional safety
func (s *BudgetService) Create(ctx context.Context, name, ownerID string) (*models.Budget, error) {
	budget := &models.Budget{
		ID:        uuid.New().String(),
		Name:      name,
		OwnerID:   ownerID,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	err := utils.WithTransaction(s.db, func(tx *sql.Tx) error {
		// 1. Insert Budget
		query := `
			INSERT INTO budgets (id, name, owner_id, created_at, updated_at)
			VALUES ($1, $2, $3, $4, $5)
		`
		if _, err := tx.ExecContext(ctx, query, budget.ID, budget.Name, budget.OwnerID, budget.CreatedAt, budget.UpdatedAt); err != nil {
			return err
		}

		// 2. Add Owner as Member
		memberQuery := `
			INSERT INTO budget_members (id, budget_id, user_id, role, joined_at)
			VALUES ($1, $2, $3, $4, $5)
		`
		if _, err := tx.ExecContext(ctx, memberQuery, uuid.New().String(), budget.ID, ownerID, "owner", time.Now()); err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return budget, nil
}

// GetByID gets a budget by ID
func (s *BudgetService) GetByID(ctx context.Context, id, userID string) (*models.Budget, error) {
	query := `
		SELECT b.id, b.name, b.owner_id, b.created_at, b.updated_at,
		       CASE WHEN b.owner_id = $2 THEN true ELSE false END as is_owner,
		       u.name as owner_name
		FROM budgets b
		LEFT JOIN users u ON b.owner_id = u.id
		INNER JOIN budget_members bm ON b.id = bm.budget_id
		WHERE b.id = $1 AND bm.user_id = $2
	`

	var budget models.Budget
	err := s.db.QueryRowContext(ctx, query, id, userID).Scan(
		&budget.ID,
		&budget.Name,
		&budget.OwnerID,
		&budget.CreatedAt,
		&budget.UpdatedAt,
		&budget.IsOwner,
		&budget.OwnerName,
	)

	if err != nil {
		return nil, err
	}

	// Get members
	members, err := s.GetMembers(ctx, id)
	if err != nil {
		return nil, err
	}
	budget.Members = members

	return &budget, nil
}

// GetUserBudgets gets all budgets for a user
func (s *BudgetService) GetUserBudgets(ctx context.Context, userID string) ([]models.Budget, error) {
	query := `
		SELECT b.id, b.name, b.owner_id, b.created_at, b.updated_at,
		       CASE WHEN b.owner_id = $1 THEN true ELSE false END as is_owner
		FROM budgets b
		INNER JOIN budget_members bm ON b.id = bm.budget_id
		WHERE bm.user_id = $1
		ORDER BY b.created_at DESC
	`

	rows, err := s.db.QueryContext(ctx, query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var budgets []models.Budget
	for rows.Next() {
		var budget models.Budget
		err := rows.Scan(
			&budget.ID,
			&budget.Name,
			&budget.OwnerID,
			&budget.CreatedAt,
			&budget.UpdatedAt,
			&budget.IsOwner,
		)
		if err != nil {
			return nil, err
		}

		members, _ := s.GetMembers(ctx, budget.ID)
		budget.Members = members

		budgets = append(budgets, budget)
	}

	return budgets, nil
}

// Update updates a budget name
func (s *BudgetService) Update(ctx context.Context, id, name string) error {
	query := `
		UPDATE budgets
		SET name = $1, updated_at = $2
		WHERE id = $3
	`
	_, err := s.db.ExecContext(ctx, query, name, time.Now(), id)
	return err
}

// Delete deletes a budget completely
func (s *BudgetService) Delete(ctx context.Context, budgetID string) error {
	return utils.WithTransaction(s.db, func(tx *sql.Tx) error {
		// Delete related records first
		if _, err := tx.ExecContext(ctx, "DELETE FROM budget_members WHERE budget_id = $1", budgetID); err != nil { return err }
		if _, err := tx.ExecContext(ctx, "DELETE FROM invitations WHERE budget_id = $1", budgetID); err != nil { return err }
		if _, err := tx.ExecContext(ctx, "DELETE FROM budget_data WHERE budget_id = $1", budgetID); err != nil { return err }
		// Delete budget
		if _, err := tx.ExecContext(ctx, "DELETE FROM budgets WHERE id = $1", budgetID); err != nil { return err }
		return nil
	})
}

// GetData gets the data for a budget and DECRYPTS it
func (s *BudgetService) GetData(ctx context.Context, budgetID string) (interface{}, error) {
	query := `SELECT data FROM budget_data WHERE budget_id = $1 ORDER BY updated_at DESC LIMIT 1`

	var rawJSON []byte
	err := s.db.QueryRowContext(ctx, query, budgetID).Scan(&rawJSON)
	if err == sql.ErrNoRows {
		return map[string]interface{}{}, nil
	}
	if err != nil {
		return nil, err
	}

	if len(rawJSON) == 0 {
		return map[string]interface{}{}, nil
	}

	// 1. Try to unmarshal as EncryptedData wrapper
	var wrapper EncryptedData
	if err := json.Unmarshal(rawJSON, &wrapper); err == nil && wrapper.Encrypted != "" {
		// 2. It IS encrypted -> Decrypt it
		decryptedBytes, err := utils.Decrypt(wrapper.Encrypted)
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt data: %w", err)
		}
		
		// 3. Unmarshal the real data
		var realData interface{}
		if err := json.Unmarshal(decryptedBytes, &realData); err != nil {
			return nil, err
		}
		return realData, nil
	}

	// Fallback: If it wasn't encrypted (legacy data), return it as is
	var data interface{}
	if err := json.Unmarshal(rawJSON, &data); err != nil {
		return nil, err
	}

	return data, nil
}

// UpdateData ENCRYPTS the data before saving it
func (s *BudgetService) UpdateData(ctx context.Context, budgetID string, data interface{}) error {
	// 1. Convert real data to JSON bytes
	realDataJSON, err := json.Marshal(data)
	if err != nil {
		return err
	}

	// 2. Encrypt the bytes
	encryptedString, err := utils.Encrypt(realDataJSON)
	if err != nil {
		return err
	}

	// 3. Wrap in a JSON object so Postgres JSONB column accepts it
	wrapper := EncryptedData{Encrypted: encryptedString}
	storageJSON, err := json.Marshal(wrapper)
	if err != nil {
		return err
	}

	// 4. Save to DB
	var existingID string
	checkQuery := `SELECT id FROM budget_data WHERE budget_id = $1 LIMIT 1`
	err = s.db.QueryRowContext(ctx, checkQuery, budgetID).Scan(&existingID)

	if err == sql.ErrNoRows {
		insertQuery := `
			INSERT INTO budget_data (id, budget_id, data, version, updated_at)
			VALUES ($1, $2, $3, 1, $4)
		`
		_, err = s.db.ExecContext(ctx, insertQuery, uuid.New().String(), budgetID, storageJSON, time.Now())
		return err
	}

	if err != nil {
		return err
	}

	updateQuery := `
		UPDATE budget_data
		SET data = $1, version = version + 1, updated_at = $2
		WHERE budget_id = $3
	`
	_, err = s.db.ExecContext(ctx, updateQuery, storageJSON, time.Now(), budgetID)
	return err
}

// GetMembers gets all members of a budget (Populates Avatar)
func (s *BudgetService) GetMembers(ctx context.Context, budgetID string) ([]models.BudgetMember, error) {
	query := `
		SELECT bm.id, bm.user_id, bm.role, bm.joined_at, u.name, u.email, COALESCE(u.avatar, '')
		FROM budget_members bm
		JOIN users u ON bm.user_id = u.id
		WHERE bm.budget_id = $1
		ORDER BY bm.joined_at
	`

	rows, err := s.db.QueryContext(ctx, query, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var members []models.BudgetMember
	for rows.Next() {
		var member models.BudgetMember
		var avatar string

		err := rows.Scan(
			&member.ID,
			&member.UserID,
			&member.Role,
			&member.JoinedAt,
			&member.UserName,
			&member.UserEmail,
			&avatar,
		)
		if err != nil {
			return nil, err
		}
		
		member.User = &models.User{
			ID:    member.UserID,
			Name:  member.UserName,
			Email: member.UserEmail,
			Avatar: avatar,
		}
		
		members = append(members, member)
	}

	return members, nil
}

// CreateInvitation creates an invitation
func (s *BudgetService) CreateInvitation(ctx context.Context, budgetID, email, invitedBy string) (*models.Invitation, error) {
	invitation := &models.Invitation{
		ID:        uuid.New().String(),
		BudgetID:  budgetID,
		Email:     email,
		Token:     uuid.New().String(),
		Status:    "pending",
		InvitedBy: invitedBy,
		ExpiresAt: time.Now().Add(7 * 24 * time.Hour),
		CreatedAt: time.Now(),
	}

	query := `
		INSERT INTO invitations (id, budget_id, email, token, status, invited_by, expires_at, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
	`

	_, err := s.db.ExecContext(ctx, query,
		invitation.ID, invitation.BudgetID, invitation.Email,
		invitation.Token, invitation.Status, invitation.InvitedBy,
		invitation.ExpiresAt, invitation.CreatedAt,
	)

	if err != nil {
		return nil, err
	}

	return invitation, nil
}

// GetPendingInvitation gets a pending invitation
func (s *BudgetService) GetPendingInvitation(ctx context.Context, budgetID, email string) (*models.Invitation, error) {
	query := `
		SELECT id, budget_id, email, token, expires_at, created_at
		FROM invitations
		WHERE budget_id = $1 AND email = $2 AND status = 'pending' AND expires_at > NOW()
		LIMIT 1
	`

	var invitation models.Invitation
	err := s.db.QueryRowContext(ctx, query, budgetID, email).Scan(
		&invitation.ID,
		&invitation.BudgetID,
		&invitation.Email,
		&invitation.Token,
		&invitation.ExpiresAt,
		&invitation.CreatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil
	}

	if err != nil {
		return nil, err
	}

	return &invitation, nil
}

// DeleteInvitation deletes an invitation
func (s *BudgetService) DeleteInvitation(ctx context.Context, invitationID string) error {
	query := `DELETE FROM invitations WHERE id = $1`
	_, err := s.db.ExecContext(ctx, query, invitationID)
	return err
}

// IsMemberByEmail checks if an email is already a member of a budget
func (s *BudgetService) IsMemberByEmail(ctx context.Context, budgetID, email string) (bool, error) {
    query := `
        SELECT EXISTS(
            SELECT 1 FROM budget_members bm
            JOIN users u ON bm.user_id = u.id
            WHERE bm.budget_id = $1 AND u.email = $2
        )
    `
    var exists bool
    err := s.db.QueryRowContext(ctx, query, budgetID, email).Scan(&exists)
    return exists, err
}

// AcceptInvitation accepts invitation, cleans up duplicates, and notifies others via "fake update"
func (s *BudgetService) AcceptInvitation(ctx context.Context, token, userID string) error {
	var invitation models.Invitation
	query := `
		SELECT id, budget_id, email, expires_at
		FROM invitations
		WHERE token = $1 AND status = 'pending'
	`

	err := s.db.QueryRowContext(ctx, query, token).Scan(
		&invitation.ID,
		&invitation.BudgetID,
		&invitation.Email,
		&invitation.ExpiresAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return sql.ErrNoRows
		}
		return err
	}

	if time.Now().After(invitation.ExpiresAt) {
		return sql.ErrNoRows
	}

	return utils.WithTransaction(s.db, func(tx *sql.Tx) error {
        // 1. Get User Name for Notification
        var userName string
        if err := tx.QueryRowContext(ctx, "SELECT name FROM users WHERE id = $1", userID).Scan(&userName); err != nil {
            return err
        }

		// 2. Add Member
		memberQuery := `
			INSERT INTO budget_members (id, budget_id, user_id, role, joined_at)
			VALUES ($1, $2, $3, $4, $5)
		`
		if _, err := tx.ExecContext(ctx, memberQuery, uuid.New().String(), invitation.BudgetID, userID, "member", time.Now()); err != nil {
			return err
		}

		// 3. Mark CURRENT invitation accepted
		updateQuery := `
			UPDATE invitations
			SET status = 'accepted', updated_at = $1
			WHERE id = $2
		`
		if _, err := tx.ExecContext(ctx, updateQuery, time.Now(), invitation.ID); err != nil {
			return err
		}

        // 4. CLEANUP: Delete pending invites for this email
        cleanupQuery := `DELETE FROM invitations WHERE budget_id = $1 AND email = $2 AND status = 'pending'`
        if _, err := tx.ExecContext(ctx, cleanupQuery, invitation.BudgetID, invitation.Email); err != nil {
            return err
        }

        // 5. NOTIFICATION TRIGGER: Update budget metadata (forces polling frontend to notice a change)
        timestamp := time.Now().Format(time.RFC3339)
        notifyQuery := `
            UPDATE budget_data 
            SET data = data || jsonb_build_object('lastUpdated', $1::text, 'updatedBy', $2::text),
                version = version + 1,
                updated_at = NOW()
            WHERE budget_id = $3
        `
        tx.ExecContext(ctx, notifyQuery, timestamp, userName, invitation.BudgetID)

		return nil
	})
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\categorizer.go
=========================================
package services

import (
	"context"
	"database/sql"
	"log"
	"strings"
)

type CategorizerService struct {
	db *sql.DB
	ai *AICategorizer
}

func NewCategorizerService(db *sql.DB) *CategorizerService {
	return &CategorizerService{
		db: db,
		ai: NewAICategorizer(),
	}
}

// --- STATIC DICTIONARY (Gratuit) ---
var staticRules = map[string]string{
	// ENERGIE
	"edf": "ENERGY", "engie": "ENERGY", "total energie": "ENERGY", "totalenergies": "ENERGY",
	"eni": "ENERGY", "ilek": "ENERGY", "sowee": "ENERGY", "veolia": "ENERGY", "suez": "ENERGY",
	
	// TELECOM
	"orange": "INTERNET", "sosh": "MOBILE", "sfr": "INTERNET", "red by sfr": "MOBILE",
	"bouygues": "INTERNET", "bbox": "INTERNET", "free": "INTERNET", "free mobile": "MOBILE",
	
	// ASSURANCE
	"axa": "INSURANCE", "allianz": "INSURANCE", "macif": "INSURANCE", "maif": "INSURANCE",
	"matmut": "INSURANCE", "groupama": "INSURANCE", "maaf": "INSURANCE", "alan": "INSURANCE",
	
	// BANQUE
	"boursorama": "BANK", "boursobank": "BANK", "revolut": "BANK", "n26": "BANK",
	"bnp": "BANK", "societe generale": "BANK", "credit agricole": "BANK", "lcl": "BANK",
	
	// LOISIRS
	"netflix": "LEISURE", "spotify": "LEISURE", "deezer": "LEISURE", "apple": "LEISURE",
	"disney": "LEISURE", "prime video": "LEISURE", "basic fit": "LEISURE", "fitness park": "LEISURE",
	
	// ALIMENTATION
	"leclerc": "FOOD", "carrefour": "FOOD", "auchan": "FOOD", "intermarche": "FOOD",
	"lidl": "FOOD", "aldi": "FOOD", "monoprix": "FOOD", "franprix": "FOOD", "uber eats": "FOOD",
	
	// TRANSPORT
	"sncf": "TRANSPORT", "ratp": "TRANSPORT", "uber": "TRANSPORT", "bolt": "TRANSPORT",
	"total access": "TRANSPORT", "shell": "TRANSPORT", "vinci": "TRANSPORT",
}

// GetCategory dÃ©termine la catÃ©gorie
func (s *CategorizerService) GetCategory(ctx context.Context, rawLabel string) (string, error) {
	// 1. Normalisation
	normalizedLabel := strings.ToLower(strings.TrimSpace(rawLabel))
	if normalizedLabel == "" {
		return "OTHER", nil
	}

	// 2. RÃ¨gles Statiques
	if category, exists := staticRules[normalizedLabel]; exists {
		return category, nil
	}
	for key, cat := range staticRules {
		if strings.Contains(normalizedLabel, key) {
			return cat, nil
		}
	}

	// 3. Cache DB
	var dbCategory string
	err := s.db.QueryRowContext(ctx, 
		"SELECT category FROM label_mappings WHERE normalized_label = $1", 
		normalizedLabel).Scan(&dbCategory)

	if err == nil {
		return dbCategory, nil
	}

	// 4. Appel Claude AI
	log.Printf("[Categorizer] Calling Claude AI for '%s'...", normalizedLabel)
	aiCategory, err := s.ai.PredictCategory(rawLabel)
	
	if err != nil {
		log.Printf("[Categorizer] AI Error: %v", err)
		return "OTHER", nil 
	}

	// 5. Sauvegarde Cache
	go func(lbl, cat string) {
		_, err := s.db.Exec(
			"INSERT INTO label_mappings (normalized_label, category, source) VALUES ($1, $2, 'AI') ON CONFLICT (normalized_label) DO NOTHING",
			lbl, cat,
		)
		if err != nil {
			log.Printf("[Categorizer] Failed to cache: %v", err)
		}
	}(normalizedLabel, aiCategory)

	return aiCategory, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\email.go
=========================================
package services

import (
	"budget-api/utils"
)

// EmailService struct
type EmailService struct {
}

// NewEmailService constructor
func NewEmailService() *EmailService {
	return &EmailService{}
}

// SendInvitation wrapper qui appelle la fonction dans utils
func (s *EmailService) SendInvitation(toEmail, inviterName, budgetName, invitationToken string) error {
	return utils.SendInvitationEmail(toEmail, inviterName, budgetName, invitationToken)
}

// SendVerification wrapper qui appelle la fonction dans utils
func (s *EmailService) SendVerification(toEmail, userName, token string) error {
	return utils.SendVerificationEmail(toEmail, userName, token)
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\enable_banking.go
=========================================
package services

import (
	"bytes"
	"context"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

type EnableBankingService struct {
	BaseURL    string
	AppID      string
	PrivateKey *rsa.PrivateKey
	Client     *http.Client
}

func NewEnableBankingService() *EnableBankingService {
	log.Println("ðŸ” Initializing Enable Banking Service...")
	
	appID := os.Getenv("ENABLE_BANKING_APP_ID")
	if appID == "" {
		log.Fatal("âŒ ENABLE_BANKING_APP_ID environment variable is not set")
	}
	log.Printf("âœ… App ID configured: %s...", appID[:8])
	
	privateKey := loadPrivateKey()
	
	return &EnableBankingService{
		BaseURL:    "https://api.enablebanking.com",
		AppID:      appID,
		PrivateKey: privateKey,
		Client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

func loadPrivateKey() *rsa.PrivateKey {
	log.Println("ðŸ”‘ Loading private key...")
	var pemData []byte
	
	if base64Key := os.Getenv("ENABLE_BANKING_PRIVATE_KEY_BASE64"); base64Key != "" {
		log.Println("ðŸ“¦ Found ENABLE_BANKING_PRIVATE_KEY_BASE64 in environment")
		log.Printf("ðŸ“ Base64 key length: %d characters", len(base64Key))
		
		decoded, err := base64.StdEncoding.DecodeString(base64Key)
		if err != nil {
			log.Printf("âŒ Failed to decode base64 private key: %v", err)
			log.Fatal("Base64 decoding failed - check if the key is properly encoded")
		}
		log.Printf("âœ… Successfully decoded base64 key, PEM length: %d bytes", len(decoded))
		pemData = decoded
	} else if keyPath := os.Getenv("ENABLE_BANKING_PRIVATE_KEY_PATH"); keyPath != "" {
		log.Printf("ðŸ“ Loading private key from file: %s", keyPath)
		data, err := os.ReadFile(keyPath)
		if err != nil {
			log.Fatal("Failed to read private key file:", err)
		}
		log.Printf("âœ… Successfully read key file, size: %d bytes", len(data))
		pemData = data
	} else {
		log.Fatal("âŒ No private key configured. Set ENABLE_BANKING_PRIVATE_KEY_BASE64 or ENABLE_BANKING_PRIVATE_KEY_PATH")
	}

	log.Println("ðŸ” Parsing PEM block...")
	block, _ := pem.Decode(pemData)
	if block == nil {
		log.Printf("âŒ PEM data preview (first 100 chars): %s", string(pemData[:min(100, len(pemData))]))
		log.Fatal("Failed to parse PEM block - the data might not be in PEM format")
	}
	log.Printf("âœ… PEM block type: %s", block.Type)

	log.Println("ðŸ”‘ Parsing RSA private key...")
	
	key, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	if err == nil {
		privateKey, ok := key.(*rsa.PrivateKey)
		if !ok {
			log.Fatal("âŒ Key is not an RSA private key")
		}
		log.Printf("âœ… Successfully parsed PKCS8 private key, size: %d bits", privateKey.N.BitLen())
		return privateKey
	}
	
	log.Printf("âš ï¸  PKCS8 parsing failed: %v, trying PKCS1...", err)
	
	privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		log.Printf("âŒ PKCS1 parsing also failed: %v", err)
		log.Fatal("Failed to parse private key in both PKCS8 and PKCS1 formats")
	}
	
	log.Printf("âœ… Successfully parsed PKCS1 private key, size: %d bits", privateKey.N.BitLen())
	return privateKey
}

func (s *EnableBankingService) generateJWT() (string, error) {
	now := time.Now()
	
	claims := jwt.MapClaims{
		"iss": "enablebanking.com",
		"aud": "api.enablebanking.com",
		"iat": now.Unix(),
		"exp": now.Add(5 * time.Minute).Unix(),
	}

	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	token.Header["kid"] = s.AppID
	
	signedToken, err := token.SignedString(s.PrivateKey)
	if err != nil {
		log.Printf("âŒ JWT signing failed: %v", err)
		return "", fmt.Errorf("failed to sign JWT: %w", err)
	}

	log.Printf("âœ… JWT token generated successfully with kid=%s (length: %d)", s.AppID[:8]+"...", len(signedToken))
	return signedToken, nil
}

func (s *EnableBankingService) setHeaders(req *http.Request) error {
	jwtToken, err := s.generateJWT()
	if err != nil {
		return err
	}

	req.Header.Set("Authorization", "Bearer "+jwtToken)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	return nil
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// ========== STRUCTS ==========

type SandboxUser struct {
	Username string `json:"username"`
	Password string `json:"password"`
	OTP      string `json:"otp"`
}

type SandboxInfo struct {
	Users []SandboxUser `json:"users"`
}

type ASPSP struct {
	Name        string       `json:"name"`
	Country     string       `json:"country"`
	BIC         string       `json:"bic,omitempty"`
	Logo        string       `json:"logo"`
	Sandbox     *SandboxInfo `json:"sandbox,omitempty"`
	Beta        bool         `json:"beta"`
}

type Access struct {
	ValidUntil string `json:"valid_until"`
}

type ASPSPIdentifier struct {
	Name    string `json:"name"`
	Country string `json:"country"`
}

type AuthRequest struct {
	Access      Access          `json:"access"`
	ASPSP       ASPSPIdentifier `json:"aspsp"`
	State       string          `json:"state"`
	RedirectURL string          `json:"redirect_url"`
	PSUType     string          `json:"psu_type"`
}

type AuthResponse struct {
	AuthURL string `json:"url"`
	State   string `json:"authorization_id"`
}

type SessionRequest struct {
	Code  string `json:"code"`
	State string `json:"state,omitempty"`
}

type AccountIdentification struct {
	IBAN  string `json:"iban,omitempty"`
	Other *struct {
		Identification string `json:"identification"`
		SchemeName     string `json:"scheme_name"`
	} `json:"other,omitempty"`
}

type Account struct {
	AccountID       AccountIdentification `json:"account_id"`
	Name            string                `json:"name"`
	Currency        string                `json:"currency"`
	CashAccountType string                `json:"cash_account_type"`
	Details         string                `json:"details,omitempty"`
	Product         string                `json:"product,omitempty"`
	UID             string                `json:"uid,omitempty"`
}

type SessionResponse struct {
	SessionID string    `json:"session_id"`
	Accounts  []Account `json:"accounts"`
	ASPSP     struct {
		Name    string `json:"name"`
		Country string `json:"country"`
	} `json:"aspsp"`
	PSUType string `json:"psu_type"`
}

type AmountType struct {
	Currency string `json:"currency"`
	Amount   string `json:"amount"`
}

type Balance struct {
	Name          string     `json:"name"`
	BalanceAmount AmountType `json:"balance_amount"`
	BalanceType   string     `json:"balance_type"`
	ReferenceDate string     `json:"reference_date,omitempty"`
}

type BalancesResponse struct {
	Balances []Balance `json:"balances"`
}

// TRANSACTION STRUCTURES pour le mapping
type Transaction struct {
	EntryReference        string     `json:"entry_reference,omitempty"`
	TransactionID         string     `json:"transaction_id,omitempty"`
	TransactionAmount     AmountType `json:"transaction_amount"`
	CreditDebitIndicator  string     `json:"credit_debit_indicator"`
	Status                string     `json:"status"`
	BookingDate           string     `json:"booking_date,omitempty"`
	ValueDate             string     `json:"value_date,omitempty"`
	TransactionDate       string     `json:"transaction_date,omitempty"`
	CreditorName          string     `json:"creditor,omitempty"`
	DebtorName            string     `json:"debtor,omitempty"`
	RemittanceInfo        string     `json:"remittance_information,omitempty"`
	BalanceAfterTransaction AmountType `json:"balance_after_transaction,omitempty"`
}

type TransactionsResponse struct {
	Transactions []Transaction `json:"transactions"`
	ContinuationKey string `json:"continuation_key,omitempty"`
}

// ========== API METHODS ==========

func (s *EnableBankingService) GetASPSPs(ctx context.Context, country string) ([]ASPSP, error) {
	url := s.BaseURL + "/aspsps"
	if country != "" {
		url += "?country=" + country
	}

	log.Printf("ðŸŒ Fetching ASPSPs from: %s", url)

	req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err := s.setHeaders(req); err != nil {
		log.Printf("âŒ Failed to set headers: %v", err)
		return nil, err
	}

	log.Println("ðŸ“¤ Sending request to Enable Banking API...")
	resp, err := s.Client.Do(req)
	if err != nil {
		log.Printf("âŒ HTTP request failed: %v", err)
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	log.Printf("ðŸ“¥ Response status: %d", resp.StatusCode)

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Printf("âŒ Failed to read response body: %v", err)
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != 200 {
		log.Printf("âŒ API Error Response: %s", string(respBody))
		return nil, fmt.Errorf("status %d: %s", resp.StatusCode, string(respBody))
	}

	log.Printf("âœ… Received response, size: %d bytes", len(respBody))

	var response struct {
		ASPSPs []ASPSP `json:"aspsps"`
	}
	
	if err := json.Unmarshal(respBody, &response); err != nil {
		log.Printf("âŒ JSON parsing failed: %v", err)
		return nil, fmt.Errorf("failed to parse JSON: %w", err)
	}

	log.Printf("âœ… Successfully parsed %d ASPSPs", len(response.ASPSPs))
	return response.ASPSPs, nil
}

func (s *EnableBankingService) CreateAuthRequest(ctx context.Context, req AuthRequest) (*AuthResponse, error) {
	log.Printf("ðŸ” Creating auth request for %s (%s)", req.ASPSP.Name, req.ASPSP.Country)
	
	body, _ := json.Marshal(req)
	httpReq, _ := http.NewRequestWithContext(ctx, "POST", s.BaseURL+"/auth", bytes.NewBuffer(body))
	if err := s.setHeaders(httpReq); err != nil {
		log.Printf("âŒ Failed to set headers: %v", err)
		return nil, err
	}

	log.Println("ðŸ“¤ Sending auth request...")
	resp, err := s.Client.Do(httpReq)
	if err != nil {
		log.Printf("âŒ HTTP request failed: %v", err)
		return nil, err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	log.Printf("ðŸ“¥ Auth response status: %d", resp.StatusCode)

	if resp.StatusCode != 200 {
		log.Printf("âŒ Auth Error: %s", string(respBody))
		return nil, fmt.Errorf("auth request failed (%d): %s", resp.StatusCode, string(respBody))
	}

	var authResp AuthResponse
	if err := json.Unmarshal(respBody, &authResp); err != nil {
		log.Printf("âŒ Failed to parse auth response: %v", err)
		return nil, err
	}

	log.Printf("âœ… Auth URL generated")
	return &authResp, nil
}

func (s *EnableBankingService) CreateSession(ctx context.Context, code, state string) (*SessionResponse, error) {
	log.Printf("ðŸ” Creating session with code and state")
	
	payload := SessionRequest{
		Code:  code,
		State: state,
	}

	body, _ := json.Marshal(payload)
	req, _ := http.NewRequestWithContext(ctx, "POST", s.BaseURL+"/sessions", bytes.NewBuffer(body))
	if err := s.setHeaders(req); err != nil {
		log.Printf("âŒ Failed to set headers: %v", err)
		return nil, err
	}

	log.Println("ðŸ“¤ Sending session creation request...")
	resp, err := s.Client.Do(req)
	if err != nil {
		log.Printf("âŒ HTTP request failed: %v", err)
		return nil, err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	log.Printf("ðŸ“¥ Session response status: %d", resp.StatusCode)

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		log.Printf("âŒ Session Error: %s", string(respBody))
		return nil, fmt.Errorf("session creation failed (%d): %s", resp.StatusCode, string(respBody))
	}

	var sessionResp SessionResponse
	if err := json.Unmarshal(respBody, &sessionResp); err != nil {
		log.Printf("âŒ Failed to parse session response: %v", err)
		return nil, err
	}

	log.Printf("âœ… Session created: %s with %d accounts", sessionResp.SessionID, len(sessionResp.Accounts))
	
	for i, acc := range sessionResp.Accounts {
		iban := acc.AccountID.IBAN
		if iban == "" && acc.AccountID.Other != nil {
			iban = acc.AccountID.Other.Identification
		}
		log.Printf("   ðŸ“Š Account %d: %s | IBAN: %s | UID: %s", i+1, acc.Name, iban, acc.UID)
	}
	
	return &sessionResp, nil
}

func (s *EnableBankingService) GetBalances(ctx context.Context, sessionID, accountUID string) ([]Balance, error) {
	url := fmt.Sprintf("%s/accounts/%s/balances", s.BaseURL, accountUID)
	log.Printf("ðŸ’° Fetching balances for account UID: %s", accountUID)
	
	req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err := s.setHeaders(req); err != nil {
		log.Printf("âŒ Failed to set headers: %v", err)
		return nil, err
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		log.Printf("âŒ HTTP request failed: %v", err)
		return nil, err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	log.Printf("ðŸ“¥ Balances response status: %d", resp.StatusCode)

	if resp.StatusCode != 200 {
		log.Printf("âŒ Error response: %s", string(respBody))
		return nil, fmt.Errorf("status %d: %s", resp.StatusCode, string(respBody))
	}

	var balancesResp BalancesResponse
	if err := json.Unmarshal(respBody, &balancesResp); err != nil {
		log.Printf("âŒ Failed to parse balances: %v", err)
		return nil, err
	}

	log.Printf("âœ… Retrieved %d balances", len(balancesResp.Balances))
	for i, bal := range balancesResp.Balances {
		log.Printf("   ðŸ’° Balance %d: %s = %s %s", i+1, bal.Name, bal.BalanceAmount.Amount, bal.BalanceAmount.Currency)
	}
	
	return balancesResp.Balances, nil
}

func (s *EnableBankingService) GetTransactions(ctx context.Context, sessionID, accountUID string, dateFrom, dateTo string) ([]Transaction, error) {
	url := fmt.Sprintf("%s/accounts/%s/transactions", s.BaseURL, accountUID)
	if dateFrom != "" && dateTo != "" {
		url += fmt.Sprintf("?date_from=%s&date_to=%s", dateFrom, dateTo)
	}
	
	log.Printf("ðŸ’³ Fetching transactions for account: %s", accountUID)

	req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err := s.setHeaders(req); err != nil {
		return nil, err
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		log.Printf("âŒ HTTP request failed: %v", err)
		return nil, err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != 200 {
		log.Printf("âŒ Error response: %s", string(respBody))
		return nil, fmt.Errorf("status %d: %s", resp.StatusCode, string(respBody))
	}

	var transResp TransactionsResponse
	if err := json.Unmarshal(respBody, &transResp); err != nil {
		log.Printf("âŒ Failed to parse transactions: %v", err)
		return nil, err
	}

	log.Printf("âœ… Retrieved %d transactions", len(transResp.Transactions))
	return transResp.Transactions, nil
}

func (s *EnableBankingService) DeleteSession(ctx context.Context, sessionID string) error {
	url := fmt.Sprintf("%s/sessions/%s", s.BaseURL, sessionID)
	log.Printf("ðŸ—‘ï¸  Deleting session: %s", sessionID)
	
	req, _ := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err := s.setHeaders(req); err != nil {
		return err
	}

	resp, err := s.Client.Do(req)
	if err != nil {
		log.Printf("âŒ HTTP request failed: %v", err)
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 && resp.StatusCode != 204 {
		respBody, _ := io.ReadAll(resp.Body)
		log.Printf("âŒ Delete failed: %s", string(respBody))
		return fmt.Errorf("delete failed (%d): %s", resp.StatusCode, string(respBody))
	}

	log.Println("âœ… Session deleted successfully")
	return nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\services\suggestions.go
=========================================
package services

import (
	"budget-api/models"
	"fmt"
	"strings"
)

type SuggestionService struct{}

func NewSuggestionService() *SuggestionService {
	return &SuggestionService{}
}

// Logic pour dÃ©terminer si une dÃ©pense mÃ©rite une affiliation
func (s *SuggestionService) AnalyzeCharges(charges []models.Charge) []models.Suggestion {
	var suggestions []models.Suggestion

	// 1. Groupement pour les dÃ©penses "Foyer" (ex: Energie, Internet)
	// On veut savoir si le foyer paie trop cher au total, mÃªme si c'est divisÃ© en deux prÃ©lÃ¨vements
	householdCategories := map[string]float64{
		"ENERGY":   0,
		"INTERNET": 0,
		"INSURANCE": 0, // Souvent habitation = foyer
	}

	// 2. Analyse Individuelle (ex: Mobile, Sport)
	// On analyse chaque ligne sÃ©parÃ©ment
	for _, c := range charges {
		category := strings.ToUpper(c.Category)
		
		// Si c'est une catÃ©gorie foyer, on cumule d'abord
		if _, isHousehold := householdCategories[category]; isHousehold {
			householdCategories[category] += c.Amount
		} else {
			// Analyse immÃ©diate pour les charges individuelles
			if sugg := s.evaluateIndividualCharge(c); sugg != nil {
				suggestions = append(suggestions, *sugg)
			}
		}
	}

	// 3. Analyse des totaux Foyer
	for cat, totalAmount := range householdCategories {
		if sugg := s.evaluateHouseholdTotal(cat, totalAmount); sugg != nil {
			suggestions = append(suggestions, *sugg)
		}
	}

	return suggestions
}

func (s *SuggestionService) evaluateIndividualCharge(c models.Charge) *models.Suggestion {
	// MOBILE : Si > 25â‚¬, c'est cher aujourd'hui
	if c.Category == "MOBILE" && c.Amount > 25 {
		return &models.Suggestion{
			ID:               "sug_" + c.ID,
			ChargeID:         c.ID,
			Type:             "MOBILE_SWITCH",
			Title:            "Forfait Mobile Optimisable",
			Message:          fmt.Sprintf("Vous payez %.0fâ‚¬/mois. Des forfaits 50Go existent dÃ¨s 10â‚¬.", c.Amount),
			PotentialSavings: (c.Amount - 10) * 12,
			ActionLink:       "https://www.ariase.com/mobile", // Ã€ remplacer par lien trackÃ©
			CanBeContacted:   false,
		}
	}
	// LOAN : Si > 500â‚¬, vÃ©rifier l'assurance emprunteur
	if c.Category == "LOAN" && c.Amount > 500 {
		return &models.Suggestion{
			ID:               "sug_" + c.ID,
			ChargeID:         c.ID,
			Type:             "LOAN_INSURANCE",
			Title:            "Assurance Emprunteur",
			Message:          "Sur un gros crÃ©dit, changer d'assurance peut rapporter gros.",
			PotentialSavings: 1500, // Estimation
			ActionLink:       "https://www.meilleurtaux.com/",
			CanBeContacted:   true,
		}
	}
	return nil
}

func (s *SuggestionService) evaluateHouseholdTotal(category string, amount float64) *models.Suggestion {
	// ENERGY : Si foyer > 120â‚¬ / mois
	if category == "ENERGY" && amount > 120 {
		return &models.Suggestion{
			ID:               "sug_household_energy",
			Type:             "ENERGY_SWITCH",
			Title:            "Facture Ã‰nergie Ã‰levÃ©e",
			Message:          fmt.Sprintf("Le foyer paie %.0fâ‚¬/mois. Comparez les fournisseurs.", amount),
			PotentialSavings: (amount * 0.15) * 12, // ~15% d'Ã©conomie
			ActionLink:       "https://www.papernest.com/energie/",
			CanBeContacted:   true,
		}
	}
	// INTERNET : Si > 45â‚¬ / mois
	if category == "INTERNET" && amount > 45 {
		return &models.Suggestion{
			ID:               "sug_household_net",
			Type:             "BOX_SWITCH",
			Title:            "Box Internet",
			Message:          "Plus de 45â‚¬/mois ? La fibre commence Ã  20â‚¬ la premiÃ¨re annÃ©e.",
			PotentialSavings: (amount - 25) * 12,
			ActionLink:       "https://www.ariase.com/box",
			CanBeContacted:   false,
		}
	}
	return nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\.env
=========================================
# Database Configuration
DATABASE_URL=postgresql://budget_db_uz3l_user:DfWCVdVQulVBIe0L6XvDcpyadrNyRQIl@dpg-d4n1379r0fns73ajeob0-a/budget_db_uz3l

# JWT Configuration
JWT_SECRET=change-this-to-a-random-secret-key-in-production
JWT_EXPIRY=15m
REFRESH_EXPIRY=168h

# Frontend URL (for CORS and email links)
FRONTEND_URL=http://localhost:3000

# Email Configuration (Resend)
RESEND_API_KEY=re_JU9a2NB3_7T4Fkwz5YuJGw1trYHfkNW3j
FROM_EMAIL=Budget Famille <noreply@budgetfamille.com>

# Server Configuration
PORT=8080
ENVIRONMENT=development
DATA_ENCRYPTION_KEY=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\crypto.go
=========================================
package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"io"
	"os"
)

// Encrypt encrypts a plain string/bytes and returns a base64 encoded ciphertext
func Encrypt(plaintext []byte) (string, error) {
	key := os.Getenv("DATA_ENCRYPTION_KEY")
	if len(key) != 32 {
		return "", errors.New("DATA_ENCRYPTION_KEY must be exactly 32 characters")
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return "", err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return "", err
	}

	ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Decrypt takes a base64 encoded ciphertext and returns the original bytes
func Decrypt(cryptoText string) ([]byte, error) {
	key := os.Getenv("DATA_ENCRYPTION_KEY")
	if len(key) != 32 {
		return nil, errors.New("DATA_ENCRYPTION_KEY must be exactly 32 characters")
	}

	ciphertext, err := base64.StdEncoding.DecodeString(cryptoText)
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, err
	}

	return plaintext, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\email.go
=========================================
package utils

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
)

type EmailRequest struct {
	From    string   `json:"from"`
	To      []string `json:"to"`
	Subject string   `json:"subject"`
	HTML    string   `json:"html"`
}

// SendInvitationEmail envoie l'email d'invitation
func SendInvitationEmail(toEmail, inviterName, budgetName, invitationToken string) error {
	frontendURL := os.Getenv("FRONTEND_URL")
	if frontendURL == "" {
		frontendURL = "http://localhost:3000"
	}

	invitationLink := fmt.Sprintf("%s/invitation/accept?token=%s", frontendURL, invitationToken)

	htmlBody := fmt.Sprintf(`
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: sans-serif; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .button { display: inline-block; background: #667eea; color: white; padding: 15px 30px; text-decoration: none; border-radius: 8px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Invitation Budget</h1>
        <p><strong>%s</strong> vous invite sur <strong>"%s"</strong>.</p>
        <a href="%s" class="button">Accepter l'invitation</a>
    </div>
</body>
</html>
	`, inviterName, budgetName, invitationLink)

	return sendEmail(toEmail, fmt.Sprintf("%s vous invite Ã  collaborer", inviterName), htmlBody)
}

// SendVerificationEmail envoie l'email de vÃ©rification
func SendVerificationEmail(toEmail, userName, token string) error {
	frontendURL := os.Getenv("FRONTEND_URL")
	if frontendURL == "" {
		frontendURL = "http://localhost:3000"
	}

	verifyLink := fmt.Sprintf("%s/verify-email?token=%s", frontendURL, token)

	htmlBody := fmt.Sprintf(`
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: sans-serif; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .button { display: inline-block; background: #10b981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h2>Bienvenue %s !</h2>
        <p>Veuillez vÃ©rifier votre email pour activer votre compte.</p>
        <a href="%s" class="button">VÃ©rifier mon email</a>
    </div>
</body>
</html>
	`, userName, verifyLink)

	return sendEmail(toEmail, "VÃ©rifiez votre compte", htmlBody)
}

// sendEmail (fonction privÃ©e)
func sendEmail(to, subject, htmlBody string) error {
	apiKey := os.Getenv("RESEND_API_KEY")
	if apiKey == "" {
		return fmt.Errorf("RESEND_API_KEY not set")
	}

	fromEmail := os.Getenv("FROM_EMAIL")
	if fromEmail == "" {
		fromEmail = "Budget Famille <noreply@budgetfamille.com>"
	}

	emailReq := EmailRequest{
		From:    fromEmail,
		To:      []string{to},
		Subject: subject,
		HTML:    htmlBody,
	}

	jsonData, err := json.Marshal(emailReq)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", "https://api.resend.com/emails", bytes.NewBuffer(jsonData))
	if err != nil {
		return err
	}

	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("email API status: %d", resp.StatusCode)
	}

	return nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\jwt.go
=========================================
package utils

import (
	"fmt"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

type Claims struct {
	UserID string `json:"user_id"`
	Email  string `json:"email"`
	jwt.RegisteredClaims
}

func GenerateAccessToken(userID, email string) (string, error) {
	secret := os.Getenv("JWT_SECRET")
	if secret == "" {
		return "", fmt.Errorf("JWT_SECRET not set")
	}

	expiryStr := os.Getenv("JWT_EXPIRY")
	if expiryStr == "" {
		expiryStr = "15m"
	}

	expiry, err := time.ParseDuration(expiryStr)
	if err != nil {
		expiry = 15 * time.Minute
	}

	claims := Claims{
		UserID: userID,
		Email:  email,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiry)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
			Issuer:    "budget-api",
			Subject:   userID,
			ID:        uuid.New().String(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(secret))
}

func GenerateRefreshToken() (string, error) {
	return uuid.New().String(), nil
}

func ValidateToken(tokenString string) (*Claims, error) {
	secret := os.Getenv("JWT_SECRET")
	if secret == "" {
		return nil, fmt.Errorf("JWT_SECRET not set")
	}

	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(secret), nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(*Claims); ok && token.Valid {
		return claims, nil
	}

	return nil, fmt.Errorf("invalid token")
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\password.go
=========================================
package utils

import (
	"golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(bytes), err
}

func CheckPassword(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\totp.go
=========================================
package utils

import (
	"github.com/pquerna/otp/totp"
)

func GenerateTOTPSecret(email string) (string, string, error) {
	key, err := totp.Generate(totp.GenerateOpts{
		Issuer:      "Budget Famille",
		AccountName: email,
	})
	if err != nil {
		return "", "", err
	}

	return key.Secret(), key.URL(), nil
}

func VerifyTOTP(secret, code string) (bool, error) {
	valid := totp.Validate(code, secret)
	return valid, nil
}



=========================================
FILE PATH: C:\Users\libasse.dia\Documents\budget\budget-api\utils\transaction.go
=========================================
package utils

import (
	"database/sql"
	"fmt"
)

// WithTransaction executes a function within a database transaction
func WithTransaction(db *sql.DB, fn func(*sql.Tx) error) error {
	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	defer func() {
		if p := recover(); p != nil {
			tx.Rollback()
			panic(p) // Re-throw panic after rollback
		}
	}()

	if err := fn(tx); err != nil {
		tx.Rollback()
		return err
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}



